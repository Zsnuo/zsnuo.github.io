{"meta":{"title":"Zsnuo's Blog","subtitle":"Living is do or die.","description":null,"author":"Zsnuo","url":"http://yoursite.com"},"pages":[{"title":"Tags","date":"2018-05-20T12:50:26.000Z","updated":"2018-05-20T12:52:13.989Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"Links","date":"2018-05-20T12:53:14.000Z","updated":"2018-05-21T06:22:47.000Z","comments":false,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"「 onion_cyc 」 世界上最可爱的男孩子。 「 Sakits 」 TJM是机房的红太阳！ 「 Blue233333 」 林队队是机房的蓝月亮！ 「 Child-Single 」沉迷讲师的LJK。 「 Cholorop 」Duck Game高玩杜老师。 「 orzccz 」日常qwq的YY。 「 L_0_Forever_LF 」根本无法同台竞技的LCD。 「 cgh_Andy 」跟名字完全不符合的菜菜。 「 Ra1nbow 」跟栋栋给给的CYS。"},{"title":"About","date":"2018-05-20T12:53:14.000Z","updated":"2018-05-21T08:41:04.358Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"高二，一只即将退役的OIer，坐标东南沿海某偏远山区学校。 现在已经跟妹子过上了幸福快乐的生活。 现博客搭建于2018年5月20日，初衷是想要有一个实用好看的区域可以给自己记录。 以及一只旧的Zsnuo，有一些东西应该还是会放在旧博客。 以上。"}],"posts":[{"title":"「ARC 063F」Snuke's Coloring 2","slug":"arc063f","date":"2018-05-22T06:22:45.000Z","updated":"2018-05-22T06:31:04.152Z","comments":true,"path":"2018/05/22/arc063f/","link":"","permalink":"http://yoursite.com/2018/05/22/arc063f/","excerpt":"给定一个 W×HW\\times HW×H 的二维平面，初始均为白色，有 nnn 个关键点 (xi,yi)(x_{i},y_{i})(xi​,yi​) ，对于每一个关键点选择一个方向，并将该方向上的所有网格涂成黑色。易得操作后白色部分一定是一个矩形，请最大化矩形周长。","text":"给定一个 W×HW\\times HW×H 的二维平面，初始均为白色，有 nnn 个关键点 (xi,yi)(x_{i},y_{i})(xi​,yi​) ，对于每一个关键点选择一个方向，并将该方向上的所有网格涂成黑色。易得操作后白色部分一定是一个矩形，请最大化矩形周长。 Constraints 0≤n≤2⋅1050 \\leq n \\leq 2 \\cdot 10^50≤n≤2⋅105 ，1≤w,h≤1081 \\leq w,h \\leq 10^81≤w,h≤108 Solution 观察可以得到一个性质，答案矩形一定会经过直线 x=W2x=\\frac{W}{2}x=2W​ 或 y=H2y=\\frac{H}{2}y=2H​ 。两种情况可以用相同的方式处理出答案。 将坐标离散化后，枚举矩形的上下边界，可以直接计算出矩形的左右边界。考虑用线段树进行优化。左右各开一个单调栈，在维护单调栈时在线段树上进行区间加减即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long long#define lc(x) x&lt;&lt;1#define rc(x) x&lt;&lt;1|1using namespace std;const int N=3e5+5;int w,h,n,ans,L,R;int mx[N*4],tag[N*4];struct node&#123;int x,y;node(int _x=0,int _y=0):x(_x),y(_y)&#123;&#125;;&#125;p[N],a[N],b[N]; int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void modify(int x,int l,int r,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;mx[x]+=v;tag[x]+=v;return;&#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(lc(x),l,mid,v); if(R&gt;mid)modify(rc(x),mid+1,r,v); mx[x]=max(mx[lc(x)],mx[rc(x)])+tag[x];&#125;bool cmp(node a,node b)&#123;return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);&#125;void work()&#123; memset(mx,0,sizeof(mx)); memset(tag,0,sizeof(tag)); sort(p+1,p+n+1,cmp); int l=0,r=0; for(int i=1;i&lt;=n-1;i++) &#123; if(p[i].y&lt;=h/2) &#123; int nxt=i-1; while(l&amp;&amp;a[l].y&lt;p[i].y) &#123; L=a[l].x;R=nxt;nxt=a[l].x-1; modify(1,1,n,a[l].y-p[i].y);l--; &#125; if(nxt!=i-1)a[++l]=node(nxt+1,p[i].y); &#125; else &#123; int nxt=i-1; while(r&amp;&amp;b[r].y&gt;p[i].y) &#123; L=b[r].x;R=nxt;nxt=b[r].x-1; modify(1,1,n,p[i].y-b[r].y);r--; &#125; if(nxt!=i-1)b[++r]=node(nxt+1,p[i].y); &#125; a[++l]=node(i,0);b[++r]=node(i,h); L=i;R=i;modify(1,1,n,h-p[i].x); ans=max(ans,mx[1]+p[i+1].x); &#125;&#125;int main()&#123; w=read();h=read();n=read(); for(int i=1;i&lt;=n;i++)p[i].x=read(),p[i].y=read(); p[++n]=node(0,0);p[++n]=node(w,h);work(); for(int i=1;i&lt;=n;i++)swap(p[i].x,p[i].y); swap(w,h);work(); printf(\"%d\",ans*2); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"单调栈","slug":"单调栈","permalink":"http://yoursite.com/tags/单调栈/"}]},{"title":"「BZOJ 4449」[Neerc2015]Distance on Triangulation","slug":"bzoj4449","date":"2018-05-22T06:15:40.000Z","updated":"2018-05-22T06:20:55.091Z","comments":true,"path":"2018/05/22/bzoj4449/","link":"","permalink":"http://yoursite.com/2018/05/22/bzoj4449/","excerpt":"给定一个凸 nnn 边形，以及它的三角剖分。再给定 qqq 个询问，每个询问是一对凸多边行上的顶点 (a,b)(a,b)(a,b) ，问点 aaa 最少经过多少条边(可以是多边形上的边，也可以是剖分上的边)可以到达点 bbb 。","text":"给定一个凸 nnn 边形，以及它的三角剖分。再给定 qqq 个询问，每个询问是一对凸多边行上的顶点 (a,b)(a,b)(a,b) ，问点 aaa 最少经过多少条边(可以是多边形上的边，也可以是剖分上的边)可以到达点 bbb 。 Constraints n≤50000n \\leq 50000n≤50000 ，q≤100000q \\leq 100000q≤100000 Solution 运用分治的思想，每一次选择一条剖分边，使得凸多边形分成尽量平均的两部分。使用 bfsbfsbfs 得出该条边的两个端点到各个顶点的最短路，对所有的询问在两个端点处进行拼凑并更新答案。然后对两部分的信息分别划开，进行下一层的分治。 （每次分治完，点数会比原来多 222 ，所以空间要开三倍。） Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=3e5+5;const int inf=0x3f3f3f3f;int n,m,cnt,x,y,t,tmp;int first[N],ans[N],id[N];int qq[N],disx[N],disy[N],q1[N],q2[N];bool ok[N];struct node&#123;int x,y,id;&#125;l[N],q[N],h1[N],h2[N];struct edge&#123;int to,next;&#125;e[N&lt;&lt;1];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int find(int l,int r,int x)&#123;return lower_bound(id+l,id+r+1,x)-id;&#125;void bfs(int S,int pl,int pr,int *dis)&#123; int head=0,tail=0; for(int i=pl;i&lt;=pr;i++)dis[id[i]]=inf; qq[tail++]=S;dis[S]=0; while(head!=tail) &#123; int u=qq[head++]; for(int i=first[u];i;i=e[i].next) &#123; int to=e[i].to; if(!ok[to])continue; if(dis[to]==inf)dis[to]=dis[u]+1,qq[tail++]=to; &#125; &#125; &#125;void work(int dl,int dr,int pl,int pr,int ql,int qr)&#123; if(dl&gt;dr||pl&gt;pr||ql&gt;qr)return; int mn=inf,mnid=0; for(int i=dl;i&lt;=dr;i++) &#123; x=find(pl,pr,l[i].x);y=find(pl,pr,l[i].y); if(x&gt;y)swap(x,y); tmp=max(y-x,x-y+pr-pl+1); if(tmp&lt;mn)mn=tmp,mnid=i; &#125; for(int i=pl;i&lt;=pr;i++)ok[id[i]]=true; bfs(l[mnid].x,pl,pr,disx); bfs(l[mnid].y,pl,pr,disy); for(int i=pl;i&lt;=pr;i++)ok[id[i]]=false; int t1=0,t2=0,t3=0,t4=0,t5=0,t6=0; for(int i=ql;i&lt;=qr;i++) &#123; x=q[i].x;y=q[i].y;t=q[i].id; if(x==l[mnid].x&amp;&amp;y==l[mnid].y)&#123;ans[t]=1;continue;&#125; ans[t]=min(ans[t],disx[x]+disx[y]); ans[t]=min(ans[t],disy[x]+disy[y]); ans[t]=min(ans[t],disx[x]+disy[y]+1); ans[t]=min(ans[t],disy[x]+disx[y]+1); if(q[i].x&gt;l[mnid].x&amp;&amp;q[i].y&lt;l[mnid].y)h1[++t1]=q[i]; else if((q[i].x&lt;l[mnid].x||q[i].x&gt;l[mnid].y)&amp;&amp; (q[i].y&lt;l[mnid].x||q[i].y&gt;l[mnid].y))h2[++t2]=q[i]; &#125; for(int i=1;i&lt;=t1;i++)q[ql+i-1]=h1[i]; for(int i=1;i&lt;=t2;i++)q[ql+t1+i-1]=h2[i]; for(int i=pl;i&lt;=pr;i++) &#123; if(id[i]&gt;=l[mnid].x&amp;&amp;id[i]&lt;=l[mnid].y)q1[++t3]=id[i]; if(id[i]&lt;=l[mnid].x||id[i]&gt;=l[mnid].y)q2[++t4]=id[i]; &#125; for(int i=1;i&lt;=t3;i++)id[pl+i-1]=q1[i]; for(int i=1;i&lt;=t4;i++)id[pl+t3+i-1]=q2[i]; for(int i=dl;i&lt;=dr;i++) &#123; if(i==mnid)continue; if(l[i].x&gt;=l[mnid].x&amp;&amp;l[i].y&lt;=l[mnid].y)h1[++t5]=l[i]; else h2[++t6]=l[i]; &#125; for(int i=1;i&lt;=t5;i++)l[dl+i-1]=h1[i]; for(int i=1;i&lt;=t6;i++)l[dl+t5+i-1]=h2[i]; work(dl+t5,dl+t5+t6-1,pl+t3,pl+t3+t4-1,ql+t1,ql+t1+t2-1); work(dl,dl+t5-1,pl,pl+t3-1,ql,ql+t1-1); &#125;int main()&#123; n=read(); for(int i=1;i&lt;=n-3;i++) &#123; l[i].x=read();l[i].y=read(); ins(l[i].x,l[i].y);ins(l[i].y,l[i].x); if(l[i].x&gt;l[i].y)swap(l[i].x,l[i].y); &#125; for(int i=1;i&lt;n;i++)ins(i,i+1),ins(i+1,i); ins(1,n);ins(n,1); m=read(); for(int i=1;i&lt;=m;i++) &#123; q[i].x=read();q[i].y=read();q[i].id=i; if(q[i].x&gt;q[i].y)swap(q[i].x,q[i].y); ans[i]=min(q[i].y-q[i].x,q[i].x-q[i].y+n); &#125; for(int i=1;i&lt;=n;i++)id[i]=i; work(1,n-3,1,n,1,m); for(int i=1;i&lt;=m;i++)printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/分治/"},{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}]},{"title":"「BZOJ 4833」[Lydsy1704月赛]最小公倍佩尔数","slug":"bzoj4833","date":"2018-05-21T23:33:38.000Z","updated":"2018-05-22T05:20:34.646Z","comments":true,"path":"2018/05/22/bzoj4833/","link":"","permalink":"http://yoursite.com/2018/05/22/bzoj4833/","excerpt":"令 (1+2)n=e(n)+2⋅f(n)(1+\\sqrt 2)^n=e(n)+\\sqrt 2\\cdot f(n)(1+2​)n=e(n)+2​⋅f(n) ，其中 e(n),f(n)e(n),f(n)e(n),f(n) 都是整数，显然有 (1−2)n=e(n)−2⋅f(n)(1-\\sqrt 2)^n=e(n)-\\sqrt 2\\cdot f(n)(1−2​)n=e(n)−2​⋅f(n)。令 g(n)g(n)g(n) 表示 f(1),f(2),⋯,f(n)f(1),f(2),\\cdots ,f(n)f(1),f(2),⋯,f(n) 的最小公倍数，给定两个正整数 nnn 和 ppp ，其中 ppp 是质数，并且保证 f(1),f(2),⋯,f(n)f(1),f(2),\\cdots ,f(n)f(1),f(2),⋯,f(n) 在模 ppp 意义下均不为 000，请计算 ∑i=1ni⋅g(i)\\sum _{i=1}^{n}i\\cdot g(i)∑i=1n​i⋅g(i) 模 ppp 的值。","text":"令 (1+2)n=e(n)+2⋅f(n)(1+\\sqrt 2)^n=e(n)+\\sqrt 2\\cdot f(n)(1+2​)n=e(n)+2​⋅f(n) ，其中 e(n),f(n)e(n),f(n)e(n),f(n) 都是整数，显然有 (1−2)n=e(n)−2⋅f(n)(1-\\sqrt 2)^n=e(n)-\\sqrt 2\\cdot f(n)(1−2​)n=e(n)−2​⋅f(n)。令 g(n)g(n)g(n) 表示 f(1),f(2),⋯,f(n)f(1),f(2),\\cdots ,f(n)f(1),f(2),⋯,f(n) 的最小公倍数，给定两个正整数 nnn 和 ppp ，其中 ppp 是质数，并且保证 f(1),f(2),⋯,f(n)f(1),f(2),\\cdots ,f(n)f(1),f(2),⋯,f(n) 在模 ppp 意义下均不为 000，请计算 ∑i=1ni⋅g(i)\\sum _{i=1}^{n}i\\cdot g(i)∑i=1n​i⋅g(i) 模 ppp 的值。 Constraints T≤210T \\leq 2 ^{10}T≤210 ，1≤n≤1061\\leq n \\leq 10 ^61≤n≤106 ，2≤p≤109+72\\leq p \\leq 10 ^9 +72≤p≤109+7 Solution 在开始推导前先观察两个式子： gcd(fib(a),fib(b))=fib(gcd(a,b))gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(xa−1,xb−1)=xgcd(a,b)−1gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1 gcd(xa−1,xb−1)=xgcd(a,b)−1 形如 f(n)=a⋅f(n−1)+b⋅f(n−2)f(n)=a\\cdot f(n-1)+b\\cdot f(n-2)f(n)=a⋅f(n−1)+b⋅f(n−2) 的式子具有性质 gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y)) 。 而题目中的式子等价于： f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)f(0)=0,f(1)=1,f(n)=2f(n-1)+f(n-2)f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)，同样满足这个性质。 （以下集合 TTT 均满足 $T\\neq \\varnothing $） 再由式子： lcm(S)=∏T⊂Sgcd(T)(−1)∣T∣+1lcm(S)=\\prod_{T\\subset S}gcd(T)^{(-1)^{|T|+1}} lcm(S)=T⊂S∏​gcd(T)(−1)∣T∣+1 可以得到： g(n)=∏T⊂2[n]f(gcdi∈T(i))(−1)∣T∣+1g(n)=\\prod _{T\\subset 2^{[n]}}f(gcd_{i\\in T}(i))^{(-1)^{|T|+1}} g(n)=T⊂2[n]∏​f(gcdi∈T​(i))(−1)∣T∣+1 构造出 hhh 满足 f(n)=∏d∣nh(d)f(n)=\\prod _{d|n}h(d)f(n)=∏d∣n​h(d) 得到式子： g(n)=∏T⊂2[n](∏d∣gcdi∈T(i)h(d))(−1)∣T∣+1=∏d=1nh(d)∑T⊂2 [⌊nd⌋] (−1)∣T∣+1\\begin{aligned} g(n)&amp;=\\prod _{T\\subset 2^{[n]}}\\left ( \\prod _{d|gcd_{i\\in T}(i)}h(d) \\right )^{(-1)^{|T|+1}}\\\\ &amp;=\\prod _{d=1}^{n}h(d)^{\\sum _{T\\subset 2^{~[\\lfloor \\frac{n}{d}\\rfloor ]~}}(-1)^{|T|+1}} \\end{aligned} g(n)​=T⊂2[n]∏​⎝⎛​d∣gcdi∈T​(i)∏​h(d)⎠⎞​(−1)∣T∣+1=d=1∏n​h(d)∑T⊂2 [⌊dn​⌋] ​(−1)∣T∣+1​ 又由二项式定理可证： ∑T⊂2[⌊nd⌋](−1)∣T∣+1=−∑i=1nd(−1)i(ndi)=1\\sum _{T\\subset 2^{[\\lfloor \\frac{n}{d}\\rfloor ]}}(-1)^{|T|+1}=-\\sum _{i=1}^{\\frac{n}{d}}(-1)^i\\binom{\\frac{n}{d}}{i}=1 T⊂2[⌊dn​⌋]∑​(−1)∣T∣+1=−i=1∑dn​​(−1)i(idn​​)=1 所以 g(n)=∏d=1nh(d)g(n)=\\prod _{d=1}^{n}h(d)g(n)=∏d=1n​h(d) 问题解决，时间复杂度 O(nlogn)O(nlogn)O(nlogn)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;int T,n,mod,inv,sum,ans,f[N],h[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; T=read(); while(T--) &#123; n=read();mod=read(); f[0]=0;h[1]=f[1]=1; for(int i=2;i&lt;=n;i++) h[i]=f[i]=(1ll*f[i-1]*2+f[i-2])%mod; for(int i=1;i&lt;=n;i++) &#123; inv=power(h[i],mod-2); for(int j=i+i;j&lt;=n;j+=i)h[j]=1ll*h[j]*inv%mod; &#125; sum=1;ans=0; for(int i=1;i&lt;=n;i++) sum=1ll*sum*h[i]%mod,ans=(ans+1ll*sum*i)%mod; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://yoursite.com/tags/容斥原理/"}]},{"title":"「BZOJ 2159」Crash的文明世界","slug":"bzoj2159","date":"2018-05-21T23:19:47.000Z","updated":"2018-05-22T05:22:45.103Z","comments":true,"path":"2018/05/22/bzoj2159/","link":"","permalink":"http://yoursite.com/2018/05/22/bzoj2159/","excerpt":"给定一棵 nnn 个节点的树，对于每个节点，计算出：S(i)=∑j=1ndist(i,j)k(mod10007)S(i)=\\sum _{j=1}^ndist(i,j)^k \\pmod {10007}S(i)=∑j=1n​dist(i,j)k(mod10007)。其中 dist(i,j)dist(i, j)dist(i,j) 表示第 iii 个节点到第 jjj 个节点路径上的边数，kkk 为一个常数且为正整数。","text":"给定一棵 nnn 个节点的树，对于每个节点，计算出：S(i)=∑j=1ndist(i,j)k(mod10007)S(i)=\\sum _{j=1}^ndist(i,j)^k \\pmod {10007}S(i)=∑j=1n​dist(i,j)k(mod10007)。其中 dist(i,j)dist(i, j)dist(i,j) 表示第 iii 个节点到第 jjj 个节点路径上的边数，kkk 为一个常数且为正整数。 Constraints n≤50000n \\leq 50000n≤50000 ，k≤150k \\leq 150k≤150 Solution 用结论来化简式子：xn=∑i=1nS(n,i)⋅F(x,i)x^n=\\sum _{i=1}^n S(n,i)\\cdot F(x,i)xn=∑i=1n​S(n,i)⋅F(x,i) S(n,i)S(n,i)S(n,i)为第二类斯特林数，F(x,i)=x!(x−i)!F(x,i)=\\frac{x!}{(x-i)!}F(x,i)=(x−i)!x!​ 可得： ans(i)=∑j=1ndist(i,j)m=∑j=1n∑k=1mS(m,k)⋅F(dist(i,j),k)=∑k=1mS(m,k)∑j=1nF(dist(i,j),k)=∑k=1mS(m,k)⋅k!⋅∑j=1nC(dist(i,j),k)\\begin{aligned} ans(i)&amp;=\\sum _{j=1}^ndist(i,j)^m\\\\ &amp;=\\sum_{j=1}^{n}\\sum_{k=1}^{m}S(m,k)\\cdot F(dist(i,j),k)\\\\ &amp;=\\sum_{k=1}^{m}S(m,k)\\sum_{j=1}^{n} F(dist(i,j),k)\\\\ &amp;=\\sum_{k=1}^{m}S(m,k)\\cdot k!\\cdot \\sum_{j=1}^{n} C(dist(i,j),k) \\end{aligned} ans(i)​=j=1∑n​dist(i,j)m=j=1∑n​k=1∑m​S(m,k)⋅F(dist(i,j),k)=k=1∑m​S(m,k)j=1∑n​F(dist(i,j),k)=k=1∑m​S(m,k)⋅k!⋅j=1∑n​C(dist(i,j),k)​ 根据组合数递推公式：C(n,m)=C(n−1,m)+C(n−1,m−1)C(n,m)=C(n-1,m)+C(n-1,m-1)C(n,m)=C(n−1,m)+C(n−1,m−1) 就可以很方便的对后面的部分进行树形dp了。 具体地，令 up(x,i)up(x,i)up(x,i) 为不在 xxx 的子树中的部分的贡献，令 dn(x,i)dn(x,i)dn(x,i) 为 xxx 的子树的贡献。特别的，dn(x,0)=1dn(x,0)=1dn(x,0)=1。 详见代码。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e4+5;const int M=155;const int mod=1e4+7;int n,m,u,v,cnt,ans,tmp;int first[N],fac[M],s[M][M];int up[N][M],dn[N][M];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void dfs1(int x,int fa)&#123; dn[x][0]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs1(to,x); Mod(dn[x][0],dn[to][0]); for(int j=1;j&lt;=m;j++) Mod(dn[x][j],(dn[to][j]+dn[to][j-1])%mod); &#125;&#125;void dfs2(int x,int fa)&#123; if(fa!=-1) &#123; up[x][0]=n-dn[x][0]; for(int i=1;i&lt;=m;i++) &#123; Mod(up[x][i],(up[fa][i]+up[fa][i-1])%mod); Mod(up[x][i],(dn[fa][i]+dn[fa][i-1])%mod); Mod(up[x][i],(2*mod-dn[x][i]-dn[x][i-1])%mod); Mod(up[x][i],(mod-dn[x][i-1])%mod); if(i!=1)Mod(up[x][i],(mod-dn[x][i-2])%mod); &#125; &#125; for(int i=first[x];i;i=e[i].next) if(e[i].to!=fa)dfs2(e[i].to,x);&#125;int main()&#123; int L,now,A,B,Q; n=read();m=read();L=read(); now=read();A=read();B=read();Q=read(); for(int i=1;i&lt;n;i++) &#123; now=(now*A+B)%Q; tmp=i&lt;L?i:L; u=i-now%tmp;v=i+1; ins(u,v);ins(v,u); &#125;// n=read();m=read();// for(int i=1;i&lt;n;i++)// &#123;// u=read();v=read();// ins(u,v);ins(v,u);// &#125; fac[0]=s[0][0]=1; for(int i=1;i&lt;=m;i++) &#123; fac[i]=fac[i-1]*i%mod; for(int j=1;j&lt;=i;j++) s[i][j]=(s[i-1][j]*j+s[i-1][j-1])%mod; &#125; dfs1(1,-1);dfs2(1,-1); for(int i=1;i&lt;=n;i++) &#123; ans=0; for(int j=1;j&lt;=m;j++) Mod(ans,s[m][j]*fac[j]%mod*(up[i][j]+dn[i][j])%mod); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"「BZOJ 3495」PA2010 Riddle","slug":"bzoj3495","date":"2018-05-21T23:10:11.000Z","updated":"2018-05-22T05:25:06.682Z","comments":true,"path":"2018/05/22/bzoj3495/","link":"","permalink":"http://yoursite.com/2018/05/22/bzoj3495/","excerpt":"有 nnn 个城镇被分成了 kkk 个郡，有 mmm 条连接城镇的无向边。要求给每个郡选择一个城镇作为首都，满足每条边至少有一个端点是首都。","text":"有 nnn 个城镇被分成了 kkk 个郡，有 mmm 条连接城镇的无向边。要求给每个郡选择一个城镇作为首都，满足每条边至少有一个端点是首都。 Constraints 1≤n≤1061\\leq n \\leq 10 ^61≤n≤106 ，0≤m≤1060\\leq m \\leq 10 ^60≤m≤106 ，1≤k≤n1\\leq k \\leq n1≤k≤n Solution 每个点 xxx 拆成两对点，xxx 代表选择 xxx 为首都，x+nx+nx+n 表示不选择 xxx 为首都，x+2nx+2nx+2n 表示 xxx 的前缀已包含首都，x+3nx+3nx+3n 表示 xxx 的前缀不包含首都。 对于每一条原图中无向边 (x,y)(x,y)(x,y) ，因为至少有一个端点为首都，连边 (x+n,y)(x+n,y)(x+n,y) ，(y+n,x)(y+n,x)(y+n,x)。 对于每一个点 xxx ，连边 (x,x+2n)(x,x+2n)(x,x+2n) ，(x+3n,x+n)(x+3n,x+n)(x+3n,x+n)。 对于每一个点 xxx 与它的上一个点 lastlastlast ，连边方式如下：(last+2n,x+2n)(last+2n,x+2n)(last+2n,x+2n)，(x+3n,last+3n)(x+3n,last+3n)(x+3n,last+3n)，(last+2n,x+n)(last+2n,x+n)(last+2n,x+n)，(x,last+3n)(x,last+3n)(x,last+3n)。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=4e6+5;int n,m,k,cnt,x,y,last,tim,top,color;int first[N],dfn[N],low[N],sta[N],c[N];bool vis[N];struct edge&#123;int to,next;&#125;e[N*3];void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++tim; sta[++top]=x;vis[x]=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!dfn[to])tarjan(to),low[x]=min(low[x],low[to]=min(low[x],low[to])); else if(vis[to])low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; color++; while(sta[top]!=x)vis[sta[top]]=false,c[sta[top--]]=color; vis[x]=false;c[x]=color;top--; &#125;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) if(c[i]==c[i+n]||c[i+2*n]==c[i+3*n])return false; return true;&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=m;i++) &#123; x=read();y=read(); ins(x+n,y);ins(y+n,x); &#125; for(int i=1;i&lt;=k;i++) &#123; x=read();last=0; for(int j=1;j&lt;=x;j++) &#123; y=read(); ins(y,y+2*n);ins(y+3*n,y+n); if(last) &#123; ins(last+2*n,y+2*n); ins(y+3*n,last+3*n); ins(last+2*n,y+n); ins(y,last+3*n); &#125; last=y; &#125; &#125; for(int i=1;i&lt;=4*n;i++)if(!dfn[i])tarjan(i); if(check())printf(\"TAK\"); else printf(\"NIE\"); return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"tarjan","slug":"tarjan","permalink":"http://yoursite.com/tags/tarjan/"}]},{"title":"「Codeforces 983E」NN country","slug":"cf983E","date":"2018-05-21T08:56:27.000Z","updated":"2018-05-22T05:02:00.693Z","comments":true,"path":"2018/05/21/cf983E/","link":"","permalink":"http://yoursite.com/2018/05/21/cf983E/","excerpt":"给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。","text":"给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。 Constraints 2≤n≤2⋅1052\\leq n \\leq 2\\cdot 10 ^52≤n≤2⋅105 ，1≤m≤2⋅1051\\leq m \\leq 2\\cdot 10 ^51≤m≤2⋅105 ，1≤q≤2⋅1051\\leq q \\leq 2\\cdot 10 ^51≤q≤2⋅105 Solution 对于每一条 aaa 与 bbb 间的路径，都可拆分为 aaa 到 lcalcalca 的路径和 bbb 到 lcalcalca 的路径 采用贪心策略， low[x][i]low[x][i]low[x][i] 表示从 xxx 点出发向上选择不超过 2i2^i2i 条链可抵达的深度最浅的点。这时对于每一个询问可将询问的两个端点修改为利用贪心策略跳到的深度大于 lcalcalca 且深度最小的节点，并记录下答案，这个过程可以用倍增完成。注意特判端点即 lcalcalca 的情况。 然后出现两种情况。若修改后的两个端点出现在同一条给定链上，答案为原答案 +1+1+1 ，否则答案为原答案 +2+2+2 。问题模型转换为，每次询问一个点对是否出现在同一条给定链上。记录下 dfsdfsdfs 序，在深搜过程中利用树状数组统计即可。 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int n,m,Q,cnt,val,x,y,ind;int deep[N],in[N],out[N],last[N];int first[N],ans[N],tr[N];int fa[N][20],low[N][20];bool ok[N];vector&lt;int&gt; a[N],b[N];struct edge&#123;int to,next;&#125;e[N];struct chain&#123;int x,y,t;&#125;c[N],q[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x)&#123; in[x]=++ind; for(int i=1;(1&lt;&lt;i)&lt;=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=first[x];i;i=e[i].next) &#123; deep[e[i].to]=deep[x]+1; dfs(e[i].to); &#125; out[x]=ind;&#125;int lca(int x,int y)&#123; if(deep[x]&lt;deep[y])swap(x,y); int d=deep[x]-deep[y]; for(int i=0;(1&lt;&lt;i)&lt;=d;i++) if((1&lt;&lt;i)&amp;d)x=fa[x][i]; if(x==y)return x; for(int i=17;i&gt;=0;i--) if((1&lt;&lt;i)&lt;=deep[x]&amp;&amp;fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfslow(int x)&#123; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to;dfslow(to); if(deep[low[to][0]]&lt;deep[low[x][0]]) low[x][0]=low[to][0]; &#125;&#125;int find(int x,int t)&#123; if(deep[low[x][17]]&gt;deep[t])&#123;val=-inf;return -1;&#125; if(x==t)&#123;val=-1;return 0;&#125; val=0; for(int i=17;i&gt;=0;i--) if(deep[low[x][i]]&gt;deep[t]) x=low[x][i],val|=(1&lt;&lt;i); return x;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x))tr[x]+=v;&#125;int query(int x)&#123;int ans=0;for(;x;x-=lowbit(x))ans+=tr[x];return ans;&#125;void work(int x)&#123; for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; last[t]=query(out[q[t].y])-query(in[q[t].y]-1); &#125; for(int sz=a[x].size(),i=0;i&lt;sz;i++)add(in[a[x][i]],1); for(int i=first[x];i;i=e[i].next)work(e[i].to); for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; if(query(out[q[t].y])-query(in[q[t].y]-1)!=last[t])ok[t]=true; &#125;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) fa[i][0]=read(),ins(fa[i][0],i); dfs(1); for(int i=1;i&lt;=n;i++)low[i][0]=i; m=read(); for(int i=1;i&lt;=m;i++) &#123; c[i].x=read();c[i].y=read(); c[i].t=lca(c[i].x,c[i].y); if(deep[c[i].t]&lt;deep[low[c[i].x][0]]) low[c[i].x][0]=c[i].t; if(deep[c[i].t]&lt;deep[low[c[i].y][0]]) low[c[i].y][0]=c[i].t; a[c[i].x].push_back(c[i].y); a[c[i].y].push_back(c[i].x); &#125; dfslow(1); for(int t=1;t&lt;=n;t++) for(int i=1;i&lt;=17;i++) low[t][i]=low[low[t][i-1]][i-1]; Q=read(); for(int i=1;i&lt;=Q;i++) &#123; q[i].x=read();q[i].y=read(); q[i].t=lca(q[i].x,q[i].y); ans[i]=2; x=find(q[i].x,q[i].t);ans[i]+=val; y=find(q[i].y,q[i].t);ans[i]+=val; if(x&gt;0&amp;&amp;y&gt;0) &#123; q[i].x=x;q[i].y=y; b[x].push_back(i); &#125; &#125; work(1); for(int i=1;i&lt;=Q;i++) if(ok[i])ans[i]--; for(int i=1;i&lt;=Q;i++) printf(\"%d\\n\",ans[i]&lt;0?-1:ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"},{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"},{"name":"最近公共祖先","slug":"最近公共祖先","permalink":"http://yoursite.com/tags/最近公共祖先/"}]}]}