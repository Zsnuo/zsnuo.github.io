{"meta":{"title":"Zsnuo's Blog","subtitle":"Living is do or die.","description":null,"author":"Zsnuo","url":"http://yoursite.com"},"pages":[{"title":"Links","date":"2018-05-20T12:53:14.000Z","updated":"2018-06-03T11:06:16.534Z","comments":false,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"「 onion_cyc 」 人生若只如初见。 「 Sakits 」 TJM是机房的红太阳！ 「 Blue233333 」 林队队是机房的蓝月亮！ 「 Child-Single 」沉迷讲师的LJK。 「 Cholorop 」Duck Game高玩杜老师。 「 orzccz 」日常qwq的YY。 「 L_0_Forever_LF 」根本无法同台竞技的LCD。 「 cgh_Andy 」跟名字完全不符合的菜菜。 「 Ra1nbow 」跟栋栋给给的CYS。"},{"title":"About","date":"2018-05-20T12:53:14.000Z","updated":"2018-05-31T22:25:18.708Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"高二，一只即将退役的OIer，坐标东南沿海某偏远山区学校。 现博客搭建于2018年5月20日，初衷是想要有一个实用好看的区域可以给自己记录。 以及一只旧的Zsnuo，有一些东西应该还是会放在旧博客。 以上。"},{"title":"Tags","date":"2018-05-20T12:50:26.000Z","updated":"2018-05-20T12:52:13.989Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"「学习笔记」计算几何相关","slug":"geometry","date":"2018-06-11T00:39:18.000Z","updated":"2018-06-11T06:19:06.748Z","comments":true,"path":"geometry/","link":"","permalink":"http://yoursite.com/geometry/","excerpt":"走上计算几何的漫漫不归路（雾）。","text":"走上计算几何的漫漫不归路（雾）。 基本概念 点积 a⋅b=∣a∣∣b∣cosθa\\cdot b=|a||b|cos\\theta a⋅b=∣a∣∣b∣cosθ 令 a=(x1,y1),b=(x2,y2)a=(x_1,y_1),b=(x_2,y_2)a=(x1​,y1​),b=(x2​,y2​) ，则它们的点积等于 x1x2+y1y2x_1x_2+y_1y_2x1​x2​+y1​y2​ 。 应用：两向量垂直，其点积为 000 。 叉积 a×b=∣a∣∣b∣sinθa\\times b=|a||b|sin\\theta a×b=∣a∣∣b∣sinθ 令 a=(x1,y1),b=(x2,y2)a=(x_1,y_1),b=(x_2,y_2)a=(x1​,y1​),b=(x2​,y2​) ，则它们的点积等于 x1y2−x2y1x_1y_2-x_2y_1x1​y2​−x2​y1​ 。 应用：叉积的几何意义为两向量 a,ba,ba,b 共起点时所构成平行四边形的面积。叉积 =0=0=0 ，两向量平行；叉积 &gt;0&gt;0&gt;0 ，向量 aaa 在向量 bbb 的顺时针方向；叉积 &lt;0&lt;0&lt;0 ，向量 aaa 在向量 bbb 的逆时针方向。 旋转向量 将向量 a=(x,y)a=(x,y)a=(x,y) 旋转 $\\theta $ 角度后，坐标为 (xcosθ−ysinθ,xsinθ+ycosθ)(x cos\\theta - y sin\\theta , x sin\\theta + y cos\\theta)(xcosθ−ysinθ,xsinθ+ycosθ) 。 证明：令向量 aaa 与 xxx 轴夹角为 $\\alpha $ ，则旋转之后夹角为 $\\alpha + \\theta $ 。利用 x=∣a∣cosαx=|a|cos \\alphax=∣a∣cosα 与 y=∣a∣sinαy=|a|sin \\alphay=∣a∣sinα 及和角公式可得证。 多边形的面积 若已知一个简单多边形的顶点按逆时针顺序依次为 P1,P2,⋯PnP_1,P_2,\\cdots P_nP1​,P2​,⋯Pn​ ，则其面积为： S=Pn×P1+∑i=1n−1Pi×Pi+12S=\\frac{P_n\\times P_1+\\sum _{i=1}^{n-1}P_i\\times P_{i+1}}{2} S=2Pn​×P1​+∑i=1n−1​Pi​×Pi+1​​ 极角排序 在平面上取一定点 OOO ，从 OOO 引一条水平射线 OxOxOx ，规定方向自左至右，再选定一个长度单位并规定角旋转的正方向，通常取逆时针方向，这样就构成了一个极坐标系。点 OOO 叫作极点，射线 OxOxOx 叫作极轴。 常见的极角排序方法有四种，这里给出利用叉积进行排序的代码（以原点为极点）。 12345678struct node&#123;double x,y;&#125;;double cross(double x1,double y1,double x2,double y2)&#123;return x1*y2-x2*y1;&#125;bool cmp(node a,node b)&#123; double cros=cross(a.x,a.y,b.x,b.y); if(fabs(cros)&lt;eps)return a.x&lt;b.x; return cros&gt;0;&#125; 凸包 Graham扫描法 一个点集的凸包就是能包围给定点的最小的凸多边形。 构造出点集的凸包的方式为：以点集中纵坐标最小的点为极点（纵坐标相同则横坐标最小，易得这个点一定在凸包上），其他点做极角排序，然后按照极角序扫描，加入一个点时利用叉积判断之前的点是否合法即可。 相关应用 查询一个点是否位于凸包内部：按照极角序二分出在哪两个点之间，判断一下是否在该线段内侧。 一条斜率为 kkk 的直线从正无穷远处向下平移，碰到的第一个点：在凸包上二分斜率。 支持插入操作的动态凸包：离线写法可以使用 cdq 分治，在线写法可以利用平衡树来维护。 坐标范围为 nnn 的整点凸包的点数上界： O(n23)O(n^{\\frac{2}{3}})O(n32​) 。 旋转卡壳 对踵点 如果过凸包上的两个点可以画一对平行直线，使凸包上的所有点都夹在两条平行线之间或落在平行线上，那么这两个点叫做一对对踵点。使用旋转卡壳算法可以求出凸多边形的所有对踵点。 算法原理 我们只需要维护两条平行直线中至少有一条卡住了一条边的情况，即可求出所有的对踵点。 枚举凸包上的每一条边，当它被一条直线卡住时，另一条直线一定卡住了离该边最远的点，且该点与该边的两个端点构成了两对对踵点。因为凸包上的点距离固定边的距离是单峰的，改变枚举边时只需要直接移动到对应点即可，且移动过程中经过的点都能与这两条相邻边的交点构成对踵点。时间复杂度 O(n)O(n)O(n) 。 应用 详见博客 《计算几何之旋转卡壳算法》 半平面交 基本概念 半平面是指二维平面上一条直线的一侧的所有空间。通常使用点对 (P,Q)(P,Q)(P,Q) 表示在向量 →PQ\\underset{PQ}{\\rightarrow}PQ→​ 左侧的半平面。 多个半平面的交是空集或非空凸集。 构造方法 首先对所有的半平面进行极角排序，对于极角相同的半平面有选择性地保留，并在双端队列中加入最开始的两个半平面。 考虑加入一个新的半平面：当队头的两个半平面的交点在该半平面外，删除队头的半平面；队尾同理；然后将新的半平面加入队尾。 添加完所有的半平面后，删除两端多余的半平面的方法为：若队头的两个半平面的交点在队尾半平面外，删除队头的半平面；队尾同理。 判断交点在半平面外可以利用叉积解决。 参考资料 《计算几何选讲》，dwjshift 极角 - 百度百科 半平面交 - 百度百科","categories":[],"tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://yoursite.com/tags/学习笔记/"},{"name":"计算几何","slug":"计算几何","permalink":"http://yoursite.com/tags/计算几何/"}]},{"title":"「LOJ 2306」「NOI2017」蔬菜","slug":"loj2306","date":"2018-06-10T23:45:10.000Z","updated":"2018-06-11T00:12:34.200Z","comments":true,"path":"loj2306/","link":"","permalink":"http://yoursite.com/loj2306/","excerpt":"小 N 是蔬菜仓库的管理员，负责设计蔬菜的销售方案。 在蔬菜仓库中，共存放有 nnn 种蔬菜，小 N 需要根据不同蔬菜的特性，综合考虑各方面因素，设计合理的销售方案，以获得最多的收益。 在计算销售蔬菜的收益时，每销售一个单位第 iii 种蔬菜，就可以获得 aia_iai​ 的收益。特别地，由于政策鼓励商家进行多样化销售，第一次销售第 iii 种蔬菜时，还会额外得到 sis_isi​ 的额外收益。 在经营开始时，第 iii 种蔬菜的库存为 cic_ici​ 个单位。然而，蔬菜的保鲜时间非常有限，一旦变质就不能进行销售，不过聪明的小 N 已 经计算出了每个单位蔬菜变质的时间：对于第 iii 种蔬菜，存在保鲜值 xix_ixi​，每天结束时会有 xix_ixi​ 个单位的蔬菜变质，直到所有蔬菜都变质。（注意：每一单位蔬菜的变质时间是固定的，不随销售发生变化） 形式化地：对于所有的满足条件 d×xi≤cid\\times x_i \\leq c_id×xi​≤ci​ 的正整数 ddd ，有 xix_ixi​ 个单位的蔬菜将在 第 ddd 天结束时变质。 特别地，若 (d−1)×xi≤ci&lt;d×xi(d-1)\\times x_i \\le c_i &lt; d\\times x_i(d−1)×xi​≤ci​&lt;d×xi​ ，则有 ci−(d−1)×xic_i-(d-1)\\times x_ici​−(d−1)×xi​ 单位的蔬菜将在第 ddd 天结束时变质。 注意，当 xi=0x_i = 0xi​=0 时，意味着这种蔬菜不会变质。 同时，每天销售的蔬菜，总量也是有限的，最多不能超过 mmm 个单位。 现在，小 N 有 kkk 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 pjp_jpj​ ，如果需要销售 pjp_jpj​ 天，最多能获得多少收益？","text":"小 N 是蔬菜仓库的管理员，负责设计蔬菜的销售方案。 在蔬菜仓库中，共存放有 nnn 种蔬菜，小 N 需要根据不同蔬菜的特性，综合考虑各方面因素，设计合理的销售方案，以获得最多的收益。 在计算销售蔬菜的收益时，每销售一个单位第 iii 种蔬菜，就可以获得 aia_iai​ 的收益。特别地，由于政策鼓励商家进行多样化销售，第一次销售第 iii 种蔬菜时，还会额外得到 sis_isi​ 的额外收益。 在经营开始时，第 iii 种蔬菜的库存为 cic_ici​ 个单位。然而，蔬菜的保鲜时间非常有限，一旦变质就不能进行销售，不过聪明的小 N 已 经计算出了每个单位蔬菜变质的时间：对于第 iii 种蔬菜，存在保鲜值 xix_ixi​，每天结束时会有 xix_ixi​ 个单位的蔬菜变质，直到所有蔬菜都变质。（注意：每一单位蔬菜的变质时间是固定的，不随销售发生变化） 形式化地：对于所有的满足条件 d×xi≤cid\\times x_i \\leq c_id×xi​≤ci​ 的正整数 ddd ，有 xix_ixi​ 个单位的蔬菜将在 第 ddd 天结束时变质。 特别地，若 (d−1)×xi≤ci&lt;d×xi(d-1)\\times x_i \\le c_i &lt; d\\times x_i(d−1)×xi​≤ci​&lt;d×xi​ ，则有 ci−(d−1)×xic_i-(d-1)\\times x_ici​−(d−1)×xi​ 单位的蔬菜将在第 ddd 天结束时变质。 注意，当 xi=0x_i = 0xi​=0 时，意味着这种蔬菜不会变质。 同时，每天销售的蔬菜，总量也是有限的，最多不能超过 mmm 个单位。 现在，小 N 有 kkk 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 pjp_jpj​ ，如果需要销售 pjp_jpj​ 天，最多能获得多少收益？ Constraints n,pj≤105n,p_j\\leq 10^5n,pj​≤105 ， m≤10m\\leq 10m≤10 ， 0&lt;ai,ci≤1090 &lt; a_i,c_i \\leq 10^90&lt;ai​,ci​≤109 ， 0≤si,xi≤1090\\leq s_i,x_i \\leq 10^90≤si​,xi​≤109 Solution 贪心可得，我们要尽量多地卖出收益高的，且尽量晚卖。对于一份蔬菜，拆成 ai+sia_i+s_iai​+si​ 和 aia_iai​ 两种，并钦定第一种过期时间最晚。 对于所有的蔬菜，我们先按价格从大到小排序。按照顺序处理方式为：从过期的最后一天开始尽量卖出，如果当前天已经满了就再往前卖。使用并查集可以保证复杂度。 对于询问，考虑从第 xxx 天到第 x−1x-1x−1 天的转移，贪心地丢弃最便宜的，且份数为从第 xxx 天开始卖出的蔬菜 −-− 从第一天到第 x−1x-1x−1 天的空隙。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;int n,m,k,A,S,C,X,cnt,tmp;int tot,mxd,id,res,cur,mn;int Q[N],f[N],v[N],p[N],d[N];LL ans,sum,t,emp[N],del[N],s[N];struct node&#123;int a,c,x,d;&#125;a[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.a&gt;b.a;&#125;int find(int t)&#123;return f[t]==t?t:f[t]=find(f[t]);&#125;void link(int x,int y)&#123;x=find(x);y=find(y);if(y!=x)f[y]=x;&#125;void modify(int id,int c,int a)&#123; ans+=1ll*c*a;v[tot]+=c;p[tot]=a; d[id]+=c;if(d[id]==m)link(id-1,id);&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=n;i++) &#123; A=read();S=read();C=read();X=read(); a[++cnt]=(node)&#123;A+S,1,0,X?(C-1)/X+1:N&#125;; C--;if(C)a[++cnt]=(node)&#123;A,C,X,X?(C-1)/X+1:N&#125;; &#125; for(int i=1;i&lt;=k;i++) Q[i]=read(),mxd=max(mxd,Q[i]); sort(a+1,a+cnt+1,cmp); for(int i=1;i&lt;=mxd;i++)f[i]=i; for(int i=1;i&lt;=cnt;i++) &#123; tot++;id=find(min(a[i].d,mxd)); res=(id-1)*a[i].x;cur=a[i].c-res; while(id&amp;&amp;cur) &#123; mn=min(m-d[id],cur); modify(id,mn,a[i].a);cur-=mn; tmp=id;id=find(id-1);tmp-=id; cur+=min(res,tmp*a[i].x); res-=min(res,tmp*a[i].x); &#125; if(!find(mxd))break; &#125; for(int i=1;i&lt;=mxd;i++)emp[i]=emp[i-1]+m-d[i]; for(int i=mxd;i&gt;=1;i--)del[i]=max(0ll,sum-emp[i]),sum+=d[i]; for(int i=mxd;i&gt;=1;i--) &#123; s[i]=ans;t=del[i-1]-del[i]; while(t) &#123; mn=min(t,1ll*v[tot]);ans-=1ll*mn*p[tot]; t-=mn;v[tot]-=mn;if(!v[tot])tot--; &#125; &#125; for(int i=1;i&lt;=k;i++)printf(\"%lld\\n\",s[Q[i]]); return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"「LOJ 2305」「NOI2017」游戏","slug":"loj2305","date":"2018-06-10T12:38:09.000Z","updated":"2018-06-10T12:41:32.427Z","comments":true,"path":"loj2305/","link":"","permalink":"http://yoursite.com/loj2305/","excerpt":"小 L 计划进行 nnn 场游戏，每场游戏使用一张地图，小 L 会选择一辆车在该地图上完成游戏。 小 L 的赛车有三辆，分别用大写字母 AAA、BBB、CCC 表示。地图一共有四种，分别用小写字母 xxx、aaa、bbb、ccc 表示。 其中，赛车 AAA 不适合在地图 aaa 上使用，赛车 BBB 不适合在地图 bbb 上使用，赛车 CCC 不适合在地图 ccc 上使用，而地图 xxx 则适合所有赛车参加。适合所有赛车参加的地图并不多见，最多只会有 ddd 张。 nnn 场游戏的地图可以用一个小写字母组成的字符串描述。 小 L 对游戏有一些特殊的要求，这些要求可以用四元组 (i,hi,j,hj)(i, h_i, j, h_j)(i,hi​,j,hj​) 来描述，表示若在第 iii 场使用型号为 hih_ihi​ 的车子，则第 jjj 场游戏要使用型号为 hjh_jhj​ 的车子。 你能帮小 L 选择每场游戏使用的赛车吗？如果有多种方案，输出任意一种方案。如果无解，输出 −1-1−1 。","text":"小 L 计划进行 nnn 场游戏，每场游戏使用一张地图，小 L 会选择一辆车在该地图上完成游戏。 小 L 的赛车有三辆，分别用大写字母 AAA、BBB、CCC 表示。地图一共有四种，分别用小写字母 xxx、aaa、bbb、ccc 表示。 其中，赛车 AAA 不适合在地图 aaa 上使用，赛车 BBB 不适合在地图 bbb 上使用，赛车 CCC 不适合在地图 ccc 上使用，而地图 xxx 则适合所有赛车参加。适合所有赛车参加的地图并不多见，最多只会有 ddd 张。 nnn 场游戏的地图可以用一个小写字母组成的字符串描述。 小 L 对游戏有一些特殊的要求，这些要求可以用四元组 (i,hi,j,hj)(i, h_i, j, h_j)(i,hi​,j,hj​) 来描述，表示若在第 iii 场使用型号为 hih_ihi​ 的车子，则第 jjj 场游戏要使用型号为 hjh_jhj​ 的车子。 你能帮小 L 选择每场游戏使用的赛车吗？如果有多种方案，输出任意一种方案。如果无解，输出 −1-1−1 。 Constraints n≤50000n\\leq 50000n≤50000 ， m≤100000m\\leq 100000m≤100000 ， d≤8d \\leq 8d≤8 Solution 据题意显然需要为 2-SAT 。因为 xxx 的地图适合三种赛车，且最多只有 888 张，所以我们可以通过枚举每张 xxx 的地图为 aaa 或 bbb 来将问题转化为 2-SAT 的裸题。 对于一条限制，点 iii 代表第 iii 场选择了赛车 hih_ihi​ ，点 i′i&#x27;i′ 代表不选择赛车 hih_ihi​ ，点 jjj 与点 j′j&#x27;j′ 同理。具体连边方式为：若第 iii 场无法使用 hih_ihi​ ，直接跳过；若第 jjj 场无法使用 hjh_jhj​ ，则连边 iii 到 i′i&#x27;i′ ，代表一旦选择 iii 则无解；否则连边 iii 到 jjj ， j′j&#x27;j′ 到 i′i&#x27;i′ 。 建完图以后 tarjan 缩点，判断是否有可行方案。输出方案时输出强连通分量编号较小的一个即可。 时间复杂度 O(m⋅2d)O(m\\cdot 2^d)O(m⋅2d) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;int n,d,m,cnt,tim,color,top,pos[10];int first[N],ci[N],hi[N],cj[N],hj[N];int s[N],low[N],dfn[N],sta[N],c[N];bool vis[N];char ch[N];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int get()&#123; char c=getchar(); while(c&lt;'A'||c&gt;'C')c=getchar(); return c-'A';&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++tim; sta[++top]=x;vis[x]=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!dfn[to])tarjan(to),low[x]=min(low[x],low[to]); else if(vis[to])low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; color++; while(sta[top]!=x)vis[sta[top]]=false,c[sta[top--]]=color; vis[x]=false;c[x]=color;top--; &#125;&#125;int id(int x,int c)&#123; if(!s[x])return c==1?x:x+n; else return c==0?x:x+n;&#125;int xo(int x)&#123;return x&gt;n?x-n:x+n;&#125;bool solve(int state)&#123; cnt=tim=color=top=0; memset(c,0,sizeof(c)); memset(vis,0,sizeof(vis)); memset(low,0,sizeof(low)); memset(dfn,0,sizeof(dfn)); memset(first,0,sizeof(first)); for(int i=0;i&lt;d;i++) if(state&amp;(1&lt;&lt;i))s[pos[i+1]]=0; else s[pos[i+1]]=1; for(int i=1;i&lt;=m;i++) &#123; if(hi[i]==s[ci[i]])continue; int x=id(ci[i],hi[i]),y=id(cj[i],hj[i]); if(hj[i]==s[cj[i]])&#123;ins(x,xo(x));continue;&#125; ins(x,y);ins(xo(y),xo(x)); &#125; for(int i=1;i&lt;=n*2;i++) if(!dfn[i])tarjan(i); for(int i=1;i&lt;=n;i++) if(c[i]==c[n+i])return false; for(int i=1;i&lt;=n;i++) if(c[i]&lt;c[i+n]) &#123; if(!s[i])putchar('B'); else putchar('A'); &#125; else &#123; if(s[i]==2)putchar('B'); else putchar('C'); &#125; return true;&#125;int main()&#123; n=read();read(); scanf(\"%s\",ch+1);m=read(); for(int i=1;i&lt;=n;i++) &#123; s[i]=ch[i]-'a'; if(ch[i]=='x')pos[++d]=i; &#125; for(int i=1;i&lt;=m;i++) ci[i]=read(),hi[i]=get(), cj[i]=read(),hj[i]=get(); for(int i=0;i&lt;(1&lt;&lt;d);i++) if(solve(i))return 0; printf(\"-1\"); return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"tarjan","slug":"tarjan","permalink":"http://yoursite.com/tags/tarjan/"}]},{"title":"「LOJ 2304」「NOI2017」泳池","slug":"loj2304","date":"2018-06-10T08:02:22.000Z","updated":"2018-06-10T08:29:51.227Z","comments":true,"path":"loj2304/","link":"","permalink":"http://yoursite.com/loj2304/","excerpt":"久莲是个爱玩的女孩子。 暑假终于到了，久莲决定请她的朋友们来游泳，她打算先在她家的私人海滩外圈一块长方形的海域作为游泳场。然而大海里有着各种各样的危险，有些地方水太深，有些地方有带毒的水母出没。她想让圈出来的这一块海域都是安全的。 经过初步分析，这块海域可视为一个底边长为 NNN 米，高为 100110011001 米的长方形网格。其中网格的底边对应着她家的私人海滩，每一个 1m×1m1m\\times 1m1m×1m 的小正方形都代表着一个单位海域。她拜托了她爸爸明天去测量每一个小正方形是否安全。在得知了信息之后，她要做的就是圈出她想要的游泳场啦。 她心目中理想的游泳场满足如下三个条件： 必须保证安全性。即游泳场中的每一个单位海域都是安全的。 必须是矩形。即游泳场必须是整个网格中的一个 a×ba\\times ba×b 的子网格。 必须和海滩相邻。即游泳场的下边界必须紧贴网格的下边界。 为了让朋友们玩的开心，她想让游泳场的面积尽可能的大。 虽然她要明天才能知道每一个单位海域是否安全，但是她现在就想行动起来估计一下她的游泳场面积有多大。经过简单的估计，她假设每一个单位海域都有独立的 qqq 的概率是安全的， 1−q 的概率是不安全的。她想要知道她能选择的最大的游泳场的面积恰好为 KKK 的概率是多少。 然而久莲对数学并不感兴趣，因此她想让你来帮她计算一下这个数值。","text":"久莲是个爱玩的女孩子。 暑假终于到了，久莲决定请她的朋友们来游泳，她打算先在她家的私人海滩外圈一块长方形的海域作为游泳场。然而大海里有着各种各样的危险，有些地方水太深，有些地方有带毒的水母出没。她想让圈出来的这一块海域都是安全的。 经过初步分析，这块海域可视为一个底边长为 NNN 米，高为 100110011001 米的长方形网格。其中网格的底边对应着她家的私人海滩，每一个 1m×1m1m\\times 1m1m×1m 的小正方形都代表着一个单位海域。她拜托了她爸爸明天去测量每一个小正方形是否安全。在得知了信息之后，她要做的就是圈出她想要的游泳场啦。 她心目中理想的游泳场满足如下三个条件： 必须保证安全性。即游泳场中的每一个单位海域都是安全的。 必须是矩形。即游泳场必须是整个网格中的一个 a×ba\\times ba×b 的子网格。 必须和海滩相邻。即游泳场的下边界必须紧贴网格的下边界。 为了让朋友们玩的开心，她想让游泳场的面积尽可能的大。 虽然她要明天才能知道每一个单位海域是否安全，但是她现在就想行动起来估计一下她的游泳场面积有多大。经过简单的估计，她假设每一个单位海域都有独立的 qqq 的概率是安全的， 1−q 的概率是不安全的。她想要知道她能选择的最大的游泳场的面积恰好为 KKK 的概率是多少。 然而久莲对数学并不感兴趣，因此她想让你来帮她计算一下这个数值。 Constraints n≤109n \\leq 10^9n≤109 ， K≤1000K \\leq 1000K≤1000 Solution 转化问题为求游泳场面积小于 KKK 的概率，最终答案为 K+1K+1K+1 的计算结果减去 KKK 的计算结果。 令 f(i,j)f(i,j)f(i,j) 表示长为 iii ，每一行高度至少为 jjj ，且满足条件的概率。可得： f(i,j)={0(i⋅j≥K)f(i,j+1)+qj⋅(1−q)⋅∑k=0i−1f(k,j+1)⋅f(i−k−1,j)(i⋅j&lt;K)f(i,j) = \\begin{cases} 0 &amp; (i\\cdot j \\ge K)\\\\ f(i,j+1)+q^j\\cdot (1-q)\\cdot \\sum_{k=0}^{i-1} f(k,j+1)\\cdot f(i-k-1,j) &amp; (i \\cdot j &lt; K) \\end{cases} f(i,j)={0f(i,j+1)+qj⋅(1−q)⋅∑k=0i−1​f(k,j+1)⋅f(i−k−1,j)​(i⋅j≥K)(i⋅j&lt;K)​ 特殊地，当 i=0i=0i=0 时， f(i,j)=1f(i,j)=1f(i,j)=1 。 计算结果即为 f(n,0)f(n,0)f(n,0) ，时间复杂度 O(nklogk)O(nklogk)O(nklogk) ，可以通过 70 分，下面放出的代码也是 70 分的代码。 对于接下来的分数，因为当 i≥Ki\\ge Ki≥K 时，只有 f(i,0)f(i,0)f(i,0) 的值不为 000 ，所以当 i&gt;=Ki&gt;=Ki&gt;=K 时有式子： f(i,0)=(1−q)⋅∑k=0K−1f(k,1)⋅f(i−k−1,0)f(i,0) = (1-q)\\cdot \\sum_{k=0}^{K-1} f(k,1)\\cdot f(i-k-1,0) f(i,0)=(1−q)⋅k=0∑K−1​f(k,1)⋅f(i−k−1,0) 然后……先屯着了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e3+5;const int mod=998244353;int n,m,x,y,q,K;int ans,tmp,mi[N],f[N][N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int inv(int x)&#123;return power(x,mod-2);&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void work()&#123; memset(f,0,sizeof(f)); for(int i=0;i&lt;=K;i++)f[0][i]=1; for(int i=1;i&lt;=n;i++) for(int j=(K-1)/i;j&gt;=0;j--) &#123; f[i][j]=f[i][j+1]; for(int k=0;k&lt;=i-1;k++) Mod(f[i][j],1ll*(mod+1-q)*mi[j]%mod*f[k][j+1]%mod*f[i-k-1][j]%mod); &#125; ans=f[n][0];&#125;int main()&#123; n=read();m=read();x=read();y=read(); q=1ll*x*inv(y)%mod; mi[0]=1;for(int i=1;i&lt;=m+1;i++)mi[i]=1ll*mi[i-1]*q%mod; K=m;work();tmp=(mod-ans)%mod; K=m+1;work();Mod(ans,tmp); printf(\"%d\",ans); return 0;&#125;","categories":[],"tags":[{"name":"概率dp","slug":"概率dp","permalink":"http://yoursite.com/tags/概率dp/"}]},{"title":"「LOJ 2303」「NOI2017」蚯蚓排队","slug":"loj2303","date":"2018-06-10T03:53:20.000Z","updated":"2018-06-10T07:19:24.383Z","comments":true,"path":"loj2303/","link":"","permalink":"http://yoursite.com/loj2303/","excerpt":"蚯蚓幼儿园有 nnn 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。 所有蚯蚓用从 111 到 nnn 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 666 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。 神刀手将会依次进行 mmm 次操作，每个操作都是以下三种操作中的一种： 给出 iii 和 jjj ，令 iii 号蚯蚓与 jjj 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 jjj 号蚯蚓紧挨在 iii 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。 给出 iii ，令 iii 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， iii 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。 给出一个正整数 kkk 和一个长度至少为 kkk 的数字串 sss ，对于 sss 的每个长度为 kkk 的连续子串 ttt （这样的子串共有 ∣s∣−k+1|s|-k+1∣s∣−k+1 个，其中 ∣s∣|s|∣s∣ 为 sss 的长度），定义函数 f(t)f(t)f(t) ，询问所有这些 f(t)f(t)f(t) 的乘积对 998244353998244353998244353 取模后的结果。其中 f(t)f(t)f(t) 的定义如下： 对于当前的蚯蚓队伍，定义某个蚯蚓的向后 kkk 数字串为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 kkk 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 kkk 只，则其没有向后 kkk 数字串。 而 f(t)f(t)f(t) 表示所有蚯蚓中，向后 kkk 数字串恰好为 ttt 的蚯蚓只数。","text":"蚯蚓幼儿园有 nnn 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。 所有蚯蚓用从 111 到 nnn 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 666 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。 神刀手将会依次进行 mmm 次操作，每个操作都是以下三种操作中的一种： 给出 iii 和 jjj ，令 iii 号蚯蚓与 jjj 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 jjj 号蚯蚓紧挨在 iii 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。 给出 iii ，令 iii 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， iii 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。 给出一个正整数 kkk 和一个长度至少为 kkk 的数字串 sss ，对于 sss 的每个长度为 kkk 的连续子串 ttt （这样的子串共有 ∣s∣−k+1|s|-k+1∣s∣−k+1 个，其中 ∣s∣|s|∣s∣ 为 sss 的长度），定义函数 f(t)f(t)f(t) ，询问所有这些 f(t)f(t)f(t) 的乘积对 998244353998244353998244353 取模后的结果。其中 f(t)f(t)f(t) 的定义如下： 对于当前的蚯蚓队伍，定义某个蚯蚓的向后 kkk 数字串为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 kkk 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 kkk 只，则其没有向后 kkk 数字串。 而 f(t)f(t)f(t) 表示所有蚯蚓中，向后 kkk 数字串恰好为 ttt 的蚯蚓只数。 Constraints n≤2×105n \\leq 2 \\times 10^{5}n≤2×105 ， m≤5×105m \\leq 5 \\times 10^{5}m≤5×105 ， k≤50k \\leq 50k≤50 ， ∑∣s∣≤107\\sum |s| \\leq 10^{7}∑∣s∣≤107 Solution 暴力维护对每个队伍链表，维护每条蚯蚓向后长度为 kkk 的字符串的哈希值。 每一次修改操作只需要暴力修改跨越操作点的 k2k^2k2 个字符串，查询时直接枚举。 从总体考虑合并操作，可得时间复杂度实际为 O(ck2+nk+∑∣s∣)O(ck^2+nk+\\sum |s|)O(ck2+nk+∑∣s∣) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int L=1e7+5;const int K=55;const int sbas=233;const int bbas=173;const int smod=3715417;const int bmod=1e9+7;const int mod=998244353;int n,m,cnt,ans,num,first[smod+5];int op,x,y,z,leng,nxt[N],lst[N];int a[N],S[K],B[K],s[N][K],b[N][K];int SS,BB,ss[L],bb[L];char ch[L];struct edge&#123;int to,next,k,c;&#125;e[N*K];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void ins(int small,int big,int len,int val)&#123; for(int i=first[small];i;i=e[i].next) if(e[i].to==big&amp;&amp;e[i].k==len)&#123;Mod(e[i].c,val);return;&#125; e[++cnt]=(edge)&#123;big,first[small],len,val&#125;;first[small]=cnt;&#125;int main()&#123; n=read();m=read(); S[0]=1;for(int i=1;i&lt;=50;i++)S[i]=1ll*S[i-1]*sbas%smod; B[0]=1;for(int i=1;i&lt;=50;i++)B[i]=1ll*B[i-1]*bbas%bmod; for(int i=1;i&lt;=n;i++) &#123; a[i]=read(); s[i][1]=b[i][1]=a[i]; ins(a[i],a[i],1,1); &#125; while(m--) &#123; op=read(); if(op==1) &#123; x=read();y=read();nxt[x]=y;lst[y]=x; for(int i=1;i&lt;50&amp;&amp;x;i++) &#123; z=y; for(int j=1;i+j&lt;=50&amp;&amp;z;j++) &#123; s[x][i+j]=(1ll*s[x][i+j-1]*sbas+a[z])%smod; b[x][i+j]=(1ll*b[x][i+j-1]*bbas+a[z])%bmod; ins(s[x][i+j],b[x][i+j],i+j,1);z=nxt[z]; &#125; x=lst[x]; &#125; &#125; else if(op==2) &#123; x=read();y=nxt[x];nxt[x]=lst[y]=0; for(int i=1;i&lt;50&amp;&amp;x;i++) &#123; z=y; for(int j=1;i+j&lt;=50&amp;&amp;z;j++) ins(s[x][i+j],b[x][i+j],i+j,-1),z=nxt[z]; x=lst[x]; &#125; &#125; else &#123; scanf(\"%s\",ch+1);leng=strlen(ch+1); x=read();ans=1; for(int i=1;i&lt;=leng;i++) &#123; ss[i]=(1ll*ss[i-1]*sbas+ch[i]-'0')%smod; bb[i]=(1ll*bb[i-1]*bbas+ch[i]-'0')%bmod; &#125; for(int i=1;i&lt;=leng-x+1;i++) &#123; SS=(ss[i+x-1]-1ll*ss[i-1]*S[x]%smod+smod)%smod; BB=(bb[i+x-1]-1ll*bb[i-1]*B[x]%bmod+bmod)%bmod; num=0; for(int i=first[SS];i;i=e[i].next) if(e[i].to==BB&amp;&amp;e[i].k==x)&#123;num=e[i].c;break;&#125; ans=1ll*ans*num%mod; &#125; printf(\"%d\\n\",ans); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"},{"name":"哈希","slug":"哈希","permalink":"http://yoursite.com/tags/哈希/"}]},{"title":"「LOJ 2302」「NOI2017」整数","slug":"loj2302","date":"2018-06-10T02:02:12.000Z","updated":"2018-06-10T02:22:46.482Z","comments":true,"path":"loj2302/","link":"","permalink":"http://yoursite.com/loj2302/","excerpt":"在人类智慧的山巅，有着一台字长为 104857610485761048576 位的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。 不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你…… P 博士将他的计算任务抽象为对一个整数的操作。 具体来说，有一个整数 xxx ，一开始为 000。 接下来有 nnn 个操作，每个操作都是以下两种类型中的一种： 1ab1 a b1ab ：将 xxx 加上整数 a⋅2ba \\cdot 2 ^ ba⋅2b ，其中 aaa 为一个整数，bbb 为一个非负整数 2k2 k2k ：询问 xxx 在用二进制表示时，位权为 2k2 ^ k2k​​ 的位的值（即这一位上的 111 代表 2k2 ^ k2k ） 保证在任何时候，x≥0x \\ge 0x≥0 。","text":"在人类智慧的山巅，有着一台字长为 104857610485761048576 位的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。 不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你…… P 博士将他的计算任务抽象为对一个整数的操作。 具体来说，有一个整数 xxx ，一开始为 000。 接下来有 nnn 个操作，每个操作都是以下两种类型中的一种： 1ab1 a b1ab ：将 xxx 加上整数 a⋅2ba \\cdot 2 ^ ba⋅2b ，其中 aaa 为一个整数，bbb 为一个非负整数 2k2 k2k ：询问 xxx 在用二进制表示时，位权为 2k2 ^ k2k​​ 的位的值（即这一位上的 111 代表 2k2 ^ k2k ） 保证在任何时候，x≥0x \\ge 0x≥0 。 Constraints $ n\\leq 1000000$ ， ∣a∣≤1000000000|a| \\leq 1000000000∣a∣≤1000000000 ， 0≤b,k≤3⋅n0\\leq b,k \\leq 3\\cdot n0≤b,k≤3⋅n Solution 数据范围提示得很明显……需要压位，每一个数字储存 303030 位。 首先开两个数组，一个储存加法，一个储存减法，修改的时候在两个数组上暴力加法暴力进位即可。 现在考虑处理询问。因为保证在任何时刻， x≥0x \\ge 0x≥0 ，所以我们判断第 kkk 位时其实只与加法、减法第 000 到 k−1k-1k−1 位的数字的大小有关。根据减法的规则，稍微分一下类可得：若后面部分的数字差为负，则答案为相应位上的数字的同或，否则为异或。 判断第 000 到 k−1k-1k−1 位的加法数字和减法数字的大小，等价于判断字典序。找到第一个不相同的位置，判断大小即可。我们使用线段树来维护，利用线段树判断 000 到 k−1k-1k−1 的区间内最靠右的加法数组和减法数组不一样的位置。 时间复杂度 O(nlog2n)O(nlog^2 n)O(nlog2n) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)#define LL long longusing namespace std;const int N=1e6+5;const int base=1&lt;&lt;30;int n,t1,t2,t3,op,pos;LL a,b,p,q,tmp,las,nex;bool fl;int L[N*4],R[N*4];LL add[N],dec[N],id[N],t[N*4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void build(int x,int l,int r)&#123; L[x]=l;R[x]=r; if(l==r)&#123;id[l]=x;return;&#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid); build(rc,mid+1,r);&#125;void change(int x,LL val)&#123; x=id[x];t[x]^=val; while(x!=1)&#123;x&gt;&gt;=1;t[x]=max(t[lc],t[rc]);&#125;&#125;void modify(LL a,int pos,LL *x)&#123; las=x[pos];nex=x[pos+1]; while(a) &#123; x[pos]+=a%base; if(x[pos]&gt;=base) &#123; x[pos+1]+=x[pos]/base; x[pos]%=base; &#125; change(pos,las^x[pos]); pos++;a/=base; las=nex;nex=x[pos+1]; &#125; if(x[pos]&gt;=base) &#123; x[pos+1]+=x[pos]/base; x[pos]%=base; &#125; change(pos,las^x[pos]);&#125;void find(int x)&#123; x=id[x]; while(x!=1) &#123; if((x&amp;1)&amp;&amp;t[x-1])&#123;x--;break;&#125; x&gt;&gt;=1; &#125; if(x==1)return; while(L[x]!=R[x]) &#123; if(t[rc])x=rc; else x=lc; &#125; t3=L[x];return;&#125;int main()&#123; n=read();t1=read();t2=read();t3=read(); build(1,1,n+2); for(int i=1;i&lt;=n;i++) &#123; op=read();a=read(); if(op==1) &#123; b=read();pos=b/30+1;b%=30; if(a==0)continue; if(a&gt;0)fl=true; else a=-a,fl=false; a&lt;&lt;=b; if(fl)modify(a,pos,add); else modify(a,pos,dec); &#125; else &#123; pos=a/30+1;a%=30; p=add[pos]%(1&lt;&lt;a); q=dec[pos]%(1&lt;&lt;a); t1=(add[pos]&gt;&gt;a)&amp;1; t2=(dec[pos]&gt;&gt;a)&amp;1; if(p!=q) &#123; if(p&gt;q)printf(\"%d\\n\",t1^t2); else printf(\"%d\\n\",t1==t2); continue; &#125; t3=0;find(pos); if(add[t3]&gt;=dec[t3])printf(\"%d\\n\",t1^t2); else printf(\"%d\\n\",t1==t2); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"「51nod 1618」树或非树","slug":"51nod1618","date":"2018-06-03T12:22:36.000Z","updated":"2018-06-03T12:31:10.907Z","comments":true,"path":"51nod1618/","link":"","permalink":"http://yoursite.com/51nod1618/","excerpt":"GGG 是一张由 nnn 个点和 nnn 条边组成的无向图。 GGG 中没有自环和重边。每条边有两种状态“开”和“关”。一开始，所有的边都是“关”着的。 现在有 mmm 个操作 (v,u)(v,u)(v,u) ，表示将从 vvv 到 uuu 的最短路上的边改变状态（如果状态为“开”则变成“关”，反之，变成“开”）。如果 vvv 到 uuu 存在多条最短路，则我们选取点序列字典序最小的那一条。 比如，将所有从 vvv 到 uuu 的路径上的点表示成序列为 v,v1,v2,⋯,uv,v_1,v_2,\\cdots ,uv,v1​,v2​,⋯,u 。那么我们从中取字典序最小的那一条。 在每一次操作后，你需要计算在图中由所有点和状态为“开”的边所组成图的连通块的数目。","text":"GGG 是一张由 nnn 个点和 nnn 条边组成的无向图。 GGG 中没有自环和重边。每条边有两种状态“开”和“关”。一开始，所有的边都是“关”着的。 现在有 mmm 个操作 (v,u)(v,u)(v,u) ，表示将从 vvv 到 uuu 的最短路上的边改变状态（如果状态为“开”则变成“关”，反之，变成“开”）。如果 vvv 到 uuu 存在多条最短路，则我们选取点序列字典序最小的那一条。 比如，将所有从 vvv 到 uuu 的路径上的点表示成序列为 v,v1,v2,⋯,uv,v_1,v_2,\\cdots ,uv,v1​,v2​,⋯,u 。那么我们从中取字典序最小的那一条。 在每一次操作后，你需要计算在图中由所有点和状态为“开”的边所组成图的连通块的数目。 Constraints 1≤n,m≤1000001\\leq n,m \\leq 1000001≤n,m≤100000 Solution 题目保证图是联通的，所以整个图为一棵环套树，去掉环之后则是森林。然后就可以 dfs 序链剖然后上线段树了，修改操作路径异或即可，其中环在线段树上要占用环大小的连续区间。 对于树来说，连通块个数即为点数 - 边数。询问时需要特判一下环上的情况，如果整个环都是开的，则 ans++ 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)#define LL long longusing namespace std;const int N=1e5+5;int n,m,cnt,tot,ctot,tim,son;int x,y,L,R,dx,dy,ans;int first[N],st[N],c[N],pos[N],be[N];int fa[N],sz[N],deep[N],dfn[N],tp[N];int s[N*8],tag[N*8];bool vis[N];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void circle(int x,int fa)&#123; vis[x]=true;st[++tot]=x; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; if(!vis[to])circle(to,x); else &#123; if(ctot)return; y=0;while(y!=to)y=st[tot--],c[++ctot]=y; &#125; &#125; tot--;&#125;void dfs1(int x,int last)&#123; sz[x]=1;deep[x]=deep[last]+1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==last||pos[to])continue; fa[to]=x;be[to]=be[x]; dfs1(to,x);sz[x]+=sz[to]; &#125;&#125;void dfs2(int x,int top)&#123; dfn[x]=++tim;tp[x]=top;son=0; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(dfn[to]||pos[to])continue; if(sz[to]&gt;sz[son])son=to; &#125; if(!son)return; dfs2(son,top); for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(dfn[to]||pos[to])continue; dfs2(to,to); &#125;&#125;void down(int x,int l,int r)&#123; if(!tag[x]||l==r)return; tag[x]=0;int mid=(l+r)&gt;&gt;1; tag[lc]^=1;tag[rc]^=1; s[lc]=mid-l+1-s[lc]; s[rc]=r-mid-s[rc];&#125;void modify(int x,int l,int r)&#123; down(x,l,r); if(L&lt;=l&amp;&amp;r&lt;=R) &#123; s[x]=r-l+1-s[x]; tag[x]^=1;return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(lc,l,mid); if(R&gt;mid)modify(rc,mid+1,r); s[x]=s[lc]+s[rc];&#125;int query(int x,int l,int r)&#123; down(x,l,r); if(L&lt;=l&amp;&amp;r&lt;=R)return s[x]; int mid=(l+r)&gt;&gt;1,sum=0; if(L&lt;=mid)sum+=query(lc,l,mid); if(R&gt;mid)sum+=query(rc,mid+1,r); return sum;&#125;void open(int x,int y)&#123; if(x&gt;y)return; L=x;R=y;modify(1,1,n+ctot);&#125;void change(int x,int y)&#123; while(tp[x]!=tp[y]) &#123; if(deep[tp[x]]&lt;deep[tp[y]])swap(x,y); open(dfn[tp[x]],dfn[x]);x=fa[tp[x]]; &#125; if(deep[x]&lt;deep[y])swap(x,y); open(dfn[y]+1,dfn[x]);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) &#123; x=read();y=read(); ins(x,y);ins(y,x); &#125; circle(1,-1); for(int i=1;i&lt;=ctot;i++)pos[c[i]]=i; for(int i=1;i&lt;=ctot;i++) &#123; be[c[i]]=c[i]; dfs1(c[i],c[i]);dfs2(c[i],c[i]); &#125; while(m--) &#123; x=read();y=read(); if(be[x]==be[y]) &#123; change(x,y); ans=n-s[1];L=n+1;R=n+ctot; if(query(1,1,n+ctot)==ctot)ans++; printf(\"%d\\n\",ans); continue; &#125; change(x,be[x]);change(y,be[y]); x=be[x];y=be[y];dx=pos[x];dy=pos[y]; if(dx&lt;dy) &#123; if(dy-dx&gt;ctot+dx-dy||(dy-dx==ctot+dx-dy&amp;&amp;c[dx+1]&gt;c[(dx-2+ctot)%ctot+1])) open(n+1,n+dx),open(n+dy+1,n+ctot); else open(n+dx+1,n+dy); &#125; else &#123; if(dx-dy&gt;ctot+dy-dx||(dx-dy==ctot+dy-dx&amp;&amp;c[dx-1]&gt;c[dx%ctot+1])) open(n+1,n+dy),open(n+dx+1,n+ctot); else open(n+dy+1,n+dx); &#125; ans=n-s[1];L=n+1;R=n+ctot; if(query(1,1,n+ctot)==ctot)ans++; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://yoursite.com/tags/树链剖分/"}]},{"title":"「51nod 1646」幸运的车票","slug":"51nod1646","date":"2018-06-01T13:29:16.000Z","updated":"2018-06-01T13:38:35.915Z","comments":true,"path":"51nod1646/","link":"","permalink":"http://yoursite.com/51nod1646/","excerpt":"华沙收集车票已经有一段时间了。他收集了上千张的车票。华沙已经厌倦了传统幸运车票的定义。所以他想寻找一个不一样的定义。华沙不理解为什么所有的车票要分为幸运的和不幸运的。他认为所有的车票都是幸运的，只是幸运的程度不一样。有了这个想法，他重新定义了车票的幸运程度。一张车票有 2n2n2n 位数字。数字 0−90-90−9 的书写如图。 就像在电子时钟里看到的数字一样，用 777 根线条表示数字。每根线条有两种状态，着色或不着色。着色的线条组成一个数字。华沙认为所有的数字都是这么书写的。把车票号码的右半部分放在左半部分上面，那么第 111 位数字就会和第 n+1n+1n+1 位重合，第 222 位就会和第 n+2n+2n+2 重合…，第 nnn 位数字和第 2n2n2n 位数字重合。对于每对重合的数字，统计这两个数字重合后都着色的线条数量。然后把每对统计的结果加起来，就是车票的幸运程度了。 现在，给定一个 2n2n2n 位数字的车票号码。找出一个 2n2n2n 位数字的车票号码，使得这个号码在数值上大于给定的号码，在幸运程度上也大于给定的号码。如果存在多个这样的号码，我们选择数值最小的那个号码。","text":"华沙收集车票已经有一段时间了。他收集了上千张的车票。华沙已经厌倦了传统幸运车票的定义。所以他想寻找一个不一样的定义。华沙不理解为什么所有的车票要分为幸运的和不幸运的。他认为所有的车票都是幸运的，只是幸运的程度不一样。有了这个想法，他重新定义了车票的幸运程度。一张车票有 2n2n2n 位数字。数字 0−90-90−9 的书写如图。 就像在电子时钟里看到的数字一样，用 777 根线条表示数字。每根线条有两种状态，着色或不着色。着色的线条组成一个数字。华沙认为所有的数字都是这么书写的。把车票号码的右半部分放在左半部分上面，那么第 111 位数字就会和第 n+1n+1n+1 位重合，第 222 位就会和第 n+2n+2n+2 重合…，第 nnn 位数字和第 2n2n2n 位数字重合。对于每对重合的数字，统计这两个数字重合后都着色的线条数量。然后把每对统计的结果加起来，就是车票的幸运程度了。 现在，给定一个 2n2n2n 位数字的车票号码。找出一个 2n2n2n 位数字的车票号码，使得这个号码在数值上大于给定的号码，在幸运程度上也大于给定的号码。如果存在多个这样的号码，我们选择数值最小的那个号码。 Constraints 1≤n≤1000001\\leq n \\leq 1000001≤n≤100000 Solution 一个数字的结构可以压缩成一个七位的二进制数，每一对数字幸运值即为对应二进制数取与后的 111 的位数。 需要在幸运值大的情况下字典序最小，则可从最后一位开始对每一位枚举要替代的数字。若当前位没有符合条件的可填数，则将其赋值为 888 。当出现第一个幸运值大的情况时，对后面进行贪心，贪心完的结果即为答案。 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int c[10]=&#123;119,36,93,109,46,107,123,37,127,111&#125;;int n,k,t,s,x,cnt,ch,a[N];char ss[N];int calc(int a,int b)&#123;return __builtin_popcount(c[a]&amp;c[b]);&#125;int main()&#123; scanf(\"%s\",ss+1); n=strlen(ss+1);k=n/2; for(int i=1;i&lt;=n;i++)a[i]=ss[i]-'0'; for(int i=n;i&gt;=1;i--) &#123; if(i&gt;k)t=a[i-k]; else t=a[i+k]; cnt=calc(a[i],t); for(int j=a[i]+1;j&lt;=9;j++) &#123; if(s+calc(t,j)&lt;=cnt)continue; a[i]=j;ch=s+calc(t,j)-cnt; for(int l=i+1;l&lt;=n;l++) &#123; x=a[l&gt;k?l-k:l+k]; for(int m=0;m&lt;=9;m++) &#123; if(ch-calc(x,a[l])+calc(x,m)&lt;=0)continue; ch=ch-calc(x,a[l])+calc(x,m); a[l]=m;break; &#125; &#125; for(int l=1;l&lt;=n;l++)printf(\"%d\",a[l]); return 0; &#125; a[i]=8;s+=calc(a[i],t)-cnt; &#125; printf(\"-1\"); return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"「51nod 1647」小Z的trie","slug":"51nod1647","date":"2018-06-01T11:46:08.000Z","updated":"2018-06-01T12:04:41.641Z","comments":true,"path":"51nod1647/","link":"","permalink":"http://yoursite.com/51nod1647/","excerpt":"NOIP 编号为 ZJ-267 的小 Z 在 NOIP 中 AK 啦！ 小 Z 打算去冲击省选，于是开始学习 trie 。 有一天，他得到了 NNN 个字符串。 他先建立一个根节点，对于每一个字符串，他都从根节点开始一点点插入。 小 Z 不满足于此。他的大脑里盘旋着 MMM 个问题： 如果给定一个二元组 (s,t)(s,t)(s,t) （ sss，ttt 都是 trie 中的节点且 sss 是 ttt 的祖先），存在多少个二元组 (x,y)(x,y)(x,y) （ xxx，yyy 都是 trie 中的节点且 xxx 是 yyy 的祖先），满足 sss ~ ttt 路径上的字符串和 xxx ~ yyy 路径上的字符串完全一样？ 注意 sss 可以等于 ttt ， xxx 也可以等于 yyy 。","text":"NOIP 编号为 ZJ-267 的小 Z 在 NOIP 中 AK 啦！ 小 Z 打算去冲击省选，于是开始学习 trie 。 有一天，他得到了 NNN 个字符串。 他先建立一个根节点，对于每一个字符串，他都从根节点开始一点点插入。 小 Z 不满足于此。他的大脑里盘旋着 MMM 个问题： 如果给定一个二元组 (s,t)(s,t)(s,t) （ sss，ttt 都是 trie 中的节点且 sss 是 ttt 的祖先），存在多少个二元组 (x,y)(x,y)(x,y) （ xxx，yyy 都是 trie 中的节点且 xxx 是 yyy 的祖先），满足 sss ~ ttt 路径上的字符串和 xxx ~ yyy 路径上的字符串完全一样？ 注意 sss 可以等于 ttt ， xxx 也可以等于 yyy 。 Constraints 1≤N,M≤1000001\\leq N,M \\leq 1000001≤N,M≤100000 ， 1≤sum≤10000001\\leq sum \\leq 10000001≤sum≤1000000 Solution 先构建出 trie ，然后在 trie 上面建 sam。分别需要记录下原串的每个节点在 trie 上的位置和 trie 上的每个节点在 sam 上的位置。 对于一个询问，从 ttt 对应在 sam 上面的节点开始，在 parent 树上跳直到深度最浅的满足节点对应长度不小于询问串的节点为止，该节点的 right 集合大小即为答案。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;int n,m,p,l,r,cnt,length,head,tail;int pos[N],spos[N],len[N];char s[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;struct sam&#123; int size,root,len; int mx[N*2],fa[N*2],sz[N*2],ch[N*2][26]; int c[N],id[N*2],f[N*2][21]; sam() &#123; size=root=1; memset(sz,0,sizeof(sz)); memset(ch,0,sizeof(ch)); &#125; int ins(int c,int x) &#123; int np=++size;mx[np]=mx[x]+1; len=max(len,mx[np]);sz[np]=1; while(x&amp;&amp;!ch[x][c])ch[x][c]=np,x=fa[x]; if(!x)fa[np]=root; else &#123; int y=ch[x][c]; if(mx[y]==mx[x]+1)fa[np]=y; else &#123; int nq=++size; memcpy(ch[nq],ch[y],sizeof(ch[y])); mx[nq]=mx[x]+1; fa[nq]=fa[y];fa[y]=fa[np]=nq; while(x&amp;&amp;ch[x][c]==y)ch[x][c]=nq,x=fa[x]; &#125; &#125; return np; &#125; void build() &#123; for(int i=1;i&lt;=size;i++)c[mx[i]]++; for(int i=1;i&lt;=len;i++)c[i]+=c[i-1]; for(int i=1;i&lt;=size;i++)id[c[mx[i]]--]=i; for(int i=size;i&gt;=1;i--)sz[fa[id[i]]]+=sz[id[i]]; for(int i=1;i&lt;=size;i++) &#123; int x=id[i];f[x][0]=fa[x]; for(int j=1;j&lt;=20;j++)f[x][j]=f[f[x][j-1]][j-1]; &#125; &#125; int find(int x,int len) &#123; for(int i=20;i&gt;=0;i--) if(mx[f[x][i]]&gt;=len)x=f[x][i]; return sz[x]; &#125;&#125;S;struct node&#123;int id,np;&#125;t,q[N];struct trie&#123; int sz,ch[N][26]; trie()&#123;sz=0;memset(ch,0,sizeof(ch));&#125; void insert(char *s,int n) &#123; int cur=0; for(int i=0;i&lt;n;i++) &#123; int c=s[i]-'a'; if(!ch[cur][c])ch[cur][c]=++sz; cur=ch[cur][c];pos[++cnt]=cur; &#125; &#125; void bfs() &#123; q[tail++]=(node)&#123;0,1&#125;; while(head!=tail) &#123; t=q[head++]; int u=t.id,last=t.np; for(int c=0;c&lt;26;c++) &#123; if(!ch[u][c])continue; int np=S.ins(c,last); spos[ch[u][c]]=np; q[tail++]=(node)&#123;ch[u][c],np&#125;; &#125; &#125; &#125;&#125;T;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; scanf(\"%s\",s); length=strlen(s); len[i]=len[i-1]+length; T.insert(s,length); &#125; T.bfs();S.build(); m=read(); while(m--) &#123; p=read();l=read();r=read(); printf(\"%d\\n\",S.find(spos[pos[r+len[p-1]]],r-l+1)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"后缀自动机","slug":"后缀自动机","permalink":"http://yoursite.com/tags/后缀自动机/"},{"name":"trie","slug":"trie","permalink":"http://yoursite.com/tags/trie/"},{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"}]},{"title":"「51nod 1648」洞","slug":"51nod1648","date":"2018-05-31T23:29:48.000Z","updated":"2018-05-31T23:33:03.130Z","comments":true,"path":"51nod1648/","link":"","permalink":"http://yoursite.com/51nod1648/","excerpt":"小 P 非常喜欢玩。他最喜欢玩的一个游戏就是《洞》，这个游戏遵循以下规则： 有 NNN 个洞呈直线分布，并且从左到右依次编号为 111 到 NNN 。每个洞都有它自己的能量值（编号为 iii 的洞有能量值 aia_iai​ ）。如果你把一个球扔到洞 iii ，它会迅速调到洞 i+aii+a_ii+ai​ ，以此类推。如果没有编号为 i+aii+a_ii+ai​ 的洞，这个球将会跳到这洞外，结束循环。玩家将会执行 MMM 次以下两种操作之一： 设置洞 aaa 的能量值为 bbb 。 将球扔到洞 aaa ，计算球跳到洞外之前跳跃的次数，以及球刚好跳到洞外之前最后经过的洞的编号。 小 P 不擅长数学，所以将由你实现这些计算。","text":"小 P 非常喜欢玩。他最喜欢玩的一个游戏就是《洞》，这个游戏遵循以下规则： 有 NNN 个洞呈直线分布，并且从左到右依次编号为 111 到 NNN 。每个洞都有它自己的能量值（编号为 iii 的洞有能量值 aia_iai​ ）。如果你把一个球扔到洞 iii ，它会迅速调到洞 i+aii+a_ii+ai​ ，以此类推。如果没有编号为 i+aii+a_ii+ai​ 的洞，这个球将会跳到这洞外，结束循环。玩家将会执行 MMM 次以下两种操作之一： 设置洞 aaa 的能量值为 bbb 。 将球扔到洞 aaa ，计算球跳到洞外之前跳跃的次数，以及球刚好跳到洞外之前最后经过的洞的编号。 小 P 不擅长数学，所以将由你实现这些计算。 Constraints 1≤n,m≤1000001\\leq n,m \\leq 1000001≤n,m≤100000 Solution 裸的分块。 需要注意的一点是，要记录下跳出去之前的最后一个洞。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,m,block,l,r,op,x,ans;int a[N],b[N],to[N],cnt[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void modify(int i)&#123; l=(i-1)*block+1; r=min(n,i*block); for(int j=r;j&gt;=l;j--) &#123; if(a[j]&gt;r) &#123; if(a[j]&gt;n)to[j]=j,cnt[j]=0; else to[j]=a[j],cnt[j]=1; &#125; else to[j]=to[a[j]],cnt[j]=cnt[a[j]]+1; &#125;&#125;int main()&#123; n=read();m=read();block=sqrt(n); for(int i=1;i&lt;=n;i++) a[i]=i+read(),b[i]=(i-1)/block+1; for(int i=1;i&lt;=(n-1)/block+1;i++)modify(i); while(m--) &#123; op=read();x=read(); if(!op)a[x]=x+read(),modify(b[x]); else &#123; ans=0; while(x!=to[x])ans+=cnt[x],x=to[x]; printf(\"%d %d\\n\",x,ans+1); &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"分块","slug":"分块","permalink":"http://yoursite.com/tags/分块/"}]},{"title":"「51nood 1769」Clarke and math2","slug":"51nod1769","date":"2018-05-30T23:19:24.000Z","updated":"2018-05-31T08:40:28.141Z","comments":true,"path":"51nod1769/","link":"","permalink":"http://yoursite.com/51nod1769/","excerpt":"克拉克是一名人格分裂患者。某一天他变成一名数学家，在研究奇怪的东西。 他突然想算这么一个式子，给出 f(i),1≤i≤nf(i), 1 \\le i \\le nf(i),1≤i≤n ，要求算： g(i)=∑i1∣i∑i2∣i1∑i3∣i2⋯∑ik∣ik−1f(ik) mod 1000000007 (1≤i≤n,ij∈N+)\\displaystyle g(i) = \\sum_{i_1 \\mid i} \\sum_{i_2 \\mid i_1} \\sum_{i_3 \\mid i_2} \\cdots \\sum_{i_k \\mid i_{k-1}} f(i_k) \\text{ mod } 1000000007 \\ \\ (1 \\le i \\le n,i_j \\in \\mathbb{N}^+) g(i)=i1​∣i∑​i2​∣i1​∑​i3​∣i2​∑​⋯ik​∣ik−1​∑​f(ik​) mod 1000000007 (1≤i≤n,ij​∈N+) ∣\\mid∣ 是整除的意思,比如 i1=5i_1 = 5i1​=5 , i2=10i_2 = 10i2​=10 则 i1∣i2i_1 \\mid i_2i1​∣i2​。","text":"克拉克是一名人格分裂患者。某一天他变成一名数学家，在研究奇怪的东西。 他突然想算这么一个式子，给出 f(i),1≤i≤nf(i), 1 \\le i \\le nf(i),1≤i≤n ，要求算： g(i)=∑i1∣i∑i2∣i1∑i3∣i2⋯∑ik∣ik−1f(ik) mod 1000000007 (1≤i≤n,ij∈N+)\\displaystyle g(i) = \\sum_{i_1 \\mid i} \\sum_{i_2 \\mid i_1} \\sum_{i_3 \\mid i_2} \\cdots \\sum_{i_k \\mid i_{k-1}} f(i_k) \\text{ mod } 1000000007 \\ \\ (1 \\le i \\le n,i_j \\in \\mathbb{N}^+) g(i)=i1​∣i∑​i2​∣i1​∑​i3​∣i2​∑​⋯ik​∣ik−1​∑​f(ik​) mod 1000000007 (1≤i≤n,ij​∈N+) ∣\\mid∣ 是整除的意思,比如 i1=5i_1 = 5i1​=5 , i2=10i_2 = 10i2​=10 则 i1∣i2i_1 \\mid i_2i1​∣i2​。 Constraints 1≤n≤5000001 \\leq n \\leq 5000001≤n≤500000 ， 1≤k≤1010000001 \\leq k \\leq 10^{1000000}1≤k≤101000000 Solution 考虑从 iki_kik​ 到 iii 的变化过程，等价于 iki_kik​ 乘上 kkk 个数得到 iii ，实际只要求满足 kkk 个数乘起来为 iik\\frac{i}{i_k}ik​i​ 的因数的方案数即可。 对 iik\\frac{i}{i_k}ik​i​ 分解质因数，考虑其中的一个质因子 ppp 以及它的次数 xxx ，利用隔板法可得当前质因子的贡献是 (k−x−1k−1)\\binom{k-x-1}{k-1}(k−1k−x−1​) （将 xxx 个 ppp 分配到这 kkk 个数里）。 kkk 很大，用 Lucas 定理可得直接将 kkk 取模即可。 剩下的就直接线性筛了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e5+5;const int mod=1e9+7;int n,K,cnt,now;int f[N],inv[N],v[N],e[N],pri[N],ans[N];bool np[N];int read()&#123; LL x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=(x*10+c-'0')%mod;c=getchar();&#125; return x*f;&#125;int main()&#123; n=read();K=read(); inv[1]=1; for(int i=2;i&lt;=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; for(int i=1;i&lt;=n;i++)f[i]=read(); v[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(!np[i])&#123;pri[++cnt]=i;v[i]=K;e[i]=1;&#125; for(int j=1;i*pri[j]&lt;=n;j++) &#123; now=i*pri[j]; np[now]=true; if(i%pri[j]==0) &#123; e[now]=e[i]+1; v[now]=1ll*v[i]*(e[now]+K-1)%mod*inv[e[now]]%mod; break; &#125; e[now]=1; v[now]=1ll*v[i]*K%mod; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;i*j&lt;=n;j++) ans[i*j]=(ans[i*j]+1ll*v[i]*f[j]%mod)%mod; for(int i=1;i&lt;=n;i++)printf(\"%d \",ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"},{"name":"线性筛","slug":"线性筛","permalink":"http://yoursite.com/tags/线性筛/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"「51nod 1792」Jabby's segment tree","slug":"51nod1792","date":"2018-05-30T12:31:25.000Z","updated":"2018-05-30T12:45:44.812Z","comments":true,"path":"51nod1792/","link":"","permalink":"http://yoursite.com/51nod1792/","excerpt":"线段树是一种经典的数据结构，一颗 [1,n][1,n][1,n] 的线段树他的根是 [1,n][1,n][1,n] ，当一个线段树的结点是 [l,r][l,r][l,r] 时，设 mid=(l+r)/2mid=(l+r)/2mid=(l+r)/2 ，则这个结点的左儿子右儿子分别是 [l,mid][l,mid][l,mid] ， [mid+1,r][mid+1,r][mid+1,r] 。 当我们在线段树上跑 [x,y][x,y][x,y] 询问时，一般是从根节点开始计算的，设现在所在结点是 [l,r][l,r][l,r] ，有以下几种分支： 若 [x,y][x,y][x,y] 包含 [l,r][l,r][l,r] ，计算结束。 否则，若左儿子和 [x,y][x,y][x,y] 有交，计算左儿子，若右儿子和 [x,y][x,y][x,y] 有交，计算右儿子。 定义询问 [x,y][x,y][x,y] 的费用是询问时计算了几个结点。 给定 QQQ 次询问，每次给定 lll , rrr ，求满足 l≤x≤y≤rl\\leq x\\leq y\\leq rl≤x≤y≤r 的 (x,y)(x,y)(x,y) 的费用之和。","text":"线段树是一种经典的数据结构，一颗 [1,n][1,n][1,n] 的线段树他的根是 [1,n][1,n][1,n] ，当一个线段树的结点是 [l,r][l,r][l,r] 时，设 mid=(l+r)/2mid=(l+r)/2mid=(l+r)/2 ，则这个结点的左儿子右儿子分别是 [l,mid][l,mid][l,mid] ， [mid+1,r][mid+1,r][mid+1,r] 。 当我们在线段树上跑 [x,y][x,y][x,y] 询问时，一般是从根节点开始计算的，设现在所在结点是 [l,r][l,r][l,r] ，有以下几种分支： 若 [x,y][x,y][x,y] 包含 [l,r][l,r][l,r] ，计算结束。 否则，若左儿子和 [x,y][x,y][x,y] 有交，计算左儿子，若右儿子和 [x,y][x,y][x,y] 有交，计算右儿子。 定义询问 [x,y][x,y][x,y] 的费用是询问时计算了几个结点。 给定 QQQ 次询问，每次给定 lll , rrr ，求满足 l≤x≤y≤rl\\leq x\\leq y\\leq rl≤x≤y≤r 的 (x,y)(x,y)(x,y) 的费用之和。 Constraints 1≤n,Q≤1000001\\leq n,Q \\leq 1000001≤n,Q≤100000 Solution 直接在线段树上维护答案。 假设当前节点编号为 xxx ，代表的区间为 [l,r][l,r][l,r] ，则令： t(x)t(x)t(x) 表示两个端点都在区间 [l,r][l,r][l,r] 内的答案； tl(x)tl(x)tl(x) 表示查询左端点为 lll ，右端点位于 [l,r)[l,r)[l,r) 的答案； tr(x)tr(x)tr(x) 表示查询右端点为 rrr ，左端点位于 (l,r](l,r](l,r] 内的答案。 具体的统计方式见代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)#define LL long longusing namespace std;const int N=1e5+5;const int mod=1e9+7;int n,Q,L,R,ans;int t[N*4],tl[N*4],tr[N*4];void Mod(int &amp;a,int b)&#123;a+=b;while(a&gt;=mod)a-=mod;&#125;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void update(int x,int l,int r)&#123; int mid=(l+r)&gt;&gt;1; Mod(tl[x],tl[lc]+1); Mod(tl[x],tl[rc]+r-mid-1); Mod(tl[x],r-l); Mod(tr[x],tr[rc]+1); Mod(tr[x],tr[lc]+mid-l); Mod(tr[x],r-l); Mod(t[x],t[lc]); Mod(t[x],t[rc]); Mod(t[x],1ll*tr[lc]*(r-mid)%mod); Mod(t[x],1ll*tl[rc]*(mid-l+1)%mod); Mod(t[x],r-mid-1); Mod(t[x],mid-l); int len=r-l+1; Mod(t[x],1ll*len*(len+1)/2%mod);&#125;void build(int x,int l,int r)&#123; if(l==r)&#123;t[x]=1;return;&#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid); build(rc,mid+1,r); update(x,l,r);&#125;void calc(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; Mod(ans,t[x]); if(L&lt;l)Mod(ans,1ll*(tl[x]+1)*(l-L)%mod); if(R&gt;r)Mod(ans,1ll*(tr[x]+1)*(R-r)%mod); if(L&lt;l&amp;&amp;R&gt;r)Mod(ans,1ll*(l-L)*(R-r)%mod); return; &#125; int ll=max(L,l),rr=min(R,r),len=rr-ll+1; Mod(ans,1ll*len*(len+1)/2%mod); if(L&lt;l)Mod(ans,1ll*(l-L)*len%mod); if(R&gt;r)Mod(ans,1ll*(R-r)*len%mod); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)calc(lc,l,mid); if(R&gt;mid)calc(rc,mid+1,r);&#125;int main()&#123; n=read();Q=read(); build(1,1,n); while(Q--) &#123; L=read();R=read(); ans=0;calc(1,1,n); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"「51nod 1743」雪之国度","slug":"51nod1743","date":"2018-05-27T02:59:39.000Z","updated":"2018-05-27T06:50:37.067Z","comments":true,"path":"51nod1743/","link":"","permalink":"http://yoursite.com/51nod1743/","excerpt":"雪之国度有 NNN 座城市，依次编号为 111 到 NNN，又有 MMM 条道路连接了其中的城市，每一条道路都连接了不同的 222 个城市，任何两座不同的城市之间可能不止一条道路。 雪之女王赋予了每一座城市不同的能量，其中第 iii 座城市被赋予的能量为 WiW_iWi​ 。如果城市 uuu 和 vvv 之间有一条道路，那么只要此刻雪之女王的能量不小于 ∣Wu−Wv∣|W_u-W_v|∣Wu​−Wv​∣ ，这条道路就是安全的。如果城市 uuu 和 vvv 之间存在两条没有重复道路的安全路径（其中每一段道路都是安全的），则认为这两座城市之间有着良好的贸易关系。 最近，雪之女王因为情感问题，她的能量产生巨大的波动。为了维持雪之国度的经济贸易，她希望你能帮忙对 QQQ 对城市进行调查。 对于第 jjj 对城市 uju_juj​ 和 vjv_jvj​ ，她希望知道在保证这两座城市之间有着良好贸易关系的前提之下，自己最少需要保持多少的能量。","text":"雪之国度有 NNN 座城市，依次编号为 111 到 NNN，又有 MMM 条道路连接了其中的城市，每一条道路都连接了不同的 222 个城市，任何两座不同的城市之间可能不止一条道路。 雪之女王赋予了每一座城市不同的能量，其中第 iii 座城市被赋予的能量为 WiW_iWi​ 。如果城市 uuu 和 vvv 之间有一条道路，那么只要此刻雪之女王的能量不小于 ∣Wu−Wv∣|W_u-W_v|∣Wu​−Wv​∣ ，这条道路就是安全的。如果城市 uuu 和 vvv 之间存在两条没有重复道路的安全路径（其中每一段道路都是安全的），则认为这两座城市之间有着良好的贸易关系。 最近，雪之女王因为情感问题，她的能量产生巨大的波动。为了维持雪之国度的经济贸易，她希望你能帮忙对 QQQ 对城市进行调查。 对于第 jjj 对城市 uju_juj​ 和 vjv_jvj​ ，她希望知道在保证这两座城市之间有着良好贸易关系的前提之下，自己最少需要保持多少的能量。 Constraints 3≤N≤1000003\\leq N\\leq 1000003≤N≤100000 ， 3≤M≤5000003\\leq M\\leq 5000003≤M≤500000 ， 1≤Q≤1000001\\leq Q\\leq 1000001≤Q≤100000 ， 0≤W≤2000000\\leq W\\leq 2000000≤W≤200000 Solution 城市间存在两条没有重复道路的安全路径，即两座城市在同一个边双里。题意可以转化为，在保证两个城市在同一个边双联通分量的情况下，求最大边权的最小值。很容易想到一种做法：将边按照边权从小到大加入直到两座城市在同一个边双里。 首先构造出原图的最小生成树，然后考虑按照边权从小到大加入非树边。考虑加进一条非树边会造成的影响：在加入非树边 u−vu-vu−v 时，uuu 到 vvv 的简单路径上的所有点都会被缩进一个边双联通分量里，这时候我们可以给路径上的所有点打上这条非树边边权的标记，代表这个点与其父亲第一次进入同一个边双时该边双的最大边权。然后利用并查集将路径上的所有点缩成一个点，避免已更新过的点被重复更新。 现在考虑处理询问。利用并查集可以直接判断两个点最后是否在同一个边双里。若在，则答案为 uuu 和 vvv 路径上的除 lcalcalca 外节点标记最大值。 具体可以用倍增来实现，时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,m,Q,cnt,x,y,tot;int first[N],w[N],f[N];int deep[N],fa[N][17],v[N][17];bool ontr[N*5];struct node&#123;int x,y,v;&#125;a[N*5];struct edge&#123;int to,next,w;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.v&lt;b.v;&#125;void ins(int u,int v,int w)&#123;e[++cnt]=(edge)&#123;v,first[u],w&#125;;first[u]=cnt;&#125; int find(int t)&#123;return f[t]==t?t:f[t]=find(f[t]);&#125;void dfs(int x,int last)&#123; for(int i=1;(1&lt;&lt;i)&lt;=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==last)continue; fa[to][0]=x;v[to][0]=e[i].w; deep[to]=deep[x]+1;dfs(to,x); &#125;&#125;void modify(int &amp;x,int val)&#123;v[x][0]=val;f[x]=find(fa[x][0]);x=f[x];&#125;int tim=0;int lca(int x,int y)&#123; if(deep[x]&lt;deep[y])swap(x,y); int ans=0,d=deep[x]-deep[y]; for(int i=0;(1&lt;&lt;i)&lt;=d;i++) if((1&lt;&lt;i)&amp;d)ans=max(ans,v[x][i]),x=fa[x][i]; if(x==y)return ans; for(int i=16;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) &#123; ans=max(ans,max(v[x][i],v[y][i])); x=fa[x][i];y=fa[y][i]; &#125; ans=max(ans,max(v[x][0],v[y][0])); return ans;&#125;int main()&#123; n=read();m=read();Q=read(); for(int i=1;i&lt;=n;i++)w[i]=read(); for(int i=1;i&lt;=m;i++) &#123; a[i].x=read();a[i].y=read(); a[i].v=abs(w[a[i].x]-w[a[i].y]); &#125; sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=n;i++)f[i]=i; for(int i=1;i&lt;=m;i++) &#123; x=find(a[i].x);y=find(a[i].y); if(x==y)continue; ins(a[i].x,a[i].y,a[i].v); ins(a[i].y,a[i].x,a[i].v); tot++;ontr[i]=true;f[y]=x; if(tot==n-1)break; &#125; dfs(1,-1); for(int i=1;i&lt;=n;i++)f[i]=i; for(int i=1;i&lt;=m;i++) &#123; if(ontr[i])continue; x=find(a[i].x);y=find(a[i].y); if(x==y)continue; while(x!=y) &#123; if(deep[x]&gt;deep[y])modify(x,a[i].v); else modify(y,a[i].v); &#125; &#125; for(int j=1;j&lt;=16;j++) for(int i=1;i&lt;=n;i++) v[i][j]=max(v[i][j-1],v[fa[i][j-1]][j-1]); while(Q--) &#123; x=read();y=read(); if(find(x)!=find(y))printf(\"infinitely\\n\"); else printf(\"%d\\n\",lca(x,y)); &#125; return 0;&#125;","categories":[],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"},{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"},{"name":"最近公共祖先","slug":"最近公共祖先","permalink":"http://yoursite.com/tags/最近公共祖先/"}]},{"title":"「51nod 1860」BigPrime","slug":"51nod1860","date":"2018-05-25T11:54:34.000Z","updated":"2018-05-30T12:39:29.743Z","comments":true,"path":"51nod1860/","link":"","permalink":"http://yoursite.com/51nod1860/","excerpt":"我们把所有大于整数 ppp 的质数称作大质数。 现在我们要统计区间 [a,b][a,b][a,b] 中有多少数其至少有一个约数是大质数。","text":"我们把所有大于整数 ppp 的质数称作大质数。 现在我们要统计区间 [a,b][a,b][a,b] 中有多少数其至少有一个约数是大质数。 Constraints p≤106p\\leq 10^6p≤106 ， a≤109a\\leq 10^9a≤109 ， b−a≤108b-a\\leq 10^8b−a≤108 Solution 先把 222 至 ppp 所有质数预处理出来。记第 kkk 个质数为 pkp_kpk​。令 f(x,y,b)f(x,y,b)f(x,y,b) 表示 [x,y][x,y][x,y] 中所有质因子不大于 pbp_bpb​ 的数个数。 分以下几种情况： 若 x&gt;yx&gt;yx&gt;y 则 f(x,y,b)=0f(x,y,b)=0f(x,y,b)=0 若 b=0b=0b=0 且 x=1≤yx=1\\leq yx=1≤y 则 f(x,y,b)=1f(x,y,b)=1f(x,y,b)=1 若 x=yx=yx=y 则暴力分解 xxx 看是否满足。（可以部分预处理） 若 y≤pby\\leq p_by≤pb​ 则 f(x,y,b)=y−x+1f(x,y,b)=y-x+1f(x,y,b)=y−x+1 否则 f(x,y,b)=f(x,y,b−1)+f(xpb,ypb,b)f(x,y,b)=f(x,y,b-1)+f(\\frac{x}{p_b},\\frac{y}{p_b},b)f(x,y,b)=f(x,y,b−1)+f(pb​x​,pb​y​,b) （上取整） 最后一种情况的意思是，当前 [x,y][x,y][x,y] 中质因子不包含 pbp_bpb​ 的数。后一个是至少包含一个 pbp_bpb​ 的数，可以把 pbp_bpb​ 除下去以后递归求解。 以上是官方题解。 以下是另一种写法，原理基本一致。 令 f(x,y,c)f(x,y,c)f(x,y,c) 表示在 (x,y](x,y](x,y] 这个区间中所有质因子均不小于 pcp_cpc​ 且不大于 ppp 的数个数。 枚举第 ccc 个及其后面的质数，递归计算 f(xpc,ypc,c)f(\\frac{x}{p_c},\\frac{y}{p_c},c)f(pc​x​,pc​y​,c) 并累加。由于需要特殊处理 111 的情况，当 x=0x=0x=0 时 ansansans 初值为 111 。其余处理细节详见代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int N=1e6+5;int p,a,b,cnt,limit,pri[N];bool np[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int f(int x,int y,int c)&#123; if(x==y)return 0; int ans=(x==0); while(c&lt;=cnt&amp;&amp;1ll*pri[c]*pri[c]&lt;=y)ans+=f(x/pri[c],y/pri[c],c),c++; ans+=upper_bound(pri+c,pri+cnt+1,y)-upper_bound(pri+c,pri+cnt+1,x); return ans;&#125;int main()&#123; p=read();a=read();b=read(); for(int i=2;i&lt;=p;i++) &#123; if(!np[i])pri[++cnt]=i; for(int j=1;i*pri[j]&lt;=p;j++) &#123; np[i*pri[j]]=true; if(i%pri[j]==0)break; &#125; &#125; printf(\"%d\\n\",b-a+1-f(a-1,b,1)); return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"},{"name":"线性筛","slug":"线性筛","permalink":"http://yoursite.com/tags/线性筛/"}]},{"title":"「51nod 1863」Travel","slug":"51nod1863","date":"2018-05-25T10:04:06.000Z","updated":"2018-05-25T10:16:04.550Z","comments":true,"path":"51nod1863/","link":"","permalink":"http://yoursite.com/51nod1863/","excerpt":"Fancy 年青的时候喜欢旅行。据他回忆说，那曾是一段有始有终的旅行。 他来到了一个叫 Fancy 的理想国。那里有许许多多的 FancyCat 。最开始的时候，同一种 FancyCat 会形成一个部落，拥有特定的一块领地。Fancy 第一次来这里的时候还 Too Young ，现在他将故地重游。但由于多年的演变，部落分分合合，现在两个不一样的部落有可能也是由同一种 FancyCat 组成。 Fancy 开始了他的徒步路程。每次他经过某一个部落，他将收到由该部落种类的纪念品一份。Fancy 很喜欢收集纪念品。他是一个性情中人，越喜欢的纪念品他就越想得到，而且要越多越好。Fancy 列出了一张纪念品喜欢程度的排名表。在这个表中越靠前的纪念品表示 Fancy 越喜欢。 由于理想国过于庞大，虽然拥有地图，但 Fancy 也会因为找不到地图上对应的位置而经常迷路。 Fancy 觉得与其在地图中苦苦挣扎不如随机走。而且他坚信一定能走到终点！ Fancy 在旅行开始前，想到可以先计算一下期望得到的每个纪念品的数量，不过由于图中环的存在，给计算带来了很大困难。于是 Fancy 打算只计算一下自己完全随机乱走的情况下最坏能得到的那些纪念品。对于两条旅行线路的比较，他采取了如下的方法：找出在排名表中最靠前的一个纪念品，满足两条线路中获得的该纪念品数量不相等。这时候，该纪念品多的那一条线路更优。 你要做的工作就是计算出最坏情况下的得到纪念品序列。","text":"Fancy 年青的时候喜欢旅行。据他回忆说，那曾是一段有始有终的旅行。 他来到了一个叫 Fancy 的理想国。那里有许许多多的 FancyCat 。最开始的时候，同一种 FancyCat 会形成一个部落，拥有特定的一块领地。Fancy 第一次来这里的时候还 Too Young ，现在他将故地重游。但由于多年的演变，部落分分合合，现在两个不一样的部落有可能也是由同一种 FancyCat 组成。 Fancy 开始了他的徒步路程。每次他经过某一个部落，他将收到由该部落种类的纪念品一份。Fancy 很喜欢收集纪念品。他是一个性情中人，越喜欢的纪念品他就越想得到，而且要越多越好。Fancy 列出了一张纪念品喜欢程度的排名表。在这个表中越靠前的纪念品表示 Fancy 越喜欢。 由于理想国过于庞大，虽然拥有地图，但 Fancy 也会因为找不到地图上对应的位置而经常迷路。 Fancy 觉得与其在地图中苦苦挣扎不如随机走。而且他坚信一定能走到终点！ Fancy 在旅行开始前，想到可以先计算一下期望得到的每个纪念品的数量，不过由于图中环的存在，给计算带来了很大困难。于是 Fancy 打算只计算一下自己完全随机乱走的情况下最坏能得到的那些纪念品。对于两条旅行线路的比较，他采取了如下的方法：找出在排名表中最靠前的一个纪念品，满足两条线路中获得的该纪念品数量不相等。这时候，该纪念品多的那一条线路更优。 你要做的工作就是计算出最坏情况下的得到纪念品序列。 Constraints n≤100000n\\leq 100000n≤100000 ， m≤500000m\\leq 500000m≤500000 Solution 据题意，显然最坏情况就是从 111 到 nnn 的最短路，这里的最短即为题意中的最劣，每个点的 disdisdis 可以按排名表统计为一个序列。 主要问题在两个序列的比较，这里我们使用主席树来维护序列的哈希值，比较两个序列的字典序时在主席树上二分即可。 详见代码，时间复杂度 O((n+m)lognlogn)O((n+m)lognlogn)O((n+m)lognlogn) 。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;queue&gt;#define LL long longusing namespace std;const int N=1e5+5;const LL base=20010311;int n,m,cnt,idx,x,y,t,cur;int first[N],id[N],rk[N],a[N];int rt[N],ls[N*50],rs[N*50];LL bit[N],v[N*50];struct edge&#123;int to,next;&#125;e[N*10];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void add(int &amp;x,int l,int r,int c)&#123; int t=x;x=++idx; ls[x]=ls[t];rs[x]=rs[t];v[x]=v[t]; if(l==r)&#123;v[x]++;return;&#125; int mid=(l+r)&gt;&gt;1; if(c&lt;=mid)add(ls[x],l,mid,c); else add(rs[x],mid+1,r,c); v[x]=v[ls[x]]*bit[r-mid]+v[rs[x]];&#125;bool cmp(int x,int y)&#123; if(v[x]==v[y])return false; int l=1,r=n; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if(v[ls[x]]!=v[ls[y]])x=ls[x],y=ls[y],r=mid; else x=rs[x],y=rs[y],l=mid+1; &#125; return v[x]&lt;v[y];&#125;struct node&#123; int x,t; bool operator &lt; (const node&amp; a)const&#123;return !cmp(t,a.t);&#125; &#125;;priority_queue&lt;node&gt; q;void dfs(int x,int l,int r)&#123; if(!x)return; if(l==r)&#123;for(int i=1;i&lt;=v[x];i++)printf(\"%d \",id[l]);return;&#125; int mid=(l+r)&gt;&gt;1; dfs(ls[x],l,mid);dfs(rs[x],mid+1,r);&#125;int main()&#123; n=read();m=read();bit[0]=1; for(int i=1;i&lt;=n;i++)bit[i]=bit[i-1]*base; for(int i=1;i&lt;=n;i++) id[i]=read(),rk[id[i]]=i; for(int i=1;i&lt;=n;i++) a[i]=read(),a[i]=rk[a[i]]; for(int i=1;i&lt;=m;i++) x=read(),y=read(),ins(x,y),ins(y,x); q.push((node)&#123;1,rt[1]&#125;); while(!q.empty()) &#123; x=q.top().x;t=q.top().t;q.pop(); if(t!=rt[x])continue; cur=rt[x];add(cur,1,n,a[x]); for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!rt[to]||cmp(cur,rt[to])) &#123; rt[to]=cur; q.push((node)&#123;to,rt[to]&#125;); &#125; &#125; &#125; add(rt[n],1,n,a[n]); dfs(rt[n],1,n); return 0;&#125;","categories":[],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://yoursite.com/tags/主席树/"},{"name":"哈希","slug":"哈希","permalink":"http://yoursite.com/tags/哈希/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://yoursite.com/tags/Dijkstra/"}]},{"title":"「51nod 1510」最小化序列","slug":"51nod1510","date":"2018-05-25T06:19:53.000Z","updated":"2018-05-25T06:29:35.837Z","comments":true,"path":"51nod1510/","link":"","permalink":"http://yoursite.com/51nod1510/","excerpt":"现在有一个长度为 nnn 的数组 AAA ，另外还有一个整数 kkk 。数组下标从 111 开始。 现在你需要把数组的顺序重新排列一下使得下面这个的式子的值尽可能小。 ∑i=1n−k∣A[i]−A[i+k]∣\\sum_{i=1}^{n-k}{|A[i]-A[i+k]|} i=1∑n−k​∣A[i]−A[i+k]∣ 特别的，你也可以不对数组进行重新排列。","text":"现在有一个长度为 nnn 的数组 AAA ，另外还有一个整数 kkk 。数组下标从 111 开始。 现在你需要把数组的顺序重新排列一下使得下面这个的式子的值尽可能小。 ∑i=1n−k∣A[i]−A[i+k]∣\\sum_{i=1}^{n-k}{|A[i]-A[i+k]|} i=1∑n−k​∣A[i]−A[i+k]∣ 特别的，你也可以不对数组进行重新排列。 Constraints $ 2\\leq n\\leq 3\\cdot 10^5$ ， 1≤k≤min(5000,n−1)1 \\leq k \\leq min(5000,n-1)1≤k≤min(5000,n−1) Solution 观察可得式子实际上将 nnn 个数字分成了不相关的 kkk 组，其中有 nmodkn \\bmod knmodk 组大小为 nk+1\\frac{n}{k}+1kn​+1 ，剩余的长度为 nk\\frac{n}{k}kn​ 。 将 AAA 数组排序后，贪心地得出每一组都是连续的一段，代价为最后一个数 −-− 第一个数。 令 f(i,j)f(i,j)f(i,j) 表示当前已有 iii 组较大的分组与 jjj 组较小的分组的最小代价，直接 dp 即可。 时间复杂度 O(k2)O(k^2)O(k2) 。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=3e5+5;const int K=5e3+5;int lcnt,scnt,leng,seng;int n,k,t,a[N],f[K][K];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void update(int &amp;a,int b)&#123; if(a==-1)a=b; else a=min(a,b);&#125;int main()&#123; n=read();k=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1); lcnt=n%k;scnt=k-lcnt; leng=n/k+1;seng=n/k; memset(f,-1,sizeof(f)); f[0][0]=0; for(int i=0;i&lt;=lcnt;i++) for(int j=0;j&lt;=scnt;j++) &#123; if(f[i][j]==-1)continue; t=i*leng+j*seng; if(i!=lcnt)update(f[i+1][j],f[i][j]+a[t+leng]-a[t+1]); if(j!=scnt)update(f[i][j+1],f[i][j]+a[t+seng]-a[t+1]); &#125; printf(\"%d\",f[lcnt][scnt]); return 0;&#125;","categories":[],"tags":[{"name":"普通dp","slug":"普通dp","permalink":"http://yoursite.com/tags/普通dp/"}]},{"title":"「51nod 1519」拆方块","slug":"51nod1519","date":"2018-05-25T06:02:54.000Z","updated":"2018-05-25T06:09:19.755Z","comments":true,"path":"51nod1519/","link":"","permalink":"http://yoursite.com/51nod1519/","excerpt":"有 nnn 堆方块，第 iii 堆方块由 hih_ihi​ 个方块堆积而成。 接下来拆方块。一个方块称为内部方块当且仅当他的上下左右都是方块或者是地面。否则方块就是边界方块。每一次操作都要把边界方块拿掉。 问多少次操作之后所有方块会消失。","text":"有 nnn 堆方块，第 iii 堆方块由 hih_ihi​ 个方块堆积而成。 接下来拆方块。一个方块称为内部方块当且仅当他的上下左右都是方块或者是地面。否则方块就是边界方块。每一次操作都要把边界方块拿掉。 问多少次操作之后所有方块会消失。 Constraints 1≤n≤1051 \\leq n \\leq 10^51≤n≤105 Solution 观察可得，每一轮进行的操作为 hi=min(hi−1,hi−1,hi+1)h_i=min(h_{i-1},h_i-1,h_{i+1})hi​=min(hi−1​,hi​−1,hi+1​) 。当一列方块被拆掉时，下一轮他的相邻两列中未被拆掉的列也会被拆掉。 从左往右和从右往左分别扫一遍，取 min 即是当前列被拆掉的操作次序。时间复杂度 O(n)O(n)O(n) 。 Code 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,ans,h[N],l[N],r[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)h[i]=read(); l[1]=1;for(int i=2;i&lt;=n;i++)l[i]=min(l[i-1]+1,h[i]); r[n]=1;for(int i=n-1;i&gt;=1;i--)r[i]=min(r[i+1]+1,h[i]); for(int i=1;i&lt;=n;i++)ans=max(ans,min(l[i],r[i])); printf(\"%d\",ans); return 0;&#125;","categories":[],"tags":[{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"「51nod 1055」最长等差数列","slug":"51nod1055","date":"2018-05-25T05:48:21.000Z","updated":"2018-05-25T05:54:09.973Z","comments":true,"path":"51nod1055/","link":"","permalink":"http://yoursite.com/51nod1055/","excerpt":"NNN 个不同的正整数，找出由这些数组成的最长的等差数列。","text":"NNN 个不同的正整数，找出由这些数组成的最长的等差数列。 Constraints $ n \\leq 10000$ Solution dp(i,j)dp(i,j)dp(i,j) 表示等差数列最后的两个数字的位置。 转移的时候考虑先固定 jjj 的位置，然后分别向两边扫寻找满足 ai+ak=2⋅aja_i+a_k=2\\cdot a_jai​+ak​=2⋅aj​ 的数对 (i,k)(i,k)(i,k) ，并用 dp(i,j)+1dp(i,j)+1dp(i,j)+1 来更新 dp(j,k)dp(j,k)dp(j,k) 。 考虑到空间问题，需要使用 short int 。时间复杂度 O(n2)O(n^2)O(n2) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e4+5;int n,a[N];short int t,ans=2,dp[N][N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) dp[i][j]=2; for(int j=2;j&lt;n;j++) &#123; int i=j-1,k=j+1; while(i&gt;=1&amp;&amp;k&lt;=n) &#123; if(a[i]+a[k]&lt;2*a[j])k++; else if(a[i]+a[k]&gt;2*a[j])i--; else &#123; t=dp[i][j]+1; dp[j][k]=max(dp[j][k],t); ans=max(ans,t); i--;k++; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[],"tags":[{"name":"普通dp","slug":"普通dp","permalink":"http://yoursite.com/tags/普通dp/"}]},{"title":"「雅礼集训 2018-04-03」Problem B","slug":"yali0403b","date":"2018-05-25T04:41:10.000Z","updated":"2018-05-31T08:40:56.664Z","comments":true,"path":"yali0403b/","link":"","permalink":"http://yoursite.com/yali0403b/","excerpt":"求有多少 NNN 个的竞赛图包含至少一个长度为 KKK 的简单环, 输出答案模 109+710^9+7109+7 的结果。 竞赛图: 任意两个点之间都有一条有向边的图。 简单环: 不经过重复节点的回路。","text":"求有多少 NNN 个的竞赛图包含至少一个长度为 KKK 的简单环, 输出答案模 109+710^9+7109+7 的结果。 竞赛图: 任意两个点之间都有一条有向边的图。 简单环: 不经过重复节点的回路。 Constraints n≤5000n \\leq 5000n≤5000 Solution 首先有一个定理：竞赛图中如果包含一个大小大于等于 kkk 的强连通分量，则这个强连通分量内包含长度为 [3,k][3,k][3,k] 的简单环。则问题转化为：求至少有一个强连通分量大小大于等于 kkk 的方案数。 令 pip_{i}pi​ 表示 iii 个点的竞赛图方案数，则显然有 pi=2i⋅(i−1)2p_{i}=2^{\\frac{i\\cdot (i-1)}{2}}pi​=22i⋅(i−1)​ 。 令 gig_{i}gi​ 表示 iii 个点的强连通分量且为竞赛图的方案数，则显然有 gi=pi−∑j=1i−1(ij)⋅gj⋅pi−jg_{i}=p_{i}-\\sum _{j=1}^{i-1}\\binom{i}{j}\\cdot g_{j}\\cdot p_{i-j}gi​=pi​−∑j=1i−1​(ji​)⋅gj​⋅pi−j​ 。 令 fif_{i}fi​ 表示当前用了 iii 个点，不包含大小大于等于kkk的强连通分量的方案数。枚举最后一个强连通分量的大小进行转移，可得： fi=∑j=1min(k−1,i)(ij)⋅gj⋅fi−jf_{i}=\\sum _{j=1}^{min(k-1,i)}\\binom{i}{j}\\cdot g_{j}\\cdot f_{i-j} fi​=j=1∑min(k−1,i)​(ji​)⋅gj​⋅fi−j​ 则最终答案为 pn−fnp_{n}-f_{n}pn​−fn​ ，时间复杂度 O(n2)O(n^{2})O(n2) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e3+5;const int mod=1e9+7;int n,k,C[N][N],g[N],p[N],f[N];int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; freopen(\"b.in\",\"r\",stdin); freopen(\"b.out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;k); for(int i=0;i&lt;=n;i++)C[i][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; for(int i=1;i&lt;=n;i++)p[i]=power(2,i*(i-1)/2); g[1]=1; for(int i=3;i&lt;=n;i++) &#123; g[i]=p[i]; for(int j=1;j&lt;i;j++) g[i]=(g[i]-1ll*C[i][j]*g[j]%mod*p[i-j]%mod+mod)%mod; &#125; f[0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;k&amp;&amp;j&lt;=i;j++) f[i]=(f[i]+1ll*C[i][j]*g[j]%mod*f[i-j])%mod; printf(\"%d\",(p[n]-f[n]+mod)%mod); return 0;&#125;","categories":[],"tags":[{"name":"普通dp","slug":"普通dp","permalink":"http://yoursite.com/tags/普通dp/"},{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"「雅礼集训 2018-04-03」Problem C","slug":"yali0403c","date":"2018-05-25T04:35:52.000Z","updated":"2018-05-25T04:40:20.183Z","comments":true,"path":"yali0403c/","link":"","permalink":"http://yoursite.com/yali0403c/","excerpt":"给出一棵 NNN 个点的有根树，这棵树以 111 号节点为根。现在你需要对于每个非叶子节点 YYY 选择它的一个儿子 XXX ，并把连接 X,YX,YX,Y 的边标记为重边，其它的边为轻边。对于这棵树的每个叶子节点，把它到根节点经过的边依次写下来，一条轻边的代价为 111 ，一段连续的重边代价为 ⌊log2L+1⌋\\left \\lfloor log_2L+1 \\right \\rfloor⌊log2​L+1⌋ ，LLL 为这段重边的数量，这个叶子的代价等于这些代价之和。求出在最优情况下，所有叶子的代价中的最大值最小是多少。","text":"给出一棵 NNN 个点的有根树，这棵树以 111 号节点为根。现在你需要对于每个非叶子节点 YYY 选择它的一个儿子 XXX ，并把连接 X,YX,YX,Y 的边标记为重边，其它的边为轻边。对于这棵树的每个叶子节点，把它到根节点经过的边依次写下来，一条轻边的代价为 111 ，一段连续的重边代价为 ⌊log2L+1⌋\\left \\lfloor log_2L+1 \\right \\rfloor⌊log2​L+1⌋ ，LLL 为这段重边的数量，这个叶子的代价等于这些代价之和。求出在最优情况下，所有叶子的代价中的最大值最小是多少。 Constraints n≤2⋅105n \\leq 2\\cdot 10^5n≤2⋅105 Solution 记一下 O(n2)O(n^{2})O(n2) 的暴力……正解把复杂度优化到了 O(nlogn)O(nlogn)O(nlogn) ，至今仍然不是很理解。 令 gig_{i}gi​ 表示节点 iii 的子树里到 iii 代价最大的叶子节点的代价，每一次贪心的选择 gig_{i}gi​ 最大的儿子节点作为重儿子。 因为贡献不方便计算，令 f(i,k)f(i,k)f(i,k) 表示在节点 iii 有一条向上长度为 kkk 的重链时的答案，则可得： f(i,k)=max(f(heavy,k+1),g(light)+⌈log2k+1⌉+1)f(i,k)=max(f(heavy,k+1),g(light)+\\lceil log_{2}k+1\\rceil +1) f(i,k)=max(f(heavy,k+1),g(light)+⌈log2​k+1⌉+1) 下面的是正解的代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int T,n,x,y,cnt;int first[N],g[N],f[N][20];struct edge&#123;int to,next;&#125;e[N&lt;&lt;1];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x,int fa)&#123; int mx=-inf,elmx=-inf,son=0; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs(to,x); if(g[to]&gt;mx)elmx=mx,mx=g[to],son=to; else if(g[to]&gt;elmx)elmx=g[to]; &#125; if(mx&lt;0) &#123; g[x]=0;f[x][0]=0; for(int i=1;i&lt;18;i++)f[x][i]=1&lt;&lt;(i-1); return; &#125; elmx++; if(f[son][0])g[x]=mx;else g[x]=mx+1; g[x]=max(g[x],elmx); for(int i=0;i&lt;18;i++) &#123; int v=g[x]+i; if(v==elmx)f[x][i]=0; else f[x][i]=1&lt;&lt;min(20,v-elmx-1); if(v-mx&lt;18)f[x][i]=min(f[x][i],f[son][v-mx]-1); &#125;&#125;void work()&#123; cnt=0;memset(first,0,sizeof(first)); n=read(); for(int i=1;i&lt;n;i++) x=read(),y=read(),ins(x,y),ins(y,x); dfs(1,0);printf(\"%d\\n\",g[1]);&#125;int main()&#123; T=read(); while(T--)work(); return 0;&#125;","categories":[],"tags":[{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"}]},{"title":"「雅礼集训 2018-04-02」Problem A","slug":"yali0402a","date":"2018-05-25T04:27:53.000Z","updated":"2018-05-25T04:34:58.429Z","comments":true,"path":"yali0402a/","link":"","permalink":"http://yoursite.com/yali0402a/","excerpt":"有一个长为 NNN 的数列 AAA ，有 QQQ 个操作: 1 L R X1 \\ \\ L \\ \\ R \\ \\ X1 L R X 对于 L≤i≤RL\\leq i\\leq RL≤i≤R ，把 AiA_iAi​ 变成 Ai∧XA_i \\wedge XAi​∧X 。 2 L R X2 \\ \\ L \\ \\ R \\ \\ X2 L R X 对于 L≤i≤RL\\leq i\\leq RL≤i≤R ，把 AiA_iAi​ 变成 Ai∨XA_i \\vee XAi​∨X 。 3 L R3 \\ \\ L \\ \\ R3 L R 求 AL,AL+1,⋯,ARA_L,A_{L+1},\\cdots ,A_RAL​,AL+1​,⋯,AR​ 中的最大值。 其中 $\\wedge $ 为按位与 ，$ \\vee $为按位或。","text":"有一个长为 NNN 的数列 AAA ，有 QQQ 个操作: 1 L R X1 \\ \\ L \\ \\ R \\ \\ X1 L R X 对于 L≤i≤RL\\leq i\\leq RL≤i≤R ，把 AiA_iAi​ 变成 Ai∧XA_i \\wedge XAi​∧X 。 2 L R X2 \\ \\ L \\ \\ R \\ \\ X2 L R X 对于 L≤i≤RL\\leq i\\leq RL≤i≤R ，把 AiA_iAi​ 变成 Ai∨XA_i \\vee XAi​∨X 。 3 L R3 \\ \\ L \\ \\ R3 L R 求 AL,AL+1,⋯,ARA_L,A_{L+1},\\cdots ,A_RAL​,AL+1​,⋯,AR​ 中的最大值。 其中 $\\wedge $ 为按位与 ，$ \\vee $为按位或。 Constraints N,Q≤2⋅105N,Q \\leq 2\\cdot 10^5N,Q≤2⋅105 ， 0≤A&lt;2200 \\leq A &lt; 2^{20}0≤A&lt;220 Solution 按位与和按位或操作会把对一些数位执行区间赋值操作，所以如果区间内的数这些数位上的数相同，则可以直接打上标记，否则需要递归访问额外节点。过程中需记录区间内数字的与、或和最大值，以方便判断数位是否相同。 下传标记时先与后或。 复杂度 O(20nlogn)O(20nlogn)O(20nlogn)（其实主要问题在复杂度分析）。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define l(x) x&lt;&lt;1#define r(x) x&lt;&lt;1|1#define LL long longusing namespace std;const int N=2e5+5;int n,m,op,L,R,v,S=(1&lt;&lt;20)-1;int vor[N*4],vand[N*4],vmx[N*4],tor[N*4],tand[N*4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void mand(int x,int v)&#123; tand[x]&amp;=v;tor[x]&amp;=v; vand[x]&amp;=v;vor[x]&amp;=v;vmx[x]&amp;=v;&#125;void mor(int x,int v)&#123; tor[x]|=v; vand[x]|=v;vor[x]|=v;vmx[x]|=v;&#125;void up(int x)&#123; vand[x]=vand[l(x)]&amp;vand[r(x)]; vor[x]=vor[l(x)]|vor[r(x)]; vmx[x]=max(vmx[l(x)],vmx[r(x)]);&#125;void dn(int x)&#123; if(tand[x]!=S) &#123; mand(l(x),tand[x]); mand(r(x),tand[x]); tand[x]=S; &#125; if(tor[x]!=0) &#123; mor(l(x),tor[x]); mor(r(x),tor[x]); tor[x]=0; &#125;&#125;void build(int x,int l,int r)&#123; tand[x]=S; if(l==r)&#123;vor[x]=vand[x]=vmx[x]=read();return;&#125; int mid=(l+r)&gt;&gt;1; build(l(x),l,mid); build(r(x),mid+1,r); up(x);&#125;void modify(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; if(op==1&amp;&amp;((v^S)&amp;(vand[x]|(vor[x]^S)))==(v^S))&#123;mand(x,v);return;&#125; if(op==2&amp;&amp;(v&amp;(vand[x]|(vor[x]^S)))==v)&#123;mor(x,v);return;&#125; &#125; dn(x);int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(l(x),l,mid); if(R&gt;mid)modify(r(x),mid+1,r); up(x);&#125;int query(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return vmx[x]; dn(x);int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans=max(ans,query(l(x),l,mid)); if(R&gt;mid)ans=max(ans,query(r(x),mid+1,r)); return ans;&#125;int main()&#123; n=read();m=read(); build(1,1,n); while(m--) &#123; op=read();L=read();R=read(); if(op==3)printf(\"%d\\n\",query(1,1,n)); else v=read(),modify(1,1,n); &#125; return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"「雅礼集训 2018-04-02」Problem B","slug":"yali0402b","date":"2018-05-25T04:19:09.000Z","updated":"2018-05-25T04:27:40.098Z","comments":true,"path":"yali0402b/","link":"","permalink":"http://yoursite.com/yali0402b/","excerpt":"有一个长宽均为 NNN 的网格，每个格子的长宽均为 111。除了最左下角的网格外，其他格子中均有一个半径为 RRR 的圆，圆心在格子的正中心。现在你站在最左下角的格子的正中心，求你能够看到多少个圆，视线不能够穿过圆。 输入一行包含两个整数 NNN ，R0R_0R0​ ，题目中的 RRR 为R0106\\frac{R_0}{10^6}106R0​​ 。","text":"有一个长宽均为 NNN 的网格，每个格子的长宽均为 111。除了最左下角的网格外，其他格子中均有一个半径为 RRR 的圆，圆心在格子的正中心。现在你站在最左下角的格子的正中心，求你能够看到多少个圆，视线不能够穿过圆。 输入一行包含两个整数 NNN ，R0R_0R0​ ，题目中的 RRR 为R0106\\frac{R_0}{10^6}106R0​​ 。 Constraints $ n \\leq 10^9$ ， R0≤106R_0 \\leq 10^6R0​≤106 Solution 首先可以确定一个结论：只有能够看到圆心才能够看到这个圆。 枚举圆 (x,y)(x,y)(x,y) 和圆 (a,b)(a,b)(a,b) ，根据点到直线的距离公式 ∣Ax0+By0+CA2+B2∣\\begin{vmatrix} \\frac{Ax_{0}+By_{0}+C}{\\sqrt{A^{2}+B^{2}}} \\end{vmatrix}∣∣∣​A2+B2​Ax0​+By0​+C​​∣∣∣​ ，可得若 (a,b)(a,b)(a,b) 挡住了 (x,y)(x,y)(x,y) ，则 (ay−bx)2x2+y2≤R2\\frac{(ay-bx)^{2}}{x^{2}+y^{2}}\\leq R^{2}x2+y2(ay−bx)2​≤R2 。 只考虑 x,yx,yx,y 互质的情况，那么一定存在 a&lt;xa&lt;xa&lt;x ， b&lt;yb&lt;yb&lt;y ， ∣ay−bx∣=1|ay-bx|=1∣ay−bx∣=1 ，这时候只要满足 x2+y2&lt;1R2x^{2}+y^{2}&lt; \\frac{1}{R^{2}}x2+y2&lt;R21​ 就不会被挡住。 所以令 r=1Rr=\\frac{1}{R}r=R1​ ，枚举约数 ddd ，得出： ∑d=1min(n,r)μ(d)∑x=1⌊rd⌋∑y=1⌊rd⌋[x2+y2&lt;r2d2]\\sum _{d=1}^{min(n,r)}\\mu(d)\\sum _{x=1}^{\\lfloor \\frac{r}{d} \\rfloor}\\sum _{y=1}^{\\lfloor \\frac{r}{d} \\rfloor}[x^{2}+y^{2}&lt;\\frac{r^{2}}{d^{2}}] d=1∑min(n,r)​μ(d)x=1∑⌊dr​⌋​y=1∑⌊dr​⌋​[x2+y2&lt;d2r2​] 具体计算方式见代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int N=1e6+5;int n,r,tot,pri[N],miu[N];LL ans;bool np[N];LL calc(LL lim,LL n)&#123; LL y=sqrt(lim)+1,sum=0; y=min(y,n); for(LL x=1;x*x&lt;lim&amp;&amp;x&lt;=n;x++) &#123; while(y&amp;&amp;x*x+y*y&gt;lim)y--; sum+=y; &#125; return sum;&#125;int main()&#123; miu[1]=1; for(int i=2;i&lt;=1e6;i++) &#123; if(!np[i])&#123;miu[i]=-1;pri[++tot]=i;&#125; for(int j=1;i*pri[j]&lt;=1e6;j++) &#123; int now=i*pri[j]; np[now]=true; if(i%pri[j]==0)&#123;miu[now]=0;break;&#125; miu[now]=-miu[i]; &#125; &#125; scanf(\"%d%d\",&amp;n,&amp;r); LL lim=1ll*999999999999/r/r; for(LL g=1;g*g&lt;=lim;g++) ans+=miu[g]*calc(lim/g/g,(n-1)/g); printf(\"%lld\",ans+2); return 0;&#125;","categories":[],"tags":[{"name":"容斥原理","slug":"容斥原理","permalink":"http://yoursite.com/tags/容斥原理/"},{"name":"计算几何","slug":"计算几何","permalink":"http://yoursite.com/tags/计算几何/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://yoursite.com/tags/莫比乌斯反演/"}]},{"title":"「雅礼集训 2018-04-02」Problem C","slug":"yali0402c","date":"2018-05-25T04:13:13.000Z","updated":"2018-05-25T04:18:51.064Z","comments":true,"path":"yali0402c/","link":"","permalink":"http://yoursite.com/yali0402c/","excerpt":"Alice 和 Bob 在玩游戏。 有一棵 NNN 个节点的树， Alice 和 Bob 轮流操作，Alice 先手。 一开始树上所有节点都没有颜色，Alice 每次会选一个没有被染色的节点并把这个节点染成红色(不能不选)，Bob 每次会选一个没有被染色的节点并把这个节点染成蓝色(不能不选)。当有人操作不了时，游戏就终止了。 Alice 的最终得分为红色连通块的个数，Bob 的最终的分为蓝色连通块的个数。设 Alice 的得分为 KAK_AKA​ ，Bob 的得分为 KBK_BKB​，Alice 想让 KA−KBK_A-K_BKA​−KB​ 尽可能大，Bob 则想让 KA−KBK_A-K_BKA​−KB​ 尽可能小，假设两人都采取最优策略操作，那么 KA−KBK_A-K_BKA​−KB​ 会是多少。 这里指的连通块为一个点集 SSS，满足集合内点的颜色相同，且每个点都能只经过 SSS 内的点走到 SSS 内的其他点，而且如果将任意 u(u⊈S)u(u\\nsubseteq S)u(u⊈S) 加入 SSS ，那么上述性质将不能被满足。","text":"Alice 和 Bob 在玩游戏。 有一棵 NNN 个节点的树， Alice 和 Bob 轮流操作，Alice 先手。 一开始树上所有节点都没有颜色，Alice 每次会选一个没有被染色的节点并把这个节点染成红色(不能不选)，Bob 每次会选一个没有被染色的节点并把这个节点染成蓝色(不能不选)。当有人操作不了时，游戏就终止了。 Alice 的最终得分为红色连通块的个数，Bob 的最终的分为蓝色连通块的个数。设 Alice 的得分为 KAK_AKA​ ，Bob 的得分为 KBK_BKB​，Alice 想让 KA−KBK_A-K_BKA​−KB​ 尽可能大，Bob 则想让 KA−KBK_A-K_BKA​−KB​ 尽可能小，假设两人都采取最优策略操作，那么 KA−KBK_A-K_BKA​−KB​ 会是多少。 这里指的连通块为一个点集 SSS，满足集合内点的颜色相同，且每个点都能只经过 SSS 内的点走到 SSS 内的其他点，而且如果将任意 u(u⊈S)u(u\\nsubseteq S)u(u⊈S) 加入 SSS ，那么上述性质将不能被满足。 Constraints $ n \\leq 10^5 $ Solution 显然，KAK_{A}KA​ 等于红色点数减去两端都为红色的边的数量，KBK_{B}KB​ 同理。两种颜色点数是确定的，问题转化为求两边同色的边数之差。对于一条边，将两个端点的点权 +1+1+1 ，若被 Alice 选择则将答案减去点权，否则加上点权。贪心可得，Alice 和 Bob 都会选择点权最小的结点。贪心计算出来的数字即为 ans⋅2ans\\cdot 2ans⋅2 。 Code 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,ans,u,v,deg[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read();ans=(n&amp;1)*2; for(int i=1;i&lt;n;i++) &#123; u=read();v=read(); deg[u]++;deg[v]++; &#125; sort(deg+1,deg+n+1); for(int i=1;i&lt;=n;i++) &#123; if(i&amp;1)ans-=deg[i]; else ans+=deg[i]; &#125; printf(\"%d\",ans/2); return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"「雅礼集训 2018-03-31」Max","slug":"yali0331a","date":"2018-05-25T04:04:15.000Z","updated":"2018-05-25T04:11:55.843Z","comments":true,"path":"yali0331a/","link":"","permalink":"http://yoursite.com/yali0331a/","excerpt":"一个长为 nnn 的序列 AAA，从 111 开始标号，一开始全为 000，现在小 C 想对它进行 mmm 次操作。对第 iii 次操作，他会选定恰好一个二元组 (j,k)(j,k)(j,k)（1≤j≤n,0≤k≤c1\\leq j\\leq n,0\\leq k\\leq c1≤j≤n,0≤k≤c）并令 Aj=Aj+kA_j=A_j+kAj​=Aj​+k，其中选中二元组 (j,k)(j,k)(j,k) 的概率为 Pi,j,kP_{i,j,k}Pi,j,k​。小 C 本来是想问你区间最大值的历史版本和的历史最大值的期望的，但鉴于这是一道签到题，现在他只想知道 mmm 次操作后整个序列最大值的期望，对 109+710^9+7109+7 取模。","text":"一个长为 nnn 的序列 AAA，从 111 开始标号，一开始全为 000，现在小 C 想对它进行 mmm 次操作。对第 iii 次操作，他会选定恰好一个二元组 (j,k)(j,k)(j,k)（1≤j≤n,0≤k≤c1\\leq j\\leq n,0\\leq k\\leq c1≤j≤n,0≤k≤c）并令 Aj=Aj+kA_j=A_j+kAj​=Aj​+k，其中选中二元组 (j,k)(j,k)(j,k) 的概率为 Pi,j,kP_{i,j,k}Pi,j,k​。小 C 本来是想问你区间最大值的历史版本和的历史最大值的期望的，但鉴于这是一道签到题，现在他只想知道 mmm 次操作后整个序列最大值的期望，对 109+710^9+7109+7 取模。 Constraints n≤40n \\leq 40n≤40 ， m≤10m \\leq 10m≤10 ， c≤3c \\leq 3c≤3 Solution 令 f(i,S,j)f(i,S,j)f(i,S,j) 表示 AiA_{i}Ai​ 在经过集合 SSS 的操作后，值为 jjj 的概率。 令 dp(i,S,j)dp(i,S,j)dp(i,S,j) 表示前 iii 个元素，用掉了集合 SSS 的操作，最大值为 jjj 的概率，可得： dp(i,S1,j)×f(i+1,S2,k)=dp(i+1,S1+S2,max(j,k))dp(i,S_{1},j)\\times f(i+1,S_{2},k)=dp(i+1,S_{1}+S_{2},max(j,k)) dp(i,S1​,j)×f(i+1,S2​,k)=dp(i+1,S1​+S2​,max(j,k)) 详见代码。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=41;const int M=11;const int T=1&lt;&lt;10;const int mod=1e9+7;int n,m,c,S,x,y,val,ans;int p[N][M][4],f[T][M*3],dp[N][T][M*3];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int &amp;x,LL val)&#123;x=(x+val)%mod;&#125;int main()&#123; n=read();m=read();c=read();S=(1&lt;&lt;m)-1; for(int j=0;j&lt;m;j++) for(int i=1;i&lt;=n;i++) for(int k=0;k&lt;=c;k++) p[i][j][k]=read(); dp[0][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; memset(f,0,sizeof(f)); f[0][0]=1; for(int s=0;s&lt;=S;s++) &#123; x=__builtin_popcount(s); for(int j=0;j&lt;m;j++) &#123; if((1&lt;&lt;j)&amp;s)break; for(int k=0;k&lt;=c*x;k++) for(int d=0;d&lt;=c;d++) Mod(f[s|(1&lt;&lt;j)][k+d],1ll*f[s][k]*p[i][j][d]); &#125; &#125; for(int s=0;s&lt;=S;s++) &#123; x=__builtin_popcount(s); for(int k=0;k&lt;=c*x;k++) &#123; val=dp[i-1][s][k]; if(!val)continue; for(int j=s^S;;j=(j-1)&amp;(s^S)) &#123; y=__builtin_popcount(j); for(int d=0;d&lt;=c*y;d++) Mod(dp[i][s^j][max(k,d)],1ll*val*f[j][d]); if(!j)break; &#125; &#125; &#125; &#125; for(int i=0;i&lt;=c*m;i++) ans=(ans+1ll*i*dp[n][S][i])%mod; printf(\"%d\",ans); return 0;&#125;","categories":[],"tags":[{"name":"状压dp","slug":"状压dp","permalink":"http://yoursite.com/tags/状压dp/"}]},{"title":"「雅礼集训 2018-03-27」Subset","slug":"yali0327b","date":"2018-05-24T23:41:15.000Z","updated":"2018-05-25T04:06:06.999Z","comments":true,"path":"yali0327b/","link":"","permalink":"http://yoursite.com/yali0327b/","excerpt":"给你三个 111 到 nnn 的排列 aia_iai​，bib_ibi​，cic_ici​。 称三元组 (x,y,z)(x,y,z)(x,y,z) 是合法的，当且仅当存在一个下标集合 SSS 满足 (x,y,z)=(max ai,max bi,max ci)(x,y,z)=(max \\ \\ a_i,max \\ \\ b_i,max \\ \\ c_i)(x,y,z)=(max ai​,max bi​,max ci​) (i⊆S)(i\\subseteq S)(i⊆S) 询问合法三元组的数量。","text":"给你三个 111 到 nnn 的排列 aia_iai​，bib_ibi​，cic_ici​。 称三元组 (x,y,z)(x,y,z)(x,y,z) 是合法的，当且仅当存在一个下标集合 SSS 满足 (x,y,z)=(max ai,max bi,max ci)(x,y,z)=(max \\ \\ a_i,max \\ \\ b_i,max \\ \\ c_i)(x,y,z)=(max ai​,max bi​,max ci​) (i⊆S)(i\\subseteq S)(i⊆S) 询问合法三元组的数量。 Constraints $ n \\leq 10^5 $ Solution 对于每一个合法三元组对应的 SSS ，只保留对三元组有贡献的下标，可以得到 ∣S∣≤3|S|\\leq 3∣S∣≤3 ，且与合法三元组一一对应。问题转化为统计 SSS 的数量。 当 ∣S∣=1|S|=1∣S∣=1 时，所有下标集合都是合法的。 当 ∣S∣=2|S|=2∣S∣=2 时，可以用总的下标集合数 −-− 非法下标集合数（即其中一个在 a,b,ca,b,ca,b,c 里都比另一个大）来统计，这一步可以用 cdq 分治来完成。 当 ∣S∣=3|S|=3∣S∣=3 时，同样考虑非法下标集合数。分为几种情况进行讨论： 1.1.1. 存在一个下标在 a,b,ca,b,ca,b,c 中都是最大的，同样可以用 cdq 分治来完成，记为 AAA 。 2.2.2. 一个下标在 a,b,ca,b,ca,b,c 中的两个最大，另一个下标在 a,b,ca,b,ca,b,c 中的一个最大。考虑枚举 a,b,ca,b,ca,b,c 中的两个，计算有多少个下标集合满足其中一个在对应枚举的排列里是最大的，计总和为 BBB 。可以注意到， BBB 中还包含着不合法的 3⋅A3\\cdot A3⋅A 种情况，所以实际上 B=B−3⋅AB=B-3\\cdot AB=B−3⋅A 。 最后 (n−2)⋅(n−1)⋅n−A−B(n-2)\\cdot (n-1)\\cdot n-A-B(n−2)⋅(n−1)⋅n−A−B 即可得到 ∣S∣=3|S|=3∣S∣=3 时的下标集合数。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,temp,t[N],mn[N];LL A,B,C,ans; struct node&#123;int a,b,c;&#125;a[N],tmp[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.a&lt;b.a;&#125;bool cmp2(node a,node b)&#123;return a.b&lt;b.b;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int val)&#123;while(x&lt;=n)t[x]+=val,x+=lowbit(x);&#125;int query(int x)&#123;int ans=0;while(x)ans+=t[x],x-=lowbit(x);return ans;&#125;void cdq(int l,int r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; for(int i=l;i&lt;=r;i++) if(a[i].c&lt;=mid)add(a[i].b,1); else mn[a[i].a]+=query(a[i].b); int t1=l,t2=mid+1; for(int i=l;i&lt;=r;i++) if(a[i].c&lt;=mid)add(a[i].b,-1),tmp[t1++]=a[i]; else tmp[t2++]=a[i]; for(int i=l;i&lt;=r;i++)a[i]=tmp[i]; cdq(l,mid);cdq(mid+1,r);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i].a=read(); for(int i=1;i&lt;=n;i++)a[i].b=read(); for(int i=1;i&lt;=n;i++)a[i].c=read(); sort(a+1,a+n+1,cmp);cdq(1,n); for(int i=1;i&lt;=n;i++) A+=1ll*mn[i]*(mn[i]-1)/2,C+=mn[i]; sort(a+1,a+n+1,cmp); memset(t,0,sizeof(t)); for(int i=1;i&lt;=n;i++) &#123; temp=query(a[i].b); B+=1ll*temp*(temp-1)/2; add(a[i].b,1); &#125; memset(t,0,sizeof(t)); for(int i=1;i&lt;=n;i++) &#123; temp=query(a[i].c); B+=1ll*temp*(temp-1)/2; add(a[i].c,1); &#125; sort(a+1,a+n+1,cmp2); memset(t,0,sizeof(t)); for(int i=1;i&lt;=n;i++) &#123; temp=query(a[i].c); B+=1ll*temp*(temp-1)/2; add(a[i].c,1); &#125; ans=1ll*(n-2)*(n-1)*n/6-(B-A*2); ans+=1ll*n*(n-1)/2-C; printf(\"%lld\",ans+n); return 0;&#125;","categories":[],"tags":[{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/分治/"},{"name":"cdq分治","slug":"cdq分治","permalink":"http://yoursite.com/tags/cdq分治/"}]},{"title":"「雅礼集训 2018-03-25」cti","slug":"yali0325c","date":"2018-05-24T23:34:01.000Z","updated":"2018-05-24T23:39:14.423Z","comments":true,"path":"yali0325c/","link":"","permalink":"http://yoursite.com/yali0325c/","excerpt":"有一个n×mn\\times mn×m 的地图，地图上的每一个位置可以是空地，炮塔或是敌人。你需要操纵炮塔消灭敌人。 对于每个炮塔都有一个它可以瞄准的方向，你需要在它的瞄准方向上确定一个它的攻击位置，当然也可以不进行攻击。 一旦一个位置被攻击，则在这个位置上的所有敌人都会被消灭。保证对于任意一个炮塔，它所有可能的攻击位置上不存在另外一个炮塔。定义炮弹的运行轨迹为炮弹的起点和终点覆盖的区域。你需要求出一种方案，使得在没有两条炮弹轨迹相交的前提下，最大化消灭敌人的数量。","text":"有一个n×mn\\times mn×m 的地图，地图上的每一个位置可以是空地，炮塔或是敌人。你需要操纵炮塔消灭敌人。 对于每个炮塔都有一个它可以瞄准的方向，你需要在它的瞄准方向上确定一个它的攻击位置，当然也可以不进行攻击。 一旦一个位置被攻击，则在这个位置上的所有敌人都会被消灭。保证对于任意一个炮塔，它所有可能的攻击位置上不存在另外一个炮塔。定义炮弹的运行轨迹为炮弹的起点和终点覆盖的区域。你需要求出一种方案，使得在没有两条炮弹轨迹相交的前提下，最大化消灭敌人的数量。 Constraints $ 1 \\leq n,m \\leq 50 $ Solution 考虑对于每一个炮塔，将它们可以攻击的位置连成一条链。对于不能相交的限制，可以参考【bzoj3144】[Hnoi2013]切糕。 具体建图方式为：先将横着的链建好，再反着建竖着的链，最后在每一个相交点间连一条无穷大的边。 原理画图易得。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=55;const int M=2e5+5;const int inf=0x3f3f3f3f;int n,m,cnt=1,S,T,tot,ans,all;int first[M],cur[M],map[N][N];int q[M],dis[M];int id[N][N],ord[N][N],chain[255][N];struct edge&#123;int to,next,flow;&#125;e[M*4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v,int w)&#123; e[++cnt]=(edge)&#123;v,first[u],w&#125;;first[u]=cnt; e[++cnt]=(edge)&#123;u,first[v],0&#125;;first[v]=cnt;&#125;bool bfs()&#123; memset(dis,-1,sizeof(dis)); int head=0,tail=1;q[0]=S;dis[S]=0; while(head!=tail) &#123; int u=q[head++]; for(int i=first[u];i;i=e[i].next) &#123; int to=e[i].to; if(dis[to]!=-1||!e[i].flow)continue; dis[to]=dis[u]+1; q[tail++]=to; &#125; &#125; return dis[T]!=-1;&#125;int dfs(int u,int a)&#123; if(u==T||a==0)return a; int f,flow=0; for(int&amp; i=cur[u];i;i=e[i].next) &#123; int to=e[i].to; if(dis[to]==dis[u]+1&amp;&amp;(f=dfs(to,min(e[i].flow,a)))&gt;0) &#123; e[i].flow-=f;e[i^1].flow+=f; flow+=f;a-=f;if(a==0)break; &#125; &#125; return flow;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) map[i][j]=read(); S=++tot;T=++tot; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(map[i][j]==-1) &#123; ins(++tot,T,1000);ans+=1000; int ccnt=0,tid=++all; chain[tid][++ccnt]=tot; for(int k=i-1;k&gt;=1;k--) &#123; chain[tid][++ccnt]=++tot; ins(tot,chain[tid][ccnt-1],1000-map[k][j]); id[k][j]=tid;ord[k][j]=ccnt-1; &#125; ins(S,tot,inf); &#125; else if(map[i][j]==-2) &#123; ins(++tot,T,1000);ans+=1000; int ccnt=0,tid=++all; chain[tid][++ccnt]=tot; for(int k=i+1;k&lt;=n;k++) &#123; chain[tid][++ccnt]=++tot; ins(tot,chain[tid][ccnt-1],1000-map[k][j]); id[k][j]=tid;ord[k][j]=ccnt-1; &#125; ins(S,tot,inf); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(map[i][j]==-3) &#123; ins(S,++tot,1000);ans+=1000; int last=tot; for(int k=j-1;k&gt;=1;k--) &#123; ins(last,++tot,1000-map[i][k]); if(id[i][k])ins(last,chain[id[i][k]][ord[i][k]],inf); last=tot; &#125; ins(tot,T,inf); &#125; else if(map[i][j]==-4) &#123; ins(S,++tot,1000);ans+=1000; int last=tot; for(int k=j+1;k&lt;=m;k++) &#123; ins(last,++tot,1000-map[i][k]); if(id[i][k])ins(last,chain[id[i][k]][ord[i][k]],inf); last=tot; &#125; ins(tot,T,inf); &#125; while(bfs()) &#123; for(int i=1;i&lt;=tot;i++)cur[i]=first[i]; ans-=dfs(S,inf); &#125; printf(\"%d\",ans); return 0;&#125;","categories":[],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://yoursite.com/tags/网络流/"}]},{"title":"「51nod 1273」旅行计划","slug":"51nod1273","date":"2018-05-24T23:17:38.000Z","updated":"2018-05-24T23:30:37.570Z","comments":true,"path":"51nod1273/","link":"","permalink":"http://yoursite.com/51nod1273/","excerpt":"某个国家有 NNN 个城市，编号 000 至 N−1N-1N−1 ，他们之间用 N−1N-1N−1 条道路连接，道路是双向行驶的，沿着道路你可以到达任何一个城市。你有一个旅行计划，这个计划是从编号 KKK 的城市出发，每天到达一个你没有去过的城市，并且旅途中经过的没有去过的城市尽可能的多（如果有 222 条路线，经过的没有去过的城市同样多，优先考虑编号最小的城市），直到所有城市都观光过一遍。现在给出城市之间的交通图 TTT ，以及出发地点 KKK ，你来设计一个旅行计划，满足上面的条件。","text":"某个国家有 NNN 个城市，编号 000 至 N−1N-1N−1 ，他们之间用 N−1N-1N−1 条道路连接，道路是双向行驶的，沿着道路你可以到达任何一个城市。你有一个旅行计划，这个计划是从编号 KKK 的城市出发，每天到达一个你没有去过的城市，并且旅途中经过的没有去过的城市尽可能的多（如果有 222 条路线，经过的没有去过的城市同样多，优先考虑编号最小的城市），直到所有城市都观光过一遍。现在给出城市之间的交通图 TTT ，以及出发地点 KKK ，你来设计一个旅行计划，满足上面的条件。 Constraints 1≤N≤500001 \\leq N \\leq 500001≤N≤50000 Solution 观察易得结论：每天的目的地必然是叶子节点，每天访问的路径一定是从叶子到根节点路径上的一段。 即据题意可以进行树上贪心，依据叶子节点的深度和编号大小进行排序后，按顺序从每个叶子往根走直到走到根节点或已访问过的节点，并进行统计。得到所有结果后再排序输出即可。 所以问题可以转化为：令每个叶子分别支配一条链，使得标号小的点尽量支配多的点，最后根据支配的点数多少、标号大小依次访问。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e4+5;int n,root,cnt,x,tot,ans;int first[N];bool vis[N];struct edge&#123;int to,next;&#125;e[N*2];struct node&#123;int id,deep;&#125;a[N],b[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.deep==b.deep?a.id&lt;b.id:a.deep&gt;b.deep;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x,int fa,int deep)&#123; bool f=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; f=false;dfs(to,x,deep+1); &#125; if(f&amp;&amp;x!=root)a[++tot]=(node)&#123;x,deep&#125;;&#125;bool solve(int x,int fa)&#123; if(vis[x]||x==root)return true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; if(solve(to,x)) &#123; ans++;vis[x]=true; return true; &#125; &#125;&#125;int main()&#123; n=read();root=read(); for(int i=1;i&lt;n;i++)x=read(),ins(i,x),ins(x,i); dfs(root,-1,0);sort(a+1,a+tot+1,cmp); for(int i=1;i&lt;=tot;i++) &#123; ans=0;solve(a[i].id,-1); b[i]=(node)&#123;a[i].id,ans&#125;; &#125; sort(b+1,b+tot+1,cmp); printf(\"%d\\n\",root); for(int i=1;i&lt;=tot;i++)printf(\"%d\\n\",b[i].id); return 0;&#125;","categories":[],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"「51nod 1907」小C的游戏","slug":"51nod1907","date":"2018-05-24T13:01:18.000Z","updated":"2018-05-24T13:51:03.782Z","comments":true,"path":"51nod1907/","link":"","permalink":"http://yoursite.com/51nod1907/","excerpt":"小 C 在无向图上玩这样一个游戏。 小 C 可以任选一点作为起点。每次他可以进行两种操作： 移动到一个相邻的结点。 使用一次魔法，移动到图中任意一个结点。 当他访问图中每个结点至少 111 次时，游戏结束。注意他必须使用不超过 n−1n-1n−1 次魔法。 游戏结束时，如果他使用了 kkk 次魔法，则他本轮游戏的花费为 aka_kak​ 。 现有一个 nnn 个点 mmm 条边的无向连通图 GGG 。图 GGG 中任意一条边至多属于一个环。 小 C 希望知道，在图 GGG 的所有生成子图进行上述游戏所需花费的最小值之和。 由于答案可能很大，将答案对 998244353998244353998244353 取模。","text":"小 C 在无向图上玩这样一个游戏。 小 C 可以任选一点作为起点。每次他可以进行两种操作： 移动到一个相邻的结点。 使用一次魔法，移动到图中任意一个结点。 当他访问图中每个结点至少 111 次时，游戏结束。注意他必须使用不超过 n−1n-1n−1 次魔法。 游戏结束时，如果他使用了 kkk 次魔法，则他本轮游戏的花费为 aka_kak​ 。 现有一个 nnn 个点 mmm 条边的无向连通图 GGG 。图 GGG 中任意一条边至多属于一个环。 小 C 希望知道，在图 GGG 的所有生成子图进行上述游戏所需花费的最小值之和。 由于答案可能很大，将答案对 998244353998244353998244353 取模。 Constraints 1≤n≤300001 \\leq n \\leq 300001≤n≤30000 ， n−1≤m≤2n−2n-1 \\leq m \\leq 2n-2n−1≤m≤2n−2 ， 0≤ai≤1090 \\leq a_i \\leq 10^90≤ai​≤109 可能有重边，但不会有自环。 图 G′(V′,E′)G&#x27;(V&#x27;,E&#x27;)G′(V′,E′) 是图 G(V,E)G(V,E)G(V,E) 的生成子图当且仅当 V′=V,E′⊆EV&#x27; = V , E&#x27; \\subseteq EV′=V,E′⊆E 。 简单环定义为一个顶点序列 v1,v2,⋯,vm(m≥2)v_1, v_2, \\cdots , v_m (m \\ge 2)v1​,v2​,⋯,vm​(m≥2) ，其中 viv_ivi​ 与 vi+1v_{i+1}vi+1​ 相邻， v1v_1v1​ 与 vmv_mvm​ 相邻，且 viv_ivi​ 互不相同。 Solution 首先可以确定，在一个连通块内部移动不需要魔法，即只有跨越连通块使用的魔法是必要的，即最少魔法使用次数为连通块个数 −1-1−1 。问题转换为，求出连通块个数为 iii 的生成子图的方案数。 据题意，给出的图是仙人掌图，可以被分解为若干树边和环。我们将环和树边分开考虑，并构造出对应的生成函数，xix^ixi 表示当前部分贡献 iii 个连通块的方案数，最后将得到的所有多项式相乘即可。 1.1.1. 对于一条树边，删去即贡献 111 个连通块，保留则无贡献，即 f(x)=x+1f(x)=x+1f(x)=x+1 。 2.2.2. 对于一个包含n条边的环，在删去第一条边时无贡献，从第二条边开始每删去一条边对连通块数量贡献 +1+1+1 ，即 f(x)=∑i=0n−1(ni+1)xi+1f(x)=\\sum_{i=0}^{n-1}\\binom{n}{i+1}x^i+1f(x)=∑i=0n−1​(i+1n​)xi+1 。 在多项式相乘时使用启发式合并，保证时间复杂度为 O(nlog2n)O(nlog^2n)O(nlog2n) 。 在最后统计答案时，由于 aaa 序列不一定单调递增，一个连通块个数为 iii 的生成子图的实际最小代价为后缀最小值。且因为初始连通块个数为 111 ，最终 xix^ixi 的系数实际代表的是包含 i+1i+1i+1 个连通块的生成子图的方案数。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;queue&gt;#define LL long longusing namespace std;const int N=131072+5;const int mod=998244353;int n,m,x,y,cnt,tot,sum,*cur;int nn,al,bl,*acur,*bcur;int first[N],val[N],fac[N],fav[N],bel[N];int hx[N],hy[N],fa[N],deep[N];int length[N],o[10000005];int a[N],b[N];struct edge&#123;int to,next;&#125;e[N*2];struct node&#123; int n,*cur; bool operator &lt; (const node&amp; a)const&#123;return n&gt;a.n;&#125;&#125;aa,bb;priority_queue&lt;node&gt; q;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int min(int a,int b)&#123;return a&lt;b?a:b;&#125;int C(int n,int m)&#123;return 1ll*fac[n]*fav[m]%mod*fav[n-m]%mod;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int find(int t)&#123;return t==bel[t]?t:bel[t]=find(bel[t]);&#125;void dfs(int x,int last)&#123; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==last)continue; deep[to]=deep[x]+1; fa[to]=x;dfs(to,x); &#125;&#125;int dis(int x,int y)&#123; int ans=1; while(x!=y) &#123; if(deep[x]&lt;deep[y])swap(x,y); x=fa[x];ans++; &#125; return ans;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;void ntt(int *a,int n,int f)&#123; int k=0;while((1&lt;&lt;k)&lt;n)k++; for(int i=0;i&lt;n;i++) &#123; int t=0; for(int j=0;j&lt;k;j++) if(i&amp;(1&lt;&lt;j))t|=(1&lt;&lt;(k-j-1)); if(i&lt;t)swap(a[i],a[t]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1,nw=power(3,(mod-1)/l); if(f==-1)nw=power(nw,mod-2); for(int *p=a;p!=a+n;p+=l) &#123; int w=1; for(int i=0;i&lt;m;i++) &#123; int t=1ll*p[m+i]*w%mod; p[m+i]=(p[i]-t+mod)%mod; p[i]=(p[i]+t)%mod; w=1ll*w*nw%mod; &#125; &#125; &#125; if(f==-1) &#123; int inv=power(n,mod-2); for(int i=0;i&lt;n;i++)a[i]=1ll*a[i]*inv%mod; &#125;&#125;int main()&#123; n=read();m=read(); fac[0]=1; for(int i=1;i&lt;=n;i++)fac[i]=1ll*fac[i-1]*i%mod; fav[n]=power(fac[n],mod-2); for(int i=n;i&gt;=1;i--)fav[i-1]=1ll*fav[i]*i%mod; for(int i=1;i&lt;=n;i++)bel[i]=i; for(int i=1;i&lt;=n;i++)val[i]=read(); for(int i=n-1;i&gt;=1;i--)val[i]=min(val[i],val[i+1]); for(int i=1;i&lt;=m;i++) &#123; x=read();y=read(); if(find(x)!=find(y))bel[find(x)]=find(y),ins(x,y),ins(y,x); else tot++,hx[tot]=x,hy[tot]=y; &#125; dfs(1,-1);sum=n-1;cnt=0; for(int i=1;i&lt;=tot;i++) length[i]=dis(hx[i],hy[i]),sum-=(length[i]-1); if(sum&gt;=0) &#123; cur=&amp;o[cnt];cnt=sum+1; for(int i=0;i&lt;=sum;i++)cur[i]=C(sum,i); q.push((node)&#123;sum,cur&#125;); &#125; for(int i=1;i&lt;=tot;i++) &#123; cur=&amp;o[cnt];cnt+=length[i]; cur[0]=length[i]+1; for(int j=1;j&lt;=length[i]-1;j++)cur[j]=C(length[i],j+1); q.push((node)&#123;length[i]-1,cur&#125;); &#125; while(q.size()&gt;1) &#123; aa=q.top();q.pop(); al=aa.n;acur=aa.cur; bb=q.top();q.pop(); bl=bb.n;bcur=bb.cur; for(nn=1;nn&lt;=al+bl;nn&lt;&lt;=1); for(int i=0;i&lt;nn;i++)a[i]=b[i]=0; for(int i=0;i&lt;=al;i++)a[i]=acur[i]; for(int i=0;i&lt;=bl;i++)b[i]=bcur[i]; ntt(a,nn,1);ntt(b,nn,1); for(int i=0;i&lt;nn;i++)a[i]=1ll*a[i]*b[i]%mod; ntt(a,nn,-1); cur=&amp;o[cnt];cnt+=al+bl+1; for(int i=0;i&lt;=al+bl;i++)cur[i]=a[i]; q.push((node)&#123;al+bl,cur&#125;); &#125; int ans=0;aa=q.top();cur=aa.cur; for(int i=1;i&lt;=n;i++)ans=(ans+1ll*val[i]*cur[i-1])%mod; printf(\"%d\",ans); return 0;&#125;","categories":[],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"},{"name":"NTT","slug":"NTT","permalink":"http://yoursite.com/tags/NTT/"},{"name":"启发式合并","slug":"启发式合并","permalink":"http://yoursite.com/tags/启发式合并/"},{"name":"生成函数","slug":"生成函数","permalink":"http://yoursite.com/tags/生成函数/"},{"name":"仙人掌","slug":"仙人掌","permalink":"http://yoursite.com/tags/仙人掌/"}]},{"title":"「51nod 1920」空间统计学","slug":"51nod1920","date":"2018-05-24T10:53:31.000Z","updated":"2018-05-28T11:30:16.574Z","comments":true,"path":"51nod1920/","link":"","permalink":"http://yoursite.com/51nod1920/","excerpt":"有个 mmm 维的空间，并且每一维的坐标 xxx 都满足 x∈[0,3]x\\in [0,3]x∈[0,3] 并且 xxx 为整数。 这个空间有 nnn 个部落，每个部落都坐落在这片空间中的一个点上，可以用坐标 (x1,x2,⋯,xm)(x_1,x_2,\\cdots ,x_m)(x1​,x2​,⋯,xm​) 来表示。 有些部落可能在在同一个点上面。 定义两个点的距离为它们的曼哈顿距离，即每一维坐标差的绝对值的和。 比如对于点 (x1,x2,⋯,xm)(x_1,x_2,\\cdots ,x_m)(x1​,x2​,⋯,xm​) 和 (y1,y2,⋯,ym)(y_1,y_2,\\cdots ,y_m)(y1​,y2​,⋯,ym​) ，它们之间的距离为 ∑i=1m∣xi−yi∣\\sum _{i=1}^{m}|x_i-y_i|∑i=1m​∣xi​−yi​∣ 。 现在对 [0,3m][0,3m][0,3m] 之间的每一个数字 xxx ，统计有多少对部落之间的距离为 xxx。 注意，一对部落是有序的，即部落 (a,b)(a,b)(a,b) 和部落 (b,a)(b,a)(b,a) 为不同的两对。","text":"有个 mmm 维的空间，并且每一维的坐标 xxx 都满足 x∈[0,3]x\\in [0,3]x∈[0,3] 并且 xxx 为整数。 这个空间有 nnn 个部落，每个部落都坐落在这片空间中的一个点上，可以用坐标 (x1,x2,⋯,xm)(x_1,x_2,\\cdots ,x_m)(x1​,x2​,⋯,xm​) 来表示。 有些部落可能在在同一个点上面。 定义两个点的距离为它们的曼哈顿距离，即每一维坐标差的绝对值的和。 比如对于点 (x1,x2,⋯,xm)(x_1,x_2,\\cdots ,x_m)(x1​,x2​,⋯,xm​) 和 (y1,y2,⋯,ym)(y_1,y_2,\\cdots ,y_m)(y1​,y2​,⋯,ym​) ，它们之间的距离为 ∑i=1m∣xi−yi∣\\sum _{i=1}^{m}|x_i-y_i|∑i=1m​∣xi​−yi​∣ 。 现在对 [0,3m][0,3m][0,3m] 之间的每一个数字 xxx ，统计有多少对部落之间的距离为 xxx。 注意，一对部落是有序的，即部落 (a,b)(a,b)(a,b) 和部落 (b,a)(b,a)(b,a) 为不同的两对。 Constraints n≤200000n\\leq 200000n≤200000 ， m≤9m\\leq 9m≤9 Solution 观察数据范围可得 mmm 和坐标范围都很小，考虑状压 dp 。 令 f(i,j,k)f(i,j,k)f(i,j,k) 表示当前已经考虑到第 iii 维，到达 jjj 这个状态（将坐标压成四进制），当前距离为 kkk 的方案数。 转移时枚举上一维的状态和距离以及当前维的坐标，直接转移即可。 利用滚动数组节省空间，时间复杂度 O(12⋅m2⋅4m)O(12\\cdot m^2 \\cdot 4^m)O(12⋅m2⋅4m) 。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int M=262144+5;int n,m,x; int bit[10],a[N],f[2][M][28];LL ans;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int ab(int x)&#123;return x&gt;=0?x:-x;&#125;int main()&#123; n=read();m=read(); bit[0]=1; for(int i=1;i&lt;=m;i++)bit[i]=bit[i-1]*4; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;m;j++) x=read(),a[i]+=bit[j]*x; f[0][a[i]][0]++; &#125; int last=0,cur=1; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;bit[m];j++) for(int k=0;k&lt;=3*i;k++) f[cur][j][k]=0; for(int j=0;j&lt;bit[m];j++) &#123; x=j/bit[i]%4; for(int l=0;l&lt;=3*m;l++) &#123; if(!f[last][j][l])continue; for(int k=0;k&lt;=3;k++) f[cur][j+(k-x)*bit[i]][l+ab(k-x)]+=f[last][j][l]; &#125; &#125; last=cur;cur=1-cur; &#125; for(int i=0;i&lt;=3*m;i++) &#123; ans=0; for(int j=1;j&lt;=n;j++)ans+=f[m&amp;1][a[j]][i]; printf(\"%lld \",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"状压dp","slug":"状压dp","permalink":"http://yoursite.com/tags/状压dp/"}]},{"title":"「51nod 2026」Gcd and Lcm","slug":"51nod2026","date":"2018-05-23T23:35:51.000Z","updated":"2018-05-24T04:33:46.397Z","comments":true,"path":"51nod2026/","link":"","permalink":"http://yoursite.com/51nod2026/","excerpt":"已知 f(x)=∑d∣xμ(d)⋅df(x)=\\sum_{d|x} \\mu(d) \\cdot df(x)=∑d∣x​μ(d)⋅d ，现在请求出下面式子的值： ∑i=1n∑j=1nf(gcd⁡(i,j))⋅f(lcm(i,j))\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n f(\\gcd(i,j)) \\cdot f(\\text{lcm}(i,j)) i=1∑n​j=1∑n​f(gcd(i,j))⋅f(lcm(i,j)) 由于值可能过大所以请对 109+710^9+7109+7 取模","text":"已知 f(x)=∑d∣xμ(d)⋅df(x)=\\sum_{d|x} \\mu(d) \\cdot df(x)=∑d∣x​μ(d)⋅d ，现在请求出下面式子的值： ∑i=1n∑j=1nf(gcd⁡(i,j))⋅f(lcm(i,j))\\sum\\limits_{i=1}^n \\sum\\limits_{j=1}^n f(\\gcd(i,j)) \\cdot f(\\text{lcm}(i,j)) i=1∑n​j=1∑n​f(gcd(i,j))⋅f(lcm(i,j)) 由于值可能过大所以请对 109+710^9+7109+7 取模 Constraints $ n \\leq 10^9 $ Solution 对 iii 和 jjj 进行质因数分解，即 i=∏pqii=\\prod p^{qi}i=∏pqi ，j=∏pqjj=\\prod p^{qj}j=∏pqj ，可以得到： f(gcd⁡(i,j))⋅f(lcm(i,j))=∏f(pmin(qi,qj))⋅f(pmax(qi,qj))=f(i)⋅f(j)\\begin{aligned} &amp;~~~~f(\\gcd(i,j)) \\cdot f(\\text{lcm}(i,j)) \\\\ &amp;= \\prod f(p^{min(qi,qj)})\\cdot f(p^{max(qi,qj)}) \\\\ &amp;= f(i)\\cdot f(j) \\end{aligned} ​ f(gcd(i,j))⋅f(lcm(i,j))=∏f(pmin(qi,qj))⋅f(pmax(qi,qj))=f(i)⋅f(j)​ 将原答案转换为： ans=∑i=1n∑j=1nf(gcd⁡(i,j))⋅f(lcm(i,j))=∑i=1n∑j=1nf(i)⋅f(j)=(∑i=1nf(i))2=(∑i=1n∑d∣iμ(d)⋅d)2=(∑i=1nμ(i)⋅i⋅⌊ni⌋)2\\begin{aligned} ans&amp;=\\sum_{i=1}^n \\sum_{j=1}^n f(\\gcd(i,j)) \\cdot f(\\text{lcm}(i,j)) \\\\ &amp;=\\sum_{i=1}^n \\sum_{j=1}^n f(i)\\cdot f(j) \\\\ &amp;=(\\sum_{i=1}^n f(i))^2 \\\\ &amp;=(\\sum_{i=1}^n \\sum_{d|i} \\mu(d) \\cdot d)^2 \\\\ &amp;=(\\sum_{i=1}^n \\mu(i) \\cdot i \\cdot \\left \\lfloor \\frac{n}{i} \\right \\rfloor)^2 \\end{aligned} ans​=i=1∑n​j=1∑n​f(gcd(i,j))⋅f(lcm(i,j))=i=1∑n​j=1∑n​f(i)⋅f(j)=(i=1∑n​f(i))2=(i=1∑n​d∣i∑​μ(d)⋅d)2=(i=1∑n​μ(i)⋅i⋅⌊in​⌋)2​ 然后令 S(n)=∑i=1nμ(i)⋅iS(n)=\\sum_{i=1}^n \\mu(i) \\cdot iS(n)=∑i=1n​μ(i)⋅i ，则由以下推导： 1=∑i=1ni⋅∑j∣iμ(j)=∑i=1ni⋅∑j=1⌊ni⌋j⋅μ(j)=∑i=1ni⋅S(⌊ni⌋)\\begin{aligned} 1&amp;=\\sum_{i=1}^n i \\cdot \\sum _{j|i} \\mu(j) \\\\ &amp;=\\sum_{i=1}^n i\\cdot \\sum_{j=1}^{\\left \\lfloor \\frac{n}{i} \\right \\rfloor} j \\cdot \\mu(j) \\\\ &amp;=\\sum_{i=1}^n i\\cdot S({\\left \\lfloor \\frac{n}{i} \\right \\rfloor}) \\end{aligned} 1​=i=1∑n​i⋅j∣i∑​μ(j)=i=1∑n​i⋅j=1∑⌊in​⌋​j⋅μ(j)=i=1∑n​i⋅S(⌊in​⌋)​ 可得：S(n)=1−∑i=2ni⋅S(⌊ni⌋)S(n)=1-\\sum_{i=2}^n i\\cdot S({\\left \\lfloor \\frac{n}{i} \\right \\rfloor})S(n)=1−∑i=2n​i⋅S(⌊in​⌋) 杜教筛即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6;const int mod=1e9+7;int n,nn,tot,now;int miu[N+5],pri[N+5],a[N+5];bool np[N+5];int calc(int l,int r)&#123;return 1ll*(l+r)*(r-l+1)/2%mod;&#125;int solve(int n)&#123; if(n&lt;=N)return miu[n]; if(~a[nn/n])return a[nn/n]; int ans=1,pos; for(int i=2;i&lt;=n;i=pos+1) &#123; pos=n/(n/i); ans=(ans-1ll*calc(i,pos)*solve(n/i)%mod+mod)%mod; &#125; return a[nn/n]=ans;&#125;int main()&#123; scanf(\"%d\",&amp;n); nn=n;miu[1]=1; for(int i=2;i&lt;=N;i++) &#123; if(!np[i])&#123;miu[i]=-1;pri[++tot]=i;&#125; for(int j=1;1ll*i*pri[j]&lt;=N;j++) &#123; now=i*pri[j];np[now]=true; if(i%pri[j]==0)&#123;miu[now]=0;break;&#125; miu[now]=-miu[i]; &#125; &#125; for(int i=1;i&lt;=N;i++) miu[i]=(miu[i-1]+(1ll*miu[i]*i%mod+mod)%mod)%mod; int ans=0,pos; memset(a,-1,sizeof(a)); for(int i=1;i&lt;=n;i=pos+1) &#123; pos=n/(n/i); ans=(ans+1ll*(solve(pos)-solve(i-1)+mod)%mod*(n/i)%mod)%mod; &#125; printf(\"%lld\",1ll*ans*ans%mod); return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"},{"name":"杜教筛","slug":"杜教筛","permalink":"http://yoursite.com/tags/杜教筛/"}]},{"title":"「BZOJ 4259」残缺的字符串","slug":"bzoj4259","date":"2018-05-23T03:32:20.000Z","updated":"2018-05-23T05:37:38.422Z","comments":true,"path":"bzoj4259/","link":"","permalink":"http://yoursite.com/bzoj4259/","excerpt":"很久很久以前，在你刚刚学习字符串匹配的时候，有两个仅包含小写字母的字符串 AAA 和 BBB ，其中 AAA 串长度为 mmm ，BBB 串长度为 nnn 。可当你现在再次碰到这两个串时，这两个串已经老化了，每个串都有不同程度的残缺。 你想对这两个串重新进行匹配，其中 AAA 为模板串，那么现在问题来了，请回答，对于 BBB 的每一个位置 iii ，从这个位置开始连续 mmm 个字符形成的子串是否可能与 AAA 串完全匹配?","text":"很久很久以前，在你刚刚学习字符串匹配的时候，有两个仅包含小写字母的字符串 AAA 和 BBB ，其中 AAA 串长度为 mmm ，BBB 串长度为 nnn 。可当你现在再次碰到这两个串时，这两个串已经老化了，每个串都有不同程度的残缺。 你想对这两个串重新进行匹配，其中 AAA 为模板串，那么现在问题来了，请回答，对于 BBB 的每一个位置 iii ，从这个位置开始连续 mmm 个字符形成的子串是否可能与 AAA 串完全匹配? Constraints 1≤m,n≤3000001\\leq m,n \\leq 3000001≤m,n≤300000 Solution 首先将 * 号的值置为 000 ，那么对于两个长度皆为 mmm 的串，若 ∑i=0m−1(A[i]−B[i])2A[i]B[i]=0\\sum _{i=0}^{m-1}(A[i]-B[i])^2 A[i]B[i]=0∑i=0m−1​(A[i]−B[i])2A[i]B[i]=0 ，则两个串可以完全匹配。 此时若将 AAA 串翻转，并枚举在 BBB 串中的结尾位置，则可得： f[i]=∑j=0i(A[j]−B[i−j])2A[j]B[i−j]=∑j=0iA[j]3B[i−j]−2∑j=0iA[j]2B[i−j]2+∑j=0iA[j]B[i−j]3\\begin{aligned} f[i] &amp;= \\sum _{j=0}^{i}(A[j]-B[i-j])^2 A[j]B[i-j] \\\\ &amp;= \\sum _{j=0}^{i}A[j]^3B[i-j]-2\\sum _{j=0}^{i}A[j]^2B[i-j]^2+\\sum _{j=0}^{i}A[j]B[i-j]^3 \\end{aligned} f[i]​=j=0∑i​(A[j]−B[i−j])2A[j]B[i−j]=j=0∑i​A[j]3B[i−j]−2j=0∑i​A[j]2B[i−j]2+j=0∑i​A[j]B[i−j]3​ 直接 FFT 即可，注意卡常。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N=524288+5;const double pi=acos(-1);int n,n1,n2,cnt,out[N],a[N],b[N];char s1[N],s2[N];struct cpx&#123;double r,i;cpx(double _r=0,double _i=0):r(_r),i(_i)&#123;&#125;;&#125;;cpx A[N],B[N],ans[N];cpx operator + (cpx a,cpx b)&#123;return cpx(a.r+b.r,a.i+b.i);&#125;cpx operator - (cpx a,cpx b)&#123;return cpx(a.r-b.r,a.i-b.i);&#125;cpx operator * (cpx a,cpx b)&#123;return cpx(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);&#125;void fft(cpx *a,int n,int f)&#123; int k=0;while((1&lt;&lt;k)&lt;n)k++; for(int i=0;i&lt;n;i++) &#123; int t=0; for(int j=0;j&lt;k;j++) if(i&amp;(1&lt;&lt;j))t|=(1&lt;&lt;(k-j-1)); if(i&lt;t)swap(a[i],a[t]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; cpx nw=cpx(cos(2*pi/l),sin(2*pi/l)*f); for(cpx *p=a;p!=a+n;p+=l) &#123; cpx w=cpx(1,0); for(int i=0;i&lt;m;i++) &#123; cpx t=p[m+i]*w;w=w*nw; p[m+i]=p[i]-t;p[i]=p[i]+t; &#125; &#125; &#125; if(f==-1)for(int i=0;i&lt;n;i++)a[i].r/=n;&#125;int main()&#123; scanf(\"%d%d%s%s\",&amp;n1,&amp;n2,s1,s2); n=1;while(n&lt;n1||n&lt;n2)n&lt;&lt;=1; for(int i=0;i&lt;n1;i++)if(s1[i]!='*')a[n1-i-1]=s1[i]-'a'+1; for(int i=0;i&lt;n2;i++)if(s2[i]!='*')b[i]=s2[i]-'a'+1; for(int i=0;i&lt;n;i++)A[i]=cpx(a[i]*a[i]*a[i],0); for(int i=0;i&lt;n;i++)B[i]=cpx(b[i],0); fft(A,n,1);fft(B,n,1); for(int i=0;i&lt;n;i++)ans[i]=A[i]*B[i]; for(int i=0;i&lt;n;i++)A[i]=cpx(a[i]*a[i],0); for(int i=0;i&lt;n;i++)B[i]=cpx(b[i]*b[i],0); fft(A,n,1);fft(B,n,1); for(int i=0;i&lt;n;i++)ans[i]=ans[i]-A[i]*B[i]*cpx(2,0); for(int i=0;i&lt;n;i++)A[i]=cpx(a[i],0); for(int i=0;i&lt;n;i++)B[i]=cpx(b[i]*b[i]*b[i],0); fft(A,n,1);fft(B,n,1); for(int i=0;i&lt;n;i++)ans[i]=ans[i]+A[i]*B[i]; fft(ans,n,-1); for(int i=n1-1;i&lt;n2;i++) if(ans[i].r&lt;0.5)out[++cnt]=i-n1+2; printf(\"%d\\n\",cnt); for(int i=1;i&lt;=cnt;i++)printf(\"%d \",out[i]); return 0;&#125;","categories":[],"tags":[{"name":"FFT","slug":"FFT","permalink":"http://yoursite.com/tags/FFT/"}]},{"title":"「LOJ 6041」「雅礼集训 2017 Day7」事情的相似度","slug":"loj6041","date":"2018-05-22T12:46:07.000Z","updated":"2018-05-22T12:54:17.286Z","comments":true,"path":"loj6041/","link":"","permalink":"http://yoursite.com/loj6041/","excerpt":"人的一生不仅要靠自我奋斗，还要考虑到历史的行程。 历史的行程可以抽象成一个 010101 串，作为一个年纪比较大的人，你希望从历史的行程中获得一些姿势。 你发现在历史的不同时刻，不断的有相同的事情发生。比如，有两个人同时在世纪之交 111111 年的时候上台，同样喜欢与洋人谈笑风生，同样提出了以「三」字开头的理论。 你发现，一件事情可以看成是这个 010101 串的一个前缀，这个前缀最右边的位置就是这个事情的结束时间。 两件事情的相似度可以看成，这两个前缀的最长公共后缀长度。 现在你很好奇，在一段区间内结束的事情中最相似的两件事情的相似度是多少呢？","text":"人的一生不仅要靠自我奋斗，还要考虑到历史的行程。 历史的行程可以抽象成一个 010101 串，作为一个年纪比较大的人，你希望从历史的行程中获得一些姿势。 你发现在历史的不同时刻，不断的有相同的事情发生。比如，有两个人同时在世纪之交 111111 年的时候上台，同样喜欢与洋人谈笑风生，同样提出了以「三」字开头的理论。 你发现，一件事情可以看成是这个 010101 串的一个前缀，这个前缀最右边的位置就是这个事情的结束时间。 两件事情的相似度可以看成，这两个前缀的最长公共后缀长度。 现在你很好奇，在一段区间内结束的事情中最相似的两件事情的相似度是多少呢？ Constraints 1≤n,m≤1051 \\leq n,m \\leq 10^51≤n,m≤105 Solution 建出原串的 SAM ，则两个前缀的最长公共后缀为他们在 parent 树上的 lca ，问题转化为求区间内前缀两两 lca 深度的最大值。 将询问离线，按右端点从小到大排序。我们考虑每次加入一个字母，就将他们在 parent 树上到根节点的路径打上他们的标记。往根节点跑的过程中，若遇到了以前打的标记，则该节点为旧标记与新标记的 lca 。贪心可得应把标记尽量覆盖为较大的值。用树状数组来统计答案，下标为左端点，每次查询下标大于等于该询问左端点的最大深度。向根跑的过程中每一次遇到旧标记，就在树状数组上更新答案，并给该节点打上新标记。 往根节点跑的过程实际上就是 LCT 的 access 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,m,r,last,size,root;int p[N],mx[N],ans[N],num[N];int c[N*2][2],fa[N*2],v[N*2],tag[N*2];char s[N];vector&lt;int&gt; q[N];struct sam&#123;int mx,fa,ch[2];&#125;t[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void modify(int x,int v)&#123;x=n-x+1;while(x&lt;=n)mx[x]=max(mx[x],v),x+=lowbit(x);&#125;int query(int x)&#123;x=n-x+1;int ans=0;while(x)ans=max(ans,mx[x]),x-=lowbit(x);return ans;&#125;void ins(int c,int id)&#123; int np=++size;num[id]=np; t[np].mx=t[last].mx+1; int x=last;last=np; while(x&amp;&amp;!t[x].ch[c])t[x].ch[c]=np,x=t[x].fa; if(!x)t[np].fa=root; else &#123; int y=t[x].ch[c]; if(t[y].mx==t[x].mx+1)t[np].fa=y; else &#123; int nq=++size; t[nq]=t[y];t[nq].mx=t[x].mx+1; t[y].fa=t[np].fa=nq; while(x&amp;&amp;t[x].ch[c]==y)t[x].ch[c]=nq,x=t[x].fa; &#125; &#125;&#125;bool isroot(int x)&#123;return c[fa[x]][0]!=x&amp;&amp;c[fa[x]][1]!=x;&#125;void change(int x,int val)&#123;v[x]=tag[x]=val;&#125;void down(int x)&#123; if(!tag[x])return; if(c[x][0])change(c[x][0],tag[x]); if(c[x][1])change(c[x][1],tag[x]); tag[x]=0;&#125;void rotate(int x)&#123; int y=fa[x],z=fa[y],l,r; if(c[y][0]==x)l=0;else l=1;r=l^1; if(!isroot(y))&#123;if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;&#125; fa[x]=z;fa[y]=x;fa[c[x][r]]=y; c[y][l]=c[x][r];c[x][r]=y;&#125;void relax(int x)&#123;if(!isroot(x))relax(fa[x]);down(x);&#125;void splay(int x)&#123; relax(x); while(!isroot(x)) &#123; int y=fa[x],z=fa[y]; if(!isroot(y)) &#123; if((c[y][0]==x)^(c[z][0]==y))rotate(x); else rotate(y); &#125; rotate(x); &#125;&#125;void access(int x,int val)&#123; int o=0; while(x) &#123; splay(x);modify(v[x],t[x].mx); c[x][1]=o;o=x;x=fa[x]; &#125; tag[o]=v[o]=val;&#125;void build()&#123;for(int i=1;i&lt;=size;i++)fa[i]=t[i].fa;&#125;int main()&#123; n=read();m=read(); scanf(\"%s\",s+1); for(int i=1;i&lt;=m;i++) &#123; p[i]=read();r=read(); q[r].push_back(i); &#125; last=size=root=1; for(int i=1;i&lt;=n;i++)ins(s[i]-'0',i); build(); for(int i=1;i&lt;=n;i++) &#123; access(num[i],i); int sz=q[i].size(); for(int j=0;j&lt;sz;j++) &#123; int x=q[i][j]; ans[x]=query(p[x]); &#125; &#125; for(int i=1;i&lt;=m;i++)printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"},{"name":"Link-Cut Tree","slug":"Link-Cut-Tree","permalink":"http://yoursite.com/tags/Link-Cut-Tree/"},{"name":"SAM","slug":"SAM","permalink":"http://yoursite.com/tags/SAM/"}]},{"title":"「AGC 005F」Many Easy Problems","slug":"agc005f","date":"2018-05-22T12:41:39.000Z","updated":"2018-05-31T08:41:08.130Z","comments":true,"path":"agc005f/","link":"","permalink":"http://yoursite.com/agc005f/","excerpt":"给定一棵 nnn 个节点的树，选出 kkk 个特殊点，假设点集为 SSS，令 f(S)f(S)f(S) 为最小的包含这 kkk 个节点的连通块，分别求出 k=1⋯nk=1\\cdots nk=1⋯n 在所有情况下的 f(S)f(S)f(S) 的和。","text":"给定一棵 nnn 个节点的树，选出 kkk 个特殊点，假设点集为 SSS，令 f(S)f(S)f(S) 为最小的包含这 kkk 个节点的连通块，分别求出 k=1⋯nk=1\\cdots nk=1⋯n 在所有情况下的 f(S)f(S)f(S) 的和。 Constraints 2≤n≤2000002 \\leq n \\leq 2000002≤n≤200000 Solution 考虑暴力，一个点被统计在连通块内，即在以它为根时，选出来的 kkk 个点都在它的同一个儿子的子树内。即节点 xxx 被统计进答案的次数 g(x)g(x)g(x) 为： g(x)=(nk)−∑(x,i)⊆E(szik)g(x)=\\binom{n}{k}-\\sum _{(x,i)\\subseteq E}\\binom{sz_{i}}{k} g(x)=(kn​)−(x,i)⊆E∑​(kszi​​) 令 cntxcnt_{x}cntx​ 表示上述公式里有多少个 szi=xsz_{i}=xszi​=x，那么可以得到： ansk=∑i=1ncnti⋅(ik)ans_{k}=\\sum _{i=1}^{n}cnt_{i}\\cdot\\binom{i}{k} ansk​=i=1∑n​cnti​⋅(ki​) 整理可得： k!⋅ansk=∑i=1ncnti⋅i!(i−k)!k!\\cdot ans_{k}=\\sum _{i=1}^{n}\\frac{cnt_{i}\\cdot i!}{(i-k)!} k!⋅ansk​=i=1∑n​(i−k)!cnti​⋅i!​ 令 ai=cnti⋅i!a_{i}=cnt_{i}\\cdot i!ai​=cnti​⋅i!，bi=(n−i)!b_{i}=(n-i)!bi​=(n−i)!，则可得： k!⋅ansk=∑i=1nai⋅bn−i+kk!\\cdot ans_{k}=\\sum _{i=1}^{n}a_{i}\\cdot b_{n-i+k} k!⋅ansk​=i=1∑n​ai​⋅bn−i+k​ 最终答案为 n⋅(nk)−anskn\\cdot \\binom{n}{k}-ans_{k}n⋅(kn​)−ansk​ 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int M=524288+5;const int mod=924844033; int n,nn,cnt,u,v,ans,first[N],fac[N],inv[N];int num[N],sz[N],a[M],b[M];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x,int fa)&#123; sz[x]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs(to,x); sz[x]+=sz[to]; &#125; if(fa!=-1)a[sz[x]]++,a[n-sz[x]]++;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;void ntt(int *a,int n,int f)&#123; int k=0;while((1&lt;&lt;k)&lt;n)k++; for(int i=0;i&lt;n;i++) &#123; int t=0; for(int j=0;j&lt;k;j++) if(i&amp;(1&lt;&lt;j))t|=(1&lt;&lt;(k-j-1)); if(i&lt;t)swap(a[i],a[t]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1,nw=power(5,(mod-1)/l); if(f==-1)nw=power(nw,mod-2); for(int *p=a;p!=a+n;p+=l) &#123; int w=1; for(int i=0;i&lt;m;i++) &#123; int t=1ll*p[m+i]*w%mod; p[m+i]=(p[i]-t+mod)%mod; p[i]=(p[i]+t)%mod; w=1ll*w*nw%mod; &#125; &#125; &#125; if(f==-1) &#123; int inv=power(n,mod-2); for(int i=0;i&lt;n;i++)a[i]=1ll*a[i]*inv%mod; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; u=read();v=read(); ins(u,v);ins(v,u); &#125; dfs(1,-1); fac[0]=1; for(int i=1;i&lt;=n;i++)fac[i]=1ll*fac[i-1]*i%mod; inv[n]=power(fac[n],mod-2); for(int i=n;i&gt;=1;i--)inv[i-1]=1ll*inv[i]*i%mod; for(int i=1;i&lt;=n;i++)a[i]=1ll*a[i]*fac[i]%mod; for(int i=0;i&lt;=n;i++)b[n-i]=inv[i]; nn=1;while(nn&lt;n+n+1)nn&lt;&lt;=1; ntt(a,nn,1);ntt(b,nn,1); for(int i=0;i&lt;nn;i++)a[i]=1ll*a[i]*b[i]%mod; ntt(a,nn,-1); for(int i=1;i&lt;=n;i++) &#123; ans=1ll*fac[n]*inv[i]%mod*inv[n-i]%mod*n%mod; printf(\"%lld\\n\",(ans-1ll*a[n+i]*inv[i]%mod+mod)%mod); &#125; return 0;&#125;","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"},{"name":"NTT","slug":"NTT","permalink":"http://yoursite.com/tags/NTT/"}]},{"title":"「AGC 002F」Leftmost Ball","slug":"agc002f","date":"2018-05-22T12:32:40.000Z","updated":"2018-05-31T08:41:16.126Z","comments":true,"path":"agc002f/","link":"","permalink":"http://yoursite.com/agc002f/","excerpt":"有 nnn 种颜色的球，标号 111 到 nnn ，每种颜色有 kkk 个。将 nknknk 个球随机排列后，将每种颜色的第一个球涂成颜色 000 ，求最终可能得到的颜色序列的方案数。","text":"有 nnn 种颜色的球，标号 111 到 nnn ，每种颜色有 kkk 个。将 nknknk 个球随机排列后，将每种颜色的第一个球涂成颜色 000 ，求最终可能得到的颜色序列的方案数。 Constraints 1≤n,k≤20001\\leq n,k \\leq 20001≤n,k≤2000 Solution 令 f(i,j) (i≤j)f(i,j)~(i\\leq j)f(i,j) (i≤j) 表示已经放置了 iii 个编号为 000 的球与 jjj 种第一次出现的位置最靠前的颜色的方案数。每次在当前的第一个空位放置一个颜色为 000 的球或是一种未出现的颜色的球。可得转移方程： f(i,j)=f(i−1,j)+(n−i+(n−j+1)⋅(k−1)−1k−2)⋅(n−j+1)⋅f(i,j−1)f(i,j)=f(i-1,j)+\\binom{n-i+(n-j+1)\\cdot(k-1)-1}{k-2}\\cdot(n-j+1)\\cdot f(i,j-1) f(i,j)=f(i−1,j)+(k−2n−i+(n−j+1)⋅(k−1)−1​)⋅(n−j+1)⋅f(i,j−1) 时间复杂度O(nk)O(nk)O(nk)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e3+5;const int mod=1e9+7;int n,m,fac[N*N],inv[N*N],f[N][N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int C(int n,int m)&#123;return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;int main()&#123; n=read();m=read(); if(m==1)&#123;printf(\"1\");return 0;&#125; fac[0]=1; for(int i=1;i&lt;=n*m;i++)fac[i]=1ll*fac[i-1]*i%mod; inv[n*m]=power(fac[n*m],mod-2); for(int i=n*m;i&gt;=1;i--)inv[i-1]=1ll*inv[i]*i%mod; f[0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=i;j++) &#123; f[i][j]=f[i-1][j]; if(!j)continue; Mod(f[i][j],1ll*f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(m-1)-1,m-2)%mod); &#125; printf(\"%d\",f[n][n]); return 0;&#125;","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"}]},{"title":"「Codeforces 765F」Souvenirs","slug":"cf765f","date":"2018-05-22T12:23:24.000Z","updated":"2018-05-22T12:28:28.564Z","comments":true,"path":"cf765f/","link":"","permalink":"http://yoursite.com/cf765f/","excerpt":"给定 nnn 个数， mmm 次询问，每次询问区间中 ∣ai−aj∣|a_{i}-a_{j}|∣ai​−aj​∣ 的最小值。","text":"给定 nnn 个数， mmm 次询问，每次询问区间中 ∣ai−aj∣|a_{i}-a_{j}|∣ai​−aj​∣ 的最小值。 Constraints 2≤n≤1052 \\leq n \\leq 10^52≤n≤105 ，0≤ai≤1090 \\leq a_i \\leq 10^90≤ai​≤109 ，1≤m≤3⋅1051 \\leq m \\leq 3\\cdot 10^51≤m≤3⋅105 Solution 对于每一个 iii ，考虑所有满足 j&gt;ij&gt;ij&gt;i 且 aj≤aia_{j}\\leq a_{i}aj​≤ai​ 的可能可以成为答案的 jjj（aj≥aia_{j}\\geq a_{i}aj​≥ai​ 的情况可以用同样的方式处理）。假设当前已经找到了一对 (i,j)(i,j)(i,j)，则下一个合法的位置 kkk 需要满足 ak&lt;aja_{k}&lt;a_{j}ak​&lt;aj​ 且 ak−ai&lt;aj−aka_{k}-a_{i}&lt;a_{j}-a_{k}ak​−ai​&lt;aj​−ak​，即每次需要查询区间 [j+1,n][j+1,n][j+1,n] 内的第一个满足 ai≤ak&lt;ai+aj2a_{i}\\leq a_{k}&lt;\\frac{a_{i}+a_{j}}{2}ai​≤ak​&lt;2ai​+aj​​ 的 kkk，可以将数字从大到小加入线段树后直接查询。由于 aj−aia_{j}-a_{i}aj​−ai​ 每次至少减少一半，所以最多有 O(nloga)O(nloga)O(nloga)对(i,j)(i,j)(i,j) 。 得到所有合法的 (i,j)(i,j)(i,j) 后，可以按 jjj 排序后插入树状数组，每次查询左端点。时间复杂度 O((nloga+m)logn)O((nloga+m)logn)O((nloga+m)logn) 。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long long#define lc(x) x&lt;&lt;1#define rc(x) x&lt;&lt;1|1using namespace std;const int N=1e5+5;const int inf=0x3f3f3f3f;int n,m,tot,sum,a[N],b[N];int mn[N*4],ans[N*10];struct data&#123; int l,r,w,id; bool operator &lt; (const data &amp;t) const&#123;return r&lt;t.r||(r==t.r&amp;&amp;id&lt;t.id);&#125;&#125;c[N*70];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(int x,int y)&#123;return a[x]&gt;a[y]||(a[x]==a[y]&amp;&amp;x&gt;y);&#125;void modify(int x,int l,int r,int p,int w)&#123; mn[x]=min(mn[x],w); if(l==r)return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid)modify(lc(x),l,mid,p,w); else modify(rc(x),mid+1,r,p,w);&#125;int find(int x,int l,int r,int p,int w)&#123; if(l==r)return mn[x]&lt;=w?l:0; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid&amp;&amp;mn[lc(x)]&lt;=w) &#123; int t=find(lc(x),l,mid,p,w); if(t)return t; &#125; return find(rc(x),mid+1,r,p,w);&#125;void solve()&#123; memset(mn,0x3f,sizeof(mn)); sort(b+1,b+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; int j=find(1,1,n,b[i],inf-1); while(j) &#123; c[++tot]=(data)&#123;b[i],j,a[j]-a[b[i]],0&#125;; j=find(1,1,n,b[i],((a[b[i]]+a[j]-1)/2)); &#125; modify(1,1,n,b[i],a[b[i]]); &#125;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void change(int x,int w)&#123; x=n-x+1; while(x&lt;=n)mn[x]=min(mn[x],w),x+=lowbit(x);&#125;int query(int x)&#123; x=n-x+1;sum=inf; while(x)sum=min(sum,mn[x]),x-=lowbit(x); return sum;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read()+1,b[i]=i; solve(); for(int i=1;i&lt;=n;i++)a[i]=1e9+2-a[i]; solve(); m=read(); for(int i=1;i&lt;=m;i++) c[++tot]=(data)&#123;read(),read(),0,i&#125;; sort(c+1,c+tot+1); memset(mn,0x3f,sizeof(mn)); for(int i=1;i&lt;=tot;i++) if(c[i].id)ans[c[i].id]=query(c[i].l); else change(c[i].l,c[i].w); for(int i=1;i&lt;=m;i++)printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"}]},{"title":"「HDU 5217」Brackets","slug":"hdu5217","date":"2018-05-22T12:16:19.000Z","updated":"2018-05-22T13:01:53.472Z","comments":true,"path":"hdu5217/","link":"","permalink":"http://yoursite.com/hdu5217/","excerpt":"给出一个长度为 nnn 的括号序列和 222 种操作：1.1.1. 翻转某一个括号；2.2.2. 查询区间内完成括号匹配后第 kkk 个括号的原位置。","text":"给出一个长度为 nnn 的括号序列和 222 种操作：1.1.1. 翻转某一个括号；2.2.2. 查询区间内完成括号匹配后第 kkk 个括号的原位置。 Constraints 1≤n,q≤2000001\\leq n,q \\leq 2000001≤n,q≤200000 Solution 易得，最后的序列一定形如 ‘)))(((’ ，即左段皆为 ‘)’，右段皆为 ‘(’ 。我们可以建出一棵线段树，线段树上的每个节点对应区间内匹配后左段 ‘(’ 的数量和右段 ‘)’ 的数量。 区间合并与修改显然，主要问题在查询。至此我们可以通过查询区间 [L,R][L,R][L,R] 的信息快速得到第 kkk 个括号的类型。因为 ‘(’ 在从右往左合并区间时单调不减， ‘)’ 在从左往右合并区间时单调不减，所以可以在线段树上边跑边查询。详见代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc x&lt;&lt;1#define rc x&lt;&lt;1|1#define LL long longusing namespace std;const int N=5e5+5;int T,n,m,op,L,R,x;int a[N],id[N],tl[N*4],tr[N*4];char ch[N];struct node&#123;int t1,t0;&#125;ans,now,tmp,t[N*4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;node merge(node a,node b)&#123; node c=(node)&#123;a.t1,b.t0&#125;; if(a.t0&gt;b.t1)c.t0+=a.t0-b.t1; else c.t1+=b.t1-a.t0; return c;&#125;void build(int x,int l,int r)&#123; tl[x]=l;tr[x]=r; if(l==r) &#123; if(a[l])t[x]=(node)&#123;1,0&#125;; else t[x]=(node)&#123;0,1&#125;; id[l]=x;return; &#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid); build(rc,mid+1,r); t[x]=merge(t[lc],t[rc]);&#125;void modify(int x,int l,int r,int p)&#123; if(l==r) &#123; swap(t[x].t0,t[x].t1); return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid)modify(lc,l,mid,p); else modify(rc,mid+1,r,p); t[x]=merge(t[lc],t[rc]);&#125;void query(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; ans=merge(ans,t[x]); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)query(lc,l,mid); if(R&gt;mid)query(rc,mid+1,r);&#125;int work0(int x,int l,int r,int goal)&#123; if(l==r)return l; int mid=(l+r)&gt;&gt;1; tmp=now;now=merge(t[rc],now); if(now.t0&gt;=goal) &#123; now=tmp; return work0(rc,mid+1,r,goal); &#125; return work0(lc,l,mid,goal);&#125;int find0(int p,int goal)&#123; int x=id[p]; bool flag=false; now=merge(t[x],now); if(now.t0==goal)return p; if(x&amp;1)flag=true; while(1) &#123; x&gt;&gt;=1; if(flag) &#123; tmp=now;now=merge(t[lc],now); if(now.t0&gt;=goal)&#123;now=tmp;x=lc;break;&#125; &#125; if(x&amp;1)flag=true; else flag=false; &#125; return work0(x,tl[x],tr[x],goal);&#125;int work1(int x,int l,int r,int goal)&#123; if(l==r)return l; int mid=(l+r)&gt;&gt;1; tmp=now;now=merge(now,t[lc]); if(now.t1&gt;=goal) &#123; now=tmp; return work1(lc,l,mid,goal); &#125; return work1(rc,mid+1,r,goal);&#125;int find1(int p,int goal)&#123; int x=id[p]; bool flag=true; now=merge(now,t[x]); if(now.t1==goal)return p; if(x&amp;1)flag=false; while(1) &#123; x&gt;&gt;=1; if(flag) &#123; tmp=now;now=merge(now,t[rc]); if(now.t1&gt;=goal)&#123;now=tmp;x=rc;break;&#125; &#125; if(x&amp;1)flag=false; else flag=true; &#125; return work1(x,tl[x],tr[x],goal);&#125;void work()&#123; n=read();m=read(); scanf(\"%s\",ch+1); for(int i=1;i&lt;=n;i++) if(ch[i]=='(')a[i]=0; else a[i]=1; build(1,1,n); while(m--) &#123; op=read(); if(op==1) &#123; x=read(); modify(1,1,n,x); continue; &#125; L=read();R=read();x=read(); ans.t0=ans.t1=0; query(1,1,n); if(ans.t0+ans.t1&lt;x) &#123; printf(\"-1\\n\"); continue; &#125; now.t0=now.t1=0; if(x&lt;=ans.t1)printf(\"%d\\n\",find1(L,x)); else printf(\"%d\\n\",find0(R,ans.t0+ans.t1-x+1)); &#125;&#125;int main()&#123; T=read(); while(T--)work(); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"}]},{"title":"「HDU 5632」Rikka with Array","slug":"hdu5632","date":"2018-05-22T12:07:13.000Z","updated":"2018-05-22T12:14:49.034Z","comments":true,"path":"hdu5632/","link":"","permalink":"http://yoursite.com/hdu5632/","excerpt":"给定一个数 nnn ，问有多少个数对 (i,j)(i,j)(i,j) ，满足 1≤i&lt;j≤n1\\leq i&lt;j \\leq n1≤i&lt;j≤n 且 f[i]&gt;f[j]f[i]&gt;f[j]f[i]&gt;f[j] ，f[x]f[x]f[x] 为 xxx 二进制表示下 111 的个数。","text":"给定一个数 nnn ，问有多少个数对 (i,j)(i,j)(i,j) ，满足 1≤i&lt;j≤n1\\leq i&lt;j \\leq n1≤i&lt;j≤n 且 f[i]&gt;f[j]f[i]&gt;f[j]f[i]&gt;f[j] ，f[x]f[x]f[x] 为 xxx 二进制表示下 111 的个数。 Constraints n≤10300n \\leq 10^{300}n≤10300 Solution （在打模拟赛时写到的题目……好像写了一种跟所有人都不一样的写法） 首先考虑一个数 xxx ，我们需要统计满足 1≤i&lt;x1\\leq i&lt;x1≤i&lt;x 且 f[i]&gt;f[x]f[i]&gt;f[x]f[i]&gt;f[x] 的 iii 的个数。考虑数位 dpdpdp ，将 xxx 转为二进制形式，从低位往高位推。假设当前在第 iii 位，从第 111 位到第 iii 位共有 kkk 个 111 ：若当前位为 000 ，则直接跳过进行下一位的统计；否则钦定当前要统计进答案的数字的比第 iii 位高的位置与 xxx 相同，且第 iii 位为 000 ，则此时最低的第 i−1i-1i−1 位至少要有 k+1k+1k+1 个 111 ，可任意选取，即需要统计进答案里的方案数为 ∑j=k+1i−1(i−1j)\\sum _{j=k+1}^{i-1} \\binom{i-1}{j}∑j=k+1i−1​(ji−1​) ，令 s(i,j)=∑d=0j(id)s(i,j)=\\sum _{d=0}^{j}\\binom{i}{d}s(i,j)=∑d=0j​(di​) ，则公式简化为 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 。 现在我们需要统计总答案，且因为 nnn 很大，无法直接枚举。考虑将 nnn 转成二进制形式，共有 cntcntcnt 位，aia_{i}ai​ 为 nnn 在二进制下第 iii 位上的数字。统计每一个 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 被统计进答案的贡献。若 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 会在数字 xxx 时被统计进答案里， xxx 需要满足以下几个条件：1. 1≤x≤n1\\leq x\\leq n1≤x≤n ，2. xxx 的第 iii 位为 111 ，3. xxx 的前 iii 位恰好有 kkk 个 111 。答案转化为统计满足条件的 xxx 的个数。 我们递推一个数组 fff ，f(i,j)f(i,j)f(i,j) 表示数值小于等于 nnn 最低的 iii 位，且二进制下恰好含有 jjj 个 111 的数字的方案数。可得： f(i,j)={f(i−1,j) (ai=0)f(i−1,j−1)+(i−1j) (ai=1)f(i,j)=\\begin{cases}f(i-1,j)~~~~~~~~~~~~~~~~~~~~~~~(a_{i}=0)\\\\f(i-1,j-1)+\\binom{i-1}{j}~~~(a_{i}=1)\\end{cases} f(i,j)={f(i−1,j) (ai​=0)f(i−1,j−1)+(ji−1​) (ai​=1)​ 特殊的，f(i,0)=1(0≤i≤cnt)f(i,0)=1(0\\leq i\\leq cnt)f(i,0)=1(0≤i≤cnt) 。然后就可以数位 dpdpdp 出对于每一个 (i−1,k)(i-1,k)(i−1,k) 的组合，所有符合条件的数 xxx 了。 枚举当前在第 iii 位，前 i−1i-1i−1 位总共有 kkk 个 111 ，我们令 num=∑d=i+1cnt2d−(i+1)⋅adnum=\\sum _{d=i+1}^{cnt} 2^{d-(i+1)}\\cdot a_{d}num=∑d=i+1cnt​2d−(i+1)⋅ad​ ，即大于第 iii 位的部分的 000 到 num−1num-1num−1 的方案，则 s(i−1,i−1)−s(i−1,k+1)s(i-1,i-1)-s(i-1,k+1)s(i−1,i−1)−s(i−1,k+1) 的系数 ttt 计算方式如下： t={num⋅(i−1k) (ai=0)num⋅(i−1k)+f(i−1,k) (ai=1)t=\\begin{cases}num\\cdot \\binom{i-1}{k}~~~~~~~~~~~~~~~~~~~~~~~~~(a_{i}=0)\\\\num\\cdot \\binom{i-1}{k}+f(i-1,k)~~~(a_{i}=1)\\end{cases} t={num⋅(ki−1​) (ai​=0)num⋅(ki−1​)+f(i−1,k) (ai​=1)​ 然后就可以得到最终的答案了。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e3+5;const int mod=998244353;int T,n,cnt,ans,tmp,num,now,t;int x[N],a[N],C[N][N],s[N][N],f[N][N];char ch[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;int main()&#123; for(int i=0;i&lt;=1000;i++)C[i][0]=1; for(int i=1;i&lt;=1000;i++) for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; for(int i=0;i&lt;=1000;i++) for(int j=0;j&lt;=1000;j++) if(j)s[i][j]=(s[i][j-1]+C[i][j])%mod; else s[i][j]=C[i][j]; T=read(); while(T--) &#123; cnt=ans=0; scanf(\"%s\",ch+1); n=strlen(ch+1); for(int i=1;i&lt;=n;i++)x[n-i+1]=ch[i]-'0'; if(n==1&amp;&amp;(x[1]==0||x[1]==1))&#123;printf(\"0\\n\");continue;&#125; while(n) &#123; if(x[1]&amp;1)a[++cnt]=1,x[1]--; else a[++cnt]=0; for(int i=n;i&gt;=1;i--) if(x[i]&amp;1)x[i]/=2,x[i-1]+=10; else x[i]/=2; while(n&amp;&amp;x[n]==0)n--; &#125; memset(f,0,sizeof(f)); for(int i=0;i&lt;=cnt;i++)f[i][0]=1; for(int j=1;j&lt;=cnt;j++) for(int i=j;i&lt;=cnt;i++) if(!a[i])Mod(f[i][j],f[i-1][j]); else &#123; Mod(f[i][j],f[i-1][j-1]); Mod(f[i][j],C[i-1][j]); &#125; for(int i=1;i&lt;=cnt;i++) &#123; num=0; for(int j=cnt;j&gt;i;j--)num=(num*2+a[j])%mod; for(int j=0;j&lt;i;j++) &#123; t=1ll*num*C[i-1][j]%mod; Mod(ans,1ll*(s[i-1][i-1]-s[i-1][j+1]+mod)%mod*t%mod); if(!a[i])continue; Mod(ans,1ll*(s[i-1][i-1]-s[i-1][j+1]+mod)%mod*f[i-1][j]%mod); &#125; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数位dp","slug":"数位dp","permalink":"http://yoursite.com/tags/数位dp/"}]},{"title":"「Codeforces 914H」Ember and Storm's Tree Game","slug":"cf914h","date":"2018-05-22T10:56:21.000Z","updated":"2018-05-31T08:41:27.696Z","comments":true,"path":"cf914h/","link":"","permalink":"http://yoursite.com/cf914h/","excerpt":"Ember 和 Storm 正在玩游戏。首先，Ember 构造一棵 nnn 个节点且每个节点度数不超过 ddd 的带节点编号的树 TTT 。然后，Storm 选择两个不同的节点 uuu 和 vvv ，并写下从 uuu 到 vvv 路径上的节点编号，记为序列 a1,a2⋯aka_1,a_2\\cdots a_ka1​,a2​⋯ak​ 。最后，Ember 在序列中选择一个位置 i(1≤i&lt;k)i(1\\leq i &lt; k)i(1≤i&lt;k) ，并在以下两个操作选择一个执行： 翻转 ai+1⋯aka_{i+1}\\cdots a_kai+1​⋯ak​ 并将这一段加上 aia_iai​，操作后序列变为 a1a_1a1​，⋯ai\\cdots a_i⋯ai​，ak+aia_k+a_iak​+ai​，ak−1+aia_{k-1}+a_iak−1​+ai​，⋯ai+1+ai\\cdots a_{i+1}+a_i⋯ai+1​+ai​ 取负 ai+1⋯aka_{i+1}\\cdots a_kai+1​⋯ak​ 并将这一段加上 aia_iai​，操作后序列变为 a1a_1a1​，⋯ai\\cdots a_i⋯ai​，−ai+1+ai-a_{i+1}+a_i−ai+1​+ai​，−ai+2+ai-a_{i+2}+a_i−ai+2​+ai​，⋯−ak+ai\\cdots -a_k+a_i⋯−ak​+ai​ 如果最后的序列是严格单调的，则 Ember 获胜，否则 Storm 获胜。 游戏情形可以用一个元组 (T,u,v,i,op)(T,u,v,i,op)(T,u,v,i,op) 来描述，opopop 为翻转或是取负取决于 Ember 的决策。若 Ember 和 Storm 都使用最优策略（若有多种必胜策略，任选一种执行；若必败，也任选一种执行），试统计所有可能的游戏情形的数量，并输出其取模 mmm 的结果。","text":"Ember 和 Storm 正在玩游戏。首先，Ember 构造一棵 nnn 个节点且每个节点度数不超过 ddd 的带节点编号的树 TTT 。然后，Storm 选择两个不同的节点 uuu 和 vvv ，并写下从 uuu 到 vvv 路径上的节点编号，记为序列 a1,a2⋯aka_1,a_2\\cdots a_ka1​,a2​⋯ak​ 。最后，Ember 在序列中选择一个位置 i(1≤i&lt;k)i(1\\leq i &lt; k)i(1≤i&lt;k) ，并在以下两个操作选择一个执行： 翻转 ai+1⋯aka_{i+1}\\cdots a_kai+1​⋯ak​ 并将这一段加上 aia_iai​，操作后序列变为 a1a_1a1​，⋯ai\\cdots a_i⋯ai​，ak+aia_k+a_iak​+ai​，ak−1+aia_{k-1}+a_iak−1​+ai​，⋯ai+1+ai\\cdots a_{i+1}+a_i⋯ai+1​+ai​ 取负 ai+1⋯aka_{i+1}\\cdots a_kai+1​⋯ak​ 并将这一段加上 aia_iai​，操作后序列变为 a1a_1a1​，⋯ai\\cdots a_i⋯ai​，−ai+1+ai-a_{i+1}+a_i−ai+1​+ai​，−ai+2+ai-a_{i+2}+a_i−ai+2​+ai​，⋯−ak+ai\\cdots -a_k+a_i⋯−ak​+ai​ 如果最后的序列是严格单调的，则 Ember 获胜，否则 Storm 获胜。 游戏情形可以用一个元组 (T,u,v,i,op)(T,u,v,i,op)(T,u,v,i,op) 来描述，opopop 为翻转或是取负取决于 Ember 的决策。若 Ember 和 Storm 都使用最优策略（若有多种必胜策略，任选一种执行；若必败，也任选一种执行），试统计所有可能的游戏情形的数量，并输出其取模 mmm 的结果。 Constraints 2≤n≤2002\\leq n \\leq 2002≤n≤200 ，1≤d&lt;n1 \\leq d &lt; n1≤d&lt;n ，1≤m≤2⋅1091 \\leq m \\leq 2\\cdot 10^91≤m≤2⋅109 Solution 首先，Ember 一定会构造出一棵能让自己必胜的树。而 Ember 获胜当而仅当原序列 aaa 为单调的或是单峰的；且对于每一个合法的序列，有 222 种合法的 (i,op)(i,op)(i,op) 的组合。没有什么好证明的……在草稿纸上自己模拟一下两种操作就可以得到了。 问题转换为：统计满足以下条件的树的数量 SSS ：1. 包含nnn个节点，2. 每个节点度数不超过 ddd ，3. 树上任意两个节点间路径的编号序列为单调的或单峰的。最终答案为 2⋅n⋅(n−1)⋅S2\\cdot n\\cdot(n-1)\\cdot S2⋅n⋅(n−1)⋅S 。 而对于一棵合法的树，一定存在一个特殊点，满足以这个节点为起点或终点的所有路径都是单调的。为了方便统计，我们令合法树的根节点为特殊点。观察可得，对于一棵合法树，除根节点以外的子树都满足：父亲节点编号大于儿子编号，或是父亲编号小于儿子编号。所以我们只需要统计这两种情况的答案，然后在根节点处拼起来即可。而实际上，这两种情况是等价的。 令 f(i,j)f(i,j)f(i,j) 表示节点数为 iii ，根节点度数为 jjj ，且父亲编号小于儿子编号的方案数。 枚举当前要拼接的子树大小 kkk ，钦定根节点编号最小，拼接过来的子树的根节点编号次小，可得到以下递推公式： f(i,j)=∑k=1i−1f(i−k,j−1)⋅(i−2k−1)⋅∑l=1d−1f(k,l)f(i,j)=\\sum _{k=1}^{i-1}f(i-k,j-1)\\cdot \\binom{i-2}{k-1}\\cdot \\sum _{l=1}^{d-1}f(k,l) f(i,j)=k=1∑i−1​f(i−k,j−1)⋅(k−1i−2​)⋅l=1∑d−1​f(k,l) 令 sum(i)=∑j=1d−1f(i,j)sum(i)=\\sum _{j=1}^{d-1}f(i,j)sum(i)=∑j=1d−1​f(i,j)，可得： f(i,j)=∑k=1i−1f(i−k,j−1)⋅(i−2k−1)⋅sum(k)f(i,j)=\\sum _{k=1}^{i-1}f(i-k,j-1)\\cdot \\binom{i-2}{k-1}\\cdot sum(k) f(i,j)=k=1∑i−1​f(i−k,j−1)⋅(k−1i−2​)⋅sum(k) 时间复杂度为 O(n3)O(n^{3})O(n3) ，初始化 f(1,0)=sum(1)=1f(1,0)=sum(1)=1f(1,0)=sum(1)=1 。 （这种方法是在评论区看到的……然后参考了一下wxh大爷的博客。官方题解给了另一种统计 fff 数组的方式，要稍微复杂一些，以及因为不保证 mmm 是质数，会有一些细节需要处理。详见官方题解，细节处理详见评论区。） 统计出 fff 数组后就可以开始拼接了，枚举满足父亲节点编号小于儿子编号的点数 iii 、度数 jjj , 满足父亲节点编号大于儿子编号的度数 kkk ，可得到以下公式： S=∑i=0n−1∑j=0d∑k=0d−jf(i+1,j)⋅f(n−i,k)S=\\sum _{i=0}^{n-1}\\sum _{j=0}^{d}\\sum _{k=0}^{d-j}f(i+1,j)\\cdot f(n-i,k) S=i=0∑n−1​j=0∑d​k=0∑d−j​f(i+1,j)⋅f(n−i,k) 而实际上一棵合法树是可以有多个合法根的，比如最简单的 n=2n=2n=2 的情况，合法根既可以是 111 也可以是 222 。我们可以得出另一个结论，如果一棵树有多个合法根，那么这些点一定构成一条单调链，一端是 j=1j=1j=1 且 k≠1k≠1k≠1 ，另一端是 j≠1j≠1j≠1 且 k=1k=1k=1 ，中间是 j=1j=1j=1 且 k=1k=1k=1 ，我们把这棵树放在第一种情况统计。 得到最终公式： S=∑i=0n−1∑j+k≤d,k≠1f(i+1,j)⋅f(n−i,k)S=\\sum _{i=0}^{n-1}\\sum _{j+k\\leq d,k\\neq 1}f(i+1,j)\\cdot f(n-i,k) S=i=0∑n−1​j+k≤d,k≠1∑​f(i+1,j)⋅f(n−i,k) Code 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=205;int n,d,mod;LL ans,sum[N],c[N][N],f[N][N];int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;d,&amp;mod); for(int i=0;i&lt;=n;i++)c[i][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; sum[1]=1;f[1][0]=1; for(int i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;=d;j++) for(int k=1;k&lt;i;k++) f[i][j]=(f[i][j]+f[i-k][j-1]*sum[k]%mod*c[i-2][k-1]%mod)%mod; for(int j=1;j&lt;=d-1;j++) sum[i]=(sum[i]+f[i][j])%mod; &#125; for(int i=0;i&lt;=n-1;i++) for(int j=0;j&lt;=d;j++) for(int k=0;j+k&lt;=d;k++) if(k!=1)ans=(ans+f[i+1][j]*f[n-i][k]%mod)%mod; printf(\"%lld\",2*n*(n-1)*ans%mod); return 0;&#125;","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"},{"name":"背包dp","slug":"背包dp","permalink":"http://yoursite.com/tags/背包dp/"}]},{"title":"「Codeforces 870F」Paths","slug":"cf870f","date":"2018-05-22T09:52:30.000Z","updated":"2018-05-24T13:14:01.739Z","comments":true,"path":"cf870f/","link":"","permalink":"http://yoursite.com/cf870f/","excerpt":"给定数字 nnn ，建立一个无向图。对于所有 111 到 nnn 之间的数字，当数字 gcd(u,v)≠1gcd(u,v)\\neq 1gcd(u,v)≠1 时将 uuu、vvv 连一条边，边权为 111 。d(u,v)d(u,v)d(u,v) 表示 uuu 到 vvv 的最短路，求所有 d(u,v)d(u,v)d(u,v) 的和，其中 1≤u&lt;v≤n1\\leq u &lt; v \\leq n1≤u&lt;v≤n。","text":"给定数字 nnn ，建立一个无向图。对于所有 111 到 nnn 之间的数字，当数字 gcd(u,v)≠1gcd(u,v)\\neq 1gcd(u,v)≠1 时将 uuu、vvv 连一条边，边权为 111 。d(u,v)d(u,v)d(u,v) 表示 uuu 到 vvv 的最短路，求所有 d(u,v)d(u,v)d(u,v) 的和，其中 1≤u&lt;v≤n1\\leq u &lt; v \\leq n1≤u&lt;v≤n。 Constraints $1 \\leq n \\leq 10^7 $ Solution 对于 111 以及所有大于 n2\\frac{n}{2}2n​ 的质数，与其他数字均不联通，直接剔除。 对于剩下的数字： 1.1.1. 当 gcd(u,v)≠1gcd(u,v) \\neq 1gcd(u,v)≠1 时，d(u,v)=1d(u,v)=1d(u,v)=1 。即对于数字 uuu，小于 uuu 且 d(u,v)=1d(u,v)=1d(u,v)=1 的数字个数为 x−1−φ(x)x-1-\\varphi (x)x−1−φ(x) 。 2.2.2. 令 p[u]p[u]p[u] 表示数字 uuu 的最小质因子，则当 p[u]⋅p[v]≤np[u]\\cdot p[v]\\leq np[u]⋅p[v]≤n 时，d(u,v)=2d(u,v)=2d(u,v)=2 。维护数组 numnumnum 、sumsumsum ， num[i]num[i]num[i] 代表最小质因子为 iii 的数字个数， sumsumsum 数组为 numnumnum 数组的前缀和。统计 ∑num[i]⋅sum[n/i]\\sum num[i]\\cdot sum[n/i]∑num[i]⋅sum[n/i] 可以覆盖所有 p[u]⋅p[v]≤np[u]\\cdot p[v] \\leq np[u]⋅p[v]≤n 的情况，其中减去自身与自身被统计的情况，剩下的所有数对都被统计了两次，其中包含 gcd(u,v)≠1gcd(u,v)\\neq 1gcd(u,v)≠1 的情况，需进行相应处理，详见代码。 3.3.3. 剩下的数对最短路一定为 333 ，因为 uuu → 2⋅p[u]2\\cdot p[u]2⋅p[u] → 2⋅p[v]2\\cdot p[v]2⋅p[v] → vvv 这条路一定存在。可通过数对总数减去 d(u,v)=1d(u,v)=1d(u,v)=1 与 d(u,v)=2d(u,v)=2d(u,v)=2 的情况得到。 Code 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=1e7+5;int n,m,tot,now,pri[N],p[N],phi[N],num[N],sum[N]; LL one,two,three;int main()&#123; scanf(\"%d\",&amp;n); phi[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(!p[i])&#123;p[i]=pri[++tot]=i;phi[i]=i-1;&#125; for(int j=1;j&lt;=tot;j++) &#123; if(i*pri[j]&gt;n)break; p[i*pri[j]]=pri[j]; if(i%pri[j]==0)&#123;phi[i*pri[j]]=phi[i]*pri[j];break;&#125; else phi[i*pri[j]]=phi[i]*(pri[j]-1); &#125; &#125; for(int i=2;i&lt;=n;i++)one+=i-1-phi[i]; for(int i=2;i&lt;=n;i++)num[p[i]]++; for(int i=2;i&lt;=n;i++)sum[i]=sum[i-1]+num[i]; for(int i=2;i&lt;=n;i++)two+=1ll*num[i]*sum[n/i]; for(int i=2;i&lt;=n;i++)if(1ll*p[i]*p[i]&lt;=n)two--; two=two/2-one;m=n-1; for(int i=tot;i&gt;=1;i--) if(pri[i]*2&gt;n)m--; else break; three=1ll*m*(m-1)/2-one-two; printf(\"%lld\\n\",one+two*2+three*3); return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"「ARC 063F」Snuke's Coloring 2","slug":"arc063f","date":"2018-05-22T06:22:45.000Z","updated":"2018-05-22T06:31:04.152Z","comments":true,"path":"arc063f/","link":"","permalink":"http://yoursite.com/arc063f/","excerpt":"给定一个 W×HW\\times HW×H 的二维平面，初始均为白色，有 nnn 个关键点 (xi,yi)(x_{i},y_{i})(xi​,yi​) ，对于每一个关键点选择一个方向，并将该方向上的所有网格涂成黑色。易得操作后白色部分一定是一个矩形，请最大化矩形周长。","text":"给定一个 W×HW\\times HW×H 的二维平面，初始均为白色，有 nnn 个关键点 (xi,yi)(x_{i},y_{i})(xi​,yi​) ，对于每一个关键点选择一个方向，并将该方向上的所有网格涂成黑色。易得操作后白色部分一定是一个矩形，请最大化矩形周长。 Constraints 0≤n≤2⋅1050 \\leq n \\leq 2 \\cdot 10^50≤n≤2⋅105 ，1≤w,h≤1081 \\leq w,h \\leq 10^81≤w,h≤108 Solution 观察可以得到一个性质，答案矩形一定会经过直线 x=W2x=\\frac{W}{2}x=2W​ 或 y=H2y=\\frac{H}{2}y=2H​ 。两种情况可以用相同的方式处理出答案。 将坐标离散化后，枚举矩形的上下边界，可以直接计算出矩形的左右边界。考虑用线段树进行优化。左右各开一个单调栈，在维护单调栈时在线段树上进行区间加减即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long long#define lc(x) x&lt;&lt;1#define rc(x) x&lt;&lt;1|1using namespace std;const int N=3e5+5;int w,h,n,ans,L,R;int mx[N*4],tag[N*4];struct node&#123;int x,y;node(int _x=0,int _y=0):x(_x),y(_y)&#123;&#125;;&#125;p[N],a[N],b[N]; int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void modify(int x,int l,int r,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;mx[x]+=v;tag[x]+=v;return;&#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(lc(x),l,mid,v); if(R&gt;mid)modify(rc(x),mid+1,r,v); mx[x]=max(mx[lc(x)],mx[rc(x)])+tag[x];&#125;bool cmp(node a,node b)&#123;return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);&#125;void work()&#123; memset(mx,0,sizeof(mx)); memset(tag,0,sizeof(tag)); sort(p+1,p+n+1,cmp); int l=0,r=0; for(int i=1;i&lt;=n-1;i++) &#123; if(p[i].y&lt;=h/2) &#123; int nxt=i-1; while(l&amp;&amp;a[l].y&lt;p[i].y) &#123; L=a[l].x;R=nxt;nxt=a[l].x-1; modify(1,1,n,a[l].y-p[i].y);l--; &#125; if(nxt!=i-1)a[++l]=node(nxt+1,p[i].y); &#125; else &#123; int nxt=i-1; while(r&amp;&amp;b[r].y&gt;p[i].y) &#123; L=b[r].x;R=nxt;nxt=b[r].x-1; modify(1,1,n,p[i].y-b[r].y);r--; &#125; if(nxt!=i-1)b[++r]=node(nxt+1,p[i].y); &#125; a[++l]=node(i,0);b[++r]=node(i,h); L=i;R=i;modify(1,1,n,h-p[i].x); ans=max(ans,mx[1]+p[i+1].x); &#125;&#125;int main()&#123; w=read();h=read();n=read(); for(int i=1;i&lt;=n;i++)p[i].x=read(),p[i].y=read(); p[++n]=node(0,0);p[++n]=node(w,h);work(); for(int i=1;i&lt;=n;i++)swap(p[i].x,p[i].y); swap(w,h);work(); printf(\"%d\",ans*2); return 0;&#125;","categories":[],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://yoursite.com/tags/线段树/"},{"name":"单调栈","slug":"单调栈","permalink":"http://yoursite.com/tags/单调栈/"}]},{"title":"「BZOJ 4449」[Neerc2015]Distance on Triangulation","slug":"bzoj4449","date":"2018-05-22T06:15:40.000Z","updated":"2018-05-22T12:59:37.274Z","comments":true,"path":"bzoj4449/","link":"","permalink":"http://yoursite.com/bzoj4449/","excerpt":"给定一个凸 nnn 边形，以及它的三角剖分。再给定 qqq 个询问，每个询问是一对凸多边行上的顶点 (a,b)(a,b)(a,b) ，问点 aaa 最少经过多少条边(可以是多边形上的边，也可以是剖分上的边)可以到达点 bbb 。","text":"给定一个凸 nnn 边形，以及它的三角剖分。再给定 qqq 个询问，每个询问是一对凸多边行上的顶点 (a,b)(a,b)(a,b) ，问点 aaa 最少经过多少条边(可以是多边形上的边，也可以是剖分上的边)可以到达点 bbb 。 Constraints n≤50000n \\leq 50000n≤50000 ，q≤100000q \\leq 100000q≤100000 Solution 运用分治的思想，每一次选择一条剖分边，使得凸多边形分成尽量平均的两部分。使用 bfs 得出该条边的两个端点到各个顶点的最短路，对所有的询问在两个端点处进行拼凑并更新答案。然后对两部分的信息分别划开，进行下一层的分治。 （每次分治完，点数会比原来多 222 ，所以空间要开三倍。） Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=3e5+5;const int inf=0x3f3f3f3f;int n,m,cnt,x,y,t,tmp;int first[N],ans[N],id[N];int qq[N],disx[N],disy[N],q1[N],q2[N];bool ok[N];struct node&#123;int x,y,id;&#125;l[N],q[N],h1[N],h2[N];struct edge&#123;int to,next;&#125;e[N&lt;&lt;1];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int find(int l,int r,int x)&#123;return lower_bound(id+l,id+r+1,x)-id;&#125;void bfs(int S,int pl,int pr,int *dis)&#123; int head=0,tail=0; for(int i=pl;i&lt;=pr;i++)dis[id[i]]=inf; qq[tail++]=S;dis[S]=0; while(head!=tail) &#123; int u=qq[head++]; for(int i=first[u];i;i=e[i].next) &#123; int to=e[i].to; if(!ok[to])continue; if(dis[to]==inf)dis[to]=dis[u]+1,qq[tail++]=to; &#125; &#125; &#125;void work(int dl,int dr,int pl,int pr,int ql,int qr)&#123; if(dl&gt;dr||pl&gt;pr||ql&gt;qr)return; int mn=inf,mnid=0; for(int i=dl;i&lt;=dr;i++) &#123; x=find(pl,pr,l[i].x);y=find(pl,pr,l[i].y); if(x&gt;y)swap(x,y); tmp=max(y-x,x-y+pr-pl+1); if(tmp&lt;mn)mn=tmp,mnid=i; &#125; for(int i=pl;i&lt;=pr;i++)ok[id[i]]=true; bfs(l[mnid].x,pl,pr,disx); bfs(l[mnid].y,pl,pr,disy); for(int i=pl;i&lt;=pr;i++)ok[id[i]]=false; int t1=0,t2=0,t3=0,t4=0,t5=0,t6=0; for(int i=ql;i&lt;=qr;i++) &#123; x=q[i].x;y=q[i].y;t=q[i].id; if(x==l[mnid].x&amp;&amp;y==l[mnid].y)&#123;ans[t]=1;continue;&#125; ans[t]=min(ans[t],disx[x]+disx[y]); ans[t]=min(ans[t],disy[x]+disy[y]); ans[t]=min(ans[t],disx[x]+disy[y]+1); ans[t]=min(ans[t],disy[x]+disx[y]+1); if(q[i].x&gt;l[mnid].x&amp;&amp;q[i].y&lt;l[mnid].y)h1[++t1]=q[i]; else if((q[i].x&lt;l[mnid].x||q[i].x&gt;l[mnid].y)&amp;&amp; (q[i].y&lt;l[mnid].x||q[i].y&gt;l[mnid].y))h2[++t2]=q[i]; &#125; for(int i=1;i&lt;=t1;i++)q[ql+i-1]=h1[i]; for(int i=1;i&lt;=t2;i++)q[ql+t1+i-1]=h2[i]; for(int i=pl;i&lt;=pr;i++) &#123; if(id[i]&gt;=l[mnid].x&amp;&amp;id[i]&lt;=l[mnid].y)q1[++t3]=id[i]; if(id[i]&lt;=l[mnid].x||id[i]&gt;=l[mnid].y)q2[++t4]=id[i]; &#125; for(int i=1;i&lt;=t3;i++)id[pl+i-1]=q1[i]; for(int i=1;i&lt;=t4;i++)id[pl+t3+i-1]=q2[i]; for(int i=dl;i&lt;=dr;i++) &#123; if(i==mnid)continue; if(l[i].x&gt;=l[mnid].x&amp;&amp;l[i].y&lt;=l[mnid].y)h1[++t5]=l[i]; else h2[++t6]=l[i]; &#125; for(int i=1;i&lt;=t5;i++)l[dl+i-1]=h1[i]; for(int i=1;i&lt;=t6;i++)l[dl+t5+i-1]=h2[i]; work(dl+t5,dl+t5+t6-1,pl+t3,pl+t3+t4-1,ql+t1,ql+t1+t2-1); work(dl,dl+t5-1,pl,pl+t3-1,ql,ql+t1-1); &#125;int main()&#123; n=read(); for(int i=1;i&lt;=n-3;i++) &#123; l[i].x=read();l[i].y=read(); ins(l[i].x,l[i].y);ins(l[i].y,l[i].x); if(l[i].x&gt;l[i].y)swap(l[i].x,l[i].y); &#125; for(int i=1;i&lt;n;i++)ins(i,i+1),ins(i+1,i); ins(1,n);ins(n,1); m=read(); for(int i=1;i&lt;=m;i++) &#123; q[i].x=read();q[i].y=read();q[i].id=i; if(q[i].x&gt;q[i].y)swap(q[i].x,q[i].y); ans[i]=min(q[i].y-q[i].x,q[i].x-q[i].y+n); &#125; for(int i=1;i&lt;=n;i++)id[i]=i; work(1,n-3,1,n,1,m); for(int i=1;i&lt;=m;i++)printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"分治","slug":"分治","permalink":"http://yoursite.com/tags/分治/"},{"name":"BFS","slug":"BFS","permalink":"http://yoursite.com/tags/BFS/"}]},{"title":"「BZOJ 4833」[Lydsy1704月赛]最小公倍佩尔数","slug":"bzoj4833","date":"2018-05-21T23:33:38.000Z","updated":"2018-05-22T05:20:34.646Z","comments":true,"path":"bzoj4833/","link":"","permalink":"http://yoursite.com/bzoj4833/","excerpt":"令 (1+2)n=e(n)+2⋅f(n)(1+\\sqrt 2)^n=e(n)+\\sqrt 2\\cdot f(n)(1+2​)n=e(n)+2​⋅f(n) ，其中 e(n),f(n)e(n),f(n)e(n),f(n) 都是整数，显然有 (1−2)n=e(n)−2⋅f(n)(1-\\sqrt 2)^n=e(n)-\\sqrt 2\\cdot f(n)(1−2​)n=e(n)−2​⋅f(n)。令 g(n)g(n)g(n) 表示 f(1),f(2),⋯,f(n)f(1),f(2),\\cdots ,f(n)f(1),f(2),⋯,f(n) 的最小公倍数，给定两个正整数 nnn 和 ppp ，其中 ppp 是质数，并且保证 f(1),f(2),⋯,f(n)f(1),f(2),\\cdots ,f(n)f(1),f(2),⋯,f(n) 在模 ppp 意义下均不为 000，请计算 ∑i=1ni⋅g(i)\\sum _{i=1}^{n}i\\cdot g(i)∑i=1n​i⋅g(i) 模 ppp 的值。","text":"令 (1+2)n=e(n)+2⋅f(n)(1+\\sqrt 2)^n=e(n)+\\sqrt 2\\cdot f(n)(1+2​)n=e(n)+2​⋅f(n) ，其中 e(n),f(n)e(n),f(n)e(n),f(n) 都是整数，显然有 (1−2)n=e(n)−2⋅f(n)(1-\\sqrt 2)^n=e(n)-\\sqrt 2\\cdot f(n)(1−2​)n=e(n)−2​⋅f(n)。令 g(n)g(n)g(n) 表示 f(1),f(2),⋯,f(n)f(1),f(2),\\cdots ,f(n)f(1),f(2),⋯,f(n) 的最小公倍数，给定两个正整数 nnn 和 ppp ，其中 ppp 是质数，并且保证 f(1),f(2),⋯,f(n)f(1),f(2),\\cdots ,f(n)f(1),f(2),⋯,f(n) 在模 ppp 意义下均不为 000，请计算 ∑i=1ni⋅g(i)\\sum _{i=1}^{n}i\\cdot g(i)∑i=1n​i⋅g(i) 模 ppp 的值。 Constraints T≤210T \\leq 2 ^{10}T≤210 ，1≤n≤1061\\leq n \\leq 10 ^61≤n≤106 ，2≤p≤109+72\\leq p \\leq 10 ^9 +72≤p≤109+7 Solution 在开始推导前先观察两个式子： gcd(fib(a),fib(b))=fib(gcd(a,b))gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(xa−1,xb−1)=xgcd(a,b)−1gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1 gcd(xa−1,xb−1)=xgcd(a,b)−1 形如 f(n)=a⋅f(n−1)+b⋅f(n−2)f(n)=a\\cdot f(n-1)+b\\cdot f(n-2)f(n)=a⋅f(n−1)+b⋅f(n−2) 的式子具有性质 gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y)) 。 而题目中的式子等价于： f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)f(0)=0,f(1)=1,f(n)=2f(n-1)+f(n-2)f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)，同样满足这个性质。 （以下集合 TTT 均满足 $T\\neq \\varnothing $） 再由式子： lcm(S)=∏T⊂Sgcd(T)(−1)∣T∣+1lcm(S)=\\prod_{T\\subset S}gcd(T)^{(-1)^{|T|+1}} lcm(S)=T⊂S∏​gcd(T)(−1)∣T∣+1 可以得到： g(n)=∏T⊂2[n]f(gcdi∈T(i))(−1)∣T∣+1g(n)=\\prod _{T\\subset 2^{[n]}}f(gcd_{i\\in T}(i))^{(-1)^{|T|+1}} g(n)=T⊂2[n]∏​f(gcdi∈T​(i))(−1)∣T∣+1 构造出 hhh 满足 f(n)=∏d∣nh(d)f(n)=\\prod _{d|n}h(d)f(n)=∏d∣n​h(d) 得到式子： g(n)=∏T⊂2[n](∏d∣gcdi∈T(i)h(d))(−1)∣T∣+1=∏d=1nh(d)∑T⊂2 [⌊nd⌋] (−1)∣T∣+1\\begin{aligned} g(n)&amp;=\\prod _{T\\subset 2^{[n]}}\\left ( \\prod _{d|gcd_{i\\in T}(i)}h(d) \\right )^{(-1)^{|T|+1}}\\\\ &amp;=\\prod _{d=1}^{n}h(d)^{\\sum _{T\\subset 2^{~[\\lfloor \\frac{n}{d}\\rfloor ]~}}(-1)^{|T|+1}} \\end{aligned} g(n)​=T⊂2[n]∏​⎝⎛​d∣gcdi∈T​(i)∏​h(d)⎠⎞​(−1)∣T∣+1=d=1∏n​h(d)∑T⊂2 [⌊dn​⌋] ​(−1)∣T∣+1​ 又由二项式定理可证： ∑T⊂2[⌊nd⌋](−1)∣T∣+1=−∑i=1nd(−1)i(ndi)=1\\sum _{T\\subset 2^{[\\lfloor \\frac{n}{d}\\rfloor ]}}(-1)^{|T|+1}=-\\sum _{i=1}^{\\frac{n}{d}}(-1)^i\\binom{\\frac{n}{d}}{i}=1 T⊂2[⌊dn​⌋]∑​(−1)∣T∣+1=−i=1∑dn​​(−1)i(idn​​)=1 所以 g(n)=∏d=1nh(d)g(n)=\\prod _{d=1}^{n}h(d)g(n)=∏d=1n​h(d) 问题解决，时间复杂度 O(nlogn)O(nlogn)O(nlogn)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;int T,n,mod,inv,sum,ans,f[N],h[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; T=read(); while(T--) &#123; n=read();mod=read(); f[0]=0;h[1]=f[1]=1; for(int i=2;i&lt;=n;i++) h[i]=f[i]=(1ll*f[i-1]*2+f[i-2])%mod; for(int i=1;i&lt;=n;i++) &#123; inv=power(h[i],mod-2); for(int j=i+i;j&lt;=n;j+=i)h[j]=1ll*h[j]*inv%mod; &#125; sum=1;ans=0; for(int i=1;i&lt;=n;i++) sum=1ll*sum*h[i]%mod,ans=(ans+1ll*sum*i)%mod; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"},{"name":"容斥原理","slug":"容斥原理","permalink":"http://yoursite.com/tags/容斥原理/"}]},{"title":"「BZOJ 2159」Crash的文明世界","slug":"bzoj2159","date":"2018-05-21T23:19:47.000Z","updated":"2018-05-22T12:55:09.071Z","comments":true,"path":"bzoj2159/","link":"","permalink":"http://yoursite.com/bzoj2159/","excerpt":"给定一棵 nnn 个节点的树，对于每个节点，计算出：S(i)=∑j=1ndist(i,j)k(mod10007)S(i)=\\sum _{j=1}^ndist(i,j)^k \\pmod {10007}S(i)=∑j=1n​dist(i,j)k(mod10007)。其中 dist(i,j)dist(i, j)dist(i,j) 表示第 iii 个节点到第 jjj 个节点路径上的边数，kkk 为一个常数且为正整数。","text":"给定一棵 nnn 个节点的树，对于每个节点，计算出：S(i)=∑j=1ndist(i,j)k(mod10007)S(i)=\\sum _{j=1}^ndist(i,j)^k \\pmod {10007}S(i)=∑j=1n​dist(i,j)k(mod10007)。其中 dist(i,j)dist(i, j)dist(i,j) 表示第 iii 个节点到第 jjj 个节点路径上的边数，kkk 为一个常数且为正整数。 Constraints n≤50000n \\leq 50000n≤50000 ，k≤150k \\leq 150k≤150 Solution 用结论来化简式子：xn=∑i=1nS(n,i)⋅F(x,i)x^n=\\sum _{i=1}^n S(n,i)\\cdot F(x,i)xn=∑i=1n​S(n,i)⋅F(x,i) S(n,i)S(n,i)S(n,i)为第二类斯特林数，F(x,i)=x!(x−i)!F(x,i)=\\frac{x!}{(x-i)!}F(x,i)=(x−i)!x!​ 可得： ans(i)=∑j=1ndist(i,j)m=∑j=1n∑k=1mS(m,k)⋅F(dist(i,j),k)=∑k=1mS(m,k)∑j=1nF(dist(i,j),k)=∑k=1mS(m,k)⋅k!⋅∑j=1nC(dist(i,j),k)\\begin{aligned} ans(i)&amp;=\\sum _{j=1}^ndist(i,j)^m\\\\ &amp;=\\sum_{j=1}^{n}\\sum_{k=1}^{m}S(m,k)\\cdot F(dist(i,j),k)\\\\ &amp;=\\sum_{k=1}^{m}S(m,k)\\sum_{j=1}^{n} F(dist(i,j),k)\\\\ &amp;=\\sum_{k=1}^{m}S(m,k)\\cdot k!\\cdot \\sum_{j=1}^{n} C(dist(i,j),k) \\end{aligned} ans(i)​=j=1∑n​dist(i,j)m=j=1∑n​k=1∑m​S(m,k)⋅F(dist(i,j),k)=k=1∑m​S(m,k)j=1∑n​F(dist(i,j),k)=k=1∑m​S(m,k)⋅k!⋅j=1∑n​C(dist(i,j),k)​ 根据组合数递推公式：C(n,m)=C(n−1,m)+C(n−1,m−1)C(n,m)=C(n-1,m)+C(n-1,m-1)C(n,m)=C(n−1,m)+C(n−1,m−1) 就可以很方便的对后面的部分进行树形 dp 了。 具体地，令 up(x,i)up(x,i)up(x,i) 为不在 xxx 的子树中的部分的贡献，令 dn(x,i)dn(x,i)dn(x,i) 为 xxx 的子树的贡献。特别的，dn(x,0)=1dn(x,0)=1dn(x,0)=1。 详见代码。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e4+5;const int M=155;const int mod=1e4+7;int n,m,u,v,cnt,ans,tmp;int first[N],fac[M],s[M][M];int up[N][M],dn[N][M];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void dfs1(int x,int fa)&#123; dn[x][0]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs1(to,x); Mod(dn[x][0],dn[to][0]); for(int j=1;j&lt;=m;j++) Mod(dn[x][j],(dn[to][j]+dn[to][j-1])%mod); &#125;&#125;void dfs2(int x,int fa)&#123; if(fa!=-1) &#123; up[x][0]=n-dn[x][0]; for(int i=1;i&lt;=m;i++) &#123; Mod(up[x][i],(up[fa][i]+up[fa][i-1])%mod); Mod(up[x][i],(dn[fa][i]+dn[fa][i-1])%mod); Mod(up[x][i],(2*mod-dn[x][i]-dn[x][i-1])%mod); Mod(up[x][i],(mod-dn[x][i-1])%mod); if(i!=1)Mod(up[x][i],(mod-dn[x][i-2])%mod); &#125; &#125; for(int i=first[x];i;i=e[i].next) if(e[i].to!=fa)dfs2(e[i].to,x);&#125;int main()&#123; int L,now,A,B,Q; n=read();m=read();L=read(); now=read();A=read();B=read();Q=read(); for(int i=1;i&lt;n;i++) &#123; now=(now*A+B)%Q; tmp=i&lt;L?i:L; u=i-now%tmp;v=i+1; ins(u,v);ins(v,u); &#125;// n=read();m=read();// for(int i=1;i&lt;n;i++)// &#123;// u=read();v=read();// ins(u,v);ins(v,u);// &#125; fac[0]=s[0][0]=1; for(int i=1;i&lt;=m;i++) &#123; fac[i]=fac[i-1]*i%mod; for(int j=1;j&lt;=i;j++) s[i][j]=(s[i-1][j]*j+s[i-1][j-1])%mod; &#125; dfs1(1,-1);dfs2(1,-1); for(int i=1;i&lt;=n;i++) &#123; ans=0; for(int j=1;j&lt;=m;j++) Mod(ans,s[m][j]*fac[j]%mod*(up[i][j]+dn[i][j])%mod); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"http://yoursite.com/tags/组合数学/"},{"name":"树形dp","slug":"树形dp","permalink":"http://yoursite.com/tags/树形dp/"}]},{"title":"「BZOJ 3495」PA2010 Riddle","slug":"bzoj3495","date":"2018-05-21T23:10:11.000Z","updated":"2018-05-22T05:25:06.682Z","comments":true,"path":"bzoj3495/","link":"","permalink":"http://yoursite.com/bzoj3495/","excerpt":"有 nnn 个城镇被分成了 kkk 个郡，有 mmm 条连接城镇的无向边。要求给每个郡选择一个城镇作为首都，满足每条边至少有一个端点是首都。","text":"有 nnn 个城镇被分成了 kkk 个郡，有 mmm 条连接城镇的无向边。要求给每个郡选择一个城镇作为首都，满足每条边至少有一个端点是首都。 Constraints 1≤n≤1061\\leq n \\leq 10 ^61≤n≤106 ，0≤m≤1060\\leq m \\leq 10 ^60≤m≤106 ，1≤k≤n1\\leq k \\leq n1≤k≤n Solution 每个点 xxx 拆成两对点，xxx 代表选择 xxx 为首都，x+nx+nx+n 表示不选择 xxx 为首都，x+2nx+2nx+2n 表示 xxx 的前缀已包含首都，x+3nx+3nx+3n 表示 xxx 的前缀不包含首都。 对于每一条原图中无向边 (x,y)(x,y)(x,y) ，因为至少有一个端点为首都，连边 (x+n,y)(x+n,y)(x+n,y) ，(y+n,x)(y+n,x)(y+n,x)。 对于每一个点 xxx ，连边 (x,x+2n)(x,x+2n)(x,x+2n) ，(x+3n,x+n)(x+3n,x+n)(x+3n,x+n)。 对于每一个点 xxx 与它的上一个点 lastlastlast ，连边方式如下：(last+2n,x+2n)(last+2n,x+2n)(last+2n,x+2n)，(x+3n,last+3n)(x+3n,last+3n)(x+3n,last+3n)，(last+2n,x+n)(last+2n,x+n)(last+2n,x+n)，(x,last+3n)(x,last+3n)(x,last+3n)。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=4e6+5;int n,m,k,cnt,x,y,last,tim,top,color;int first[N],dfn[N],low[N],sta[N],c[N];bool vis[N];struct edge&#123;int to,next;&#125;e[N*3];void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++tim; sta[++top]=x;vis[x]=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!dfn[to])tarjan(to),low[x]=min(low[x],low[to]=min(low[x],low[to])); else if(vis[to])low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; color++; while(sta[top]!=x)vis[sta[top]]=false,c[sta[top--]]=color; vis[x]=false;c[x]=color;top--; &#125;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) if(c[i]==c[i+n]||c[i+2*n]==c[i+3*n])return false; return true;&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=m;i++) &#123; x=read();y=read(); ins(x+n,y);ins(y+n,x); &#125; for(int i=1;i&lt;=k;i++) &#123; x=read();last=0; for(int j=1;j&lt;=x;j++) &#123; y=read(); ins(y,y+2*n);ins(y+3*n,y+n); if(last) &#123; ins(last+2*n,y+2*n); ins(y+3*n,last+3*n); ins(last+2*n,y+n); ins(y,last+3*n); &#125; last=y; &#125; &#125; for(int i=1;i&lt;=4*n;i++)if(!dfn[i])tarjan(i); if(check())printf(\"TAK\"); else printf(\"NIE\"); return 0;&#125;","categories":[],"tags":[{"name":"2-SAT","slug":"2-SAT","permalink":"http://yoursite.com/tags/2-SAT/"},{"name":"tarjan","slug":"tarjan","permalink":"http://yoursite.com/tags/tarjan/"}]},{"title":"「Codeforces 983E」NN country","slug":"cf983e","date":"2018-05-21T08:56:27.000Z","updated":"2018-05-22T12:57:21.647Z","comments":true,"path":"cf983e/","link":"","permalink":"http://yoursite.com/cf983e/","excerpt":"给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。","text":"给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。 Constraints 2≤n≤2⋅1052\\leq n \\leq 2\\cdot 10 ^52≤n≤2⋅105 ，1≤m≤2⋅1051\\leq m \\leq 2\\cdot 10 ^51≤m≤2⋅105 ，1≤q≤2⋅1051\\leq q \\leq 2\\cdot 10 ^51≤q≤2⋅105 Solution 对于每一条 aaa 与 bbb 间的路径，都可拆分为 aaa 到 lcalcalca 的路径和 bbb 到 lcalcalca 的路径 采用贪心策略， low[x][i]low[x][i]low[x][i] 表示从 xxx 点出发向上选择不超过 2i2^i2i 条链可抵达的深度最浅的点。这时对于每一个询问可将询问的两个端点修改为利用贪心策略跳到的深度大于 lcalcalca 且深度最小的节点，并记录下答案，这个过程可以用倍增完成。注意特判端点即 lcalcalca 的情况。 然后出现两种情况。若修改后的两个端点出现在同一条给定链上，答案为原答案 +1+1+1 ，否则答案为原答案 +2+2+2 。问题模型转换为，每次询问一个点对是否出现在同一条给定链上。记录下 dfs 序，在深搜过程中利用树状数组统计即可。 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int n,m,Q,cnt,val,x,y,ind;int deep[N],in[N],out[N],last[N];int first[N],ans[N],tr[N];int fa[N][20],low[N][20];bool ok[N];vector&lt;int&gt; a[N],b[N];struct edge&#123;int to,next;&#125;e[N];struct chain&#123;int x,y,t;&#125;c[N],q[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x)&#123; in[x]=++ind; for(int i=1;(1&lt;&lt;i)&lt;=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=first[x];i;i=e[i].next) &#123; deep[e[i].to]=deep[x]+1; dfs(e[i].to); &#125; out[x]=ind;&#125;int lca(int x,int y)&#123; if(deep[x]&lt;deep[y])swap(x,y); int d=deep[x]-deep[y]; for(int i=0;(1&lt;&lt;i)&lt;=d;i++) if((1&lt;&lt;i)&amp;d)x=fa[x][i]; if(x==y)return x; for(int i=17;i&gt;=0;i--) if((1&lt;&lt;i)&lt;=deep[x]&amp;&amp;fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfslow(int x)&#123; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to;dfslow(to); if(deep[low[to][0]]&lt;deep[low[x][0]]) low[x][0]=low[to][0]; &#125;&#125;int find(int x,int t)&#123; if(deep[low[x][17]]&gt;deep[t])&#123;val=-inf;return -1;&#125; if(x==t)&#123;val=-1;return 0;&#125; val=0; for(int i=17;i&gt;=0;i--) if(deep[low[x][i]]&gt;deep[t]) x=low[x][i],val|=(1&lt;&lt;i); return x;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x))tr[x]+=v;&#125;int query(int x)&#123;int ans=0;for(;x;x-=lowbit(x))ans+=tr[x];return ans;&#125;void work(int x)&#123; for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; last[t]=query(out[q[t].y])-query(in[q[t].y]-1); &#125; for(int sz=a[x].size(),i=0;i&lt;sz;i++)add(in[a[x][i]],1); for(int i=first[x];i;i=e[i].next)work(e[i].to); for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; if(query(out[q[t].y])-query(in[q[t].y]-1)!=last[t])ok[t]=true; &#125;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) fa[i][0]=read(),ins(fa[i][0],i); dfs(1); for(int i=1;i&lt;=n;i++)low[i][0]=i; m=read(); for(int i=1;i&lt;=m;i++) &#123; c[i].x=read();c[i].y=read(); c[i].t=lca(c[i].x,c[i].y); if(deep[c[i].t]&lt;deep[low[c[i].x][0]]) low[c[i].x][0]=c[i].t; if(deep[c[i].t]&lt;deep[low[c[i].y][0]]) low[c[i].y][0]=c[i].t; a[c[i].x].push_back(c[i].y); a[c[i].y].push_back(c[i].x); &#125; dfslow(1); for(int t=1;t&lt;=n;t++) for(int i=1;i&lt;=17;i++) low[t][i]=low[low[t][i-1]][i-1]; Q=read(); for(int i=1;i&lt;=Q;i++) &#123; q[i].x=read();q[i].y=read(); q[i].t=lca(q[i].x,q[i].y); ans[i]=2; x=find(q[i].x,q[i].t);ans[i]+=val; y=find(q[i].y,q[i].t);ans[i]+=val; if(x&gt;0&amp;&amp;y&gt;0) &#123; q[i].x=x;q[i].y=y; b[x].push_back(i); &#125; &#125; work(1); for(int i=1;i&lt;=Q;i++) if(ok[i])ans[i]--; for(int i=1;i&lt;=Q;i++) printf(\"%d\\n\",ans[i]&lt;0?-1:ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"},{"name":"最近公共祖先","slug":"最近公共祖先","permalink":"http://yoursite.com/tags/最近公共祖先/"},{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"}]}]}