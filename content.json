{"meta":{"title":"Zsnuo's Blog","subtitle":"Living is do or die.","description":null,"author":"Zsnuo","url":"http://yoursite.com"},"pages":[{"title":"Links","date":"2018-05-20T12:53:14.000Z","updated":"2018-05-21T06:22:47.000Z","comments":false,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":"「 onion_cyc 」 世界上最可爱的男孩子。 「 Sakits 」 TJM是机房的红太阳！ 「 Blue233333 」 林队队是机房的蓝月亮！ 「 Child-Single 」沉迷讲师的LJK。 「 Cholorop 」Duck Game高玩杜老师。 「 orzccz 」日常qwq的YY。 「 L_0_Forever_LF 」根本无法同台竞技的LCD。 「 cgh_Andy 」跟名字完全不符合的菜菜。 「 Ra1nbow 」跟栋栋给给的CYS。"},{"title":"Tags","date":"2018-05-20T12:50:26.000Z","updated":"2018-05-20T12:52:13.989Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2018-05-20T12:53:14.000Z","updated":"2018-05-21T08:41:04.358Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"高二，一只即将退役的OIer，坐标东南沿海某偏远山区学校。 现在已经跟妹子过上了幸福快乐的生活。 现博客搭建于2018年5月20日，初衷是想要有一个实用好看的区域可以给自己记录。 以及一只旧的Zsnuo，有一些东西应该还是会放在旧博客。 以上。"}],"posts":[{"title":"「Codeforces 983E」NN country","slug":"cf983E","date":"2018-05-21T08:56:27.000Z","updated":"2018-05-21T13:58:02.223Z","comments":true,"path":"2018/05/21/cf983E/","link":"","permalink":"http://yoursite.com/2018/05/21/cf983E/","excerpt":"Description 给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。","text":"Description 给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。 Solution 对于每一条 aaa 与 bbb 间的路径，都可拆分为 aaa 到 lcalcalca 的路径和 bbb 到 lcalcalca 的路径 采用贪心策略， low[x][i]low[x][i]low[x][i] 表示从 xxx 点出发向上选择不超过 2i2^i2i 条链可抵达的深度最浅的点。这时对于每一个询问可将询问的两个端点修改为利用贪心策略跳到的深度大于 lcalcalca 且深度最小的节点，并记录下答案，这个过程可以用倍增完成。注意特判端点即 lcalcalca 的情况。 然后出现两种情况。若修改后的两个端点出现在同一条给定链上，答案为原答案 +1+1+1 ，否则答案为原答案 +2+2+2 。问题模型转换为，每次询问一个点对是否出现在同一条给定链上。记录下 dfsdfsdfs 序，在深搜过程中利用树状数组统计即可。 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int n,m,Q,cnt,val,x,y,ind;int deep[N],in[N],out[N],last[N];int first[N],ans[N],tr[N];int fa[N][20],low[N][20];bool ok[N];vector&lt;int&gt; a[N],b[N];struct edge&#123;int to,next;&#125;e[N];struct chain&#123;int x,y,t;&#125;c[N],q[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x)&#123; in[x]=++ind; for(int i=1;(1&lt;&lt;i)&lt;=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=first[x];i;i=e[i].next) &#123; deep[e[i].to]=deep[x]+1; dfs(e[i].to); &#125; out[x]=ind;&#125;int lca(int x,int y)&#123; if(deep[x]&lt;deep[y])swap(x,y); int d=deep[x]-deep[y]; for(int i=0;(1&lt;&lt;i)&lt;=d;i++) if((1&lt;&lt;i)&amp;d)x=fa[x][i]; if(x==y)return x; for(int i=17;i&gt;=0;i--) if((1&lt;&lt;i)&lt;=deep[x]&amp;&amp;fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfslow(int x)&#123; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to;dfslow(to); if(deep[low[to][0]]&lt;deep[low[x][0]]) low[x][0]=low[to][0]; &#125;&#125;int find(int x,int t)&#123; if(deep[low[x][17]]&gt;deep[t])&#123;val=-inf;return -1;&#125; if(x==t)&#123;val=-1;return 0;&#125; val=0; for(int i=17;i&gt;=0;i--) if(deep[low[x][i]]&gt;deep[t]) x=low[x][i],val|=(1&lt;&lt;i); return x;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x))tr[x]+=v;&#125;int query(int x)&#123;int ans=0;for(;x;x-=lowbit(x))ans+=tr[x];return ans;&#125;void work(int x)&#123; for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; last[t]=query(out[q[t].y])-query(in[q[t].y]-1); &#125; for(int sz=a[x].size(),i=0;i&lt;sz;i++)add(in[a[x][i]],1); for(int i=first[x];i;i=e[i].next)work(e[i].to); for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; if(query(out[q[t].y])-query(in[q[t].y]-1)!=last[t])ok[t]=true; &#125;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) fa[i][0]=read(),ins(fa[i][0],i); dfs(1); for(int i=1;i&lt;=n;i++)low[i][0]=i; m=read(); for(int i=1;i&lt;=m;i++) &#123; c[i].x=read();c[i].y=read(); c[i].t=lca(c[i].x,c[i].y); if(deep[c[i].t]&lt;deep[low[c[i].x][0]]) low[c[i].x][0]=c[i].t; if(deep[c[i].t]&lt;deep[low[c[i].y][0]]) low[c[i].y][0]=c[i].t; a[c[i].x].push_back(c[i].y); a[c[i].y].push_back(c[i].x); &#125; dfslow(1); for(int t=1;t&lt;=n;t++) for(int i=1;i&lt;=17;i++) low[t][i]=low[low[t][i-1]][i-1]; Q=read(); for(int i=1;i&lt;=Q;i++) &#123; q[i].x=read();q[i].y=read(); q[i].t=lca(q[i].x,q[i].y); ans[i]=2; x=find(q[i].x,q[i].t);ans[i]+=val; y=find(q[i].y,q[i].t);ans[i]+=val; if(x&gt;0&amp;&amp;y&gt;0) &#123; q[i].x=x;q[i].y=y; b[x].push_back(i); &#125; &#125; work(1); for(int i=1;i&lt;=Q;i++) if(ok[i])ans[i]--; for(int i=1;i&lt;=Q;i++) printf(\"%d\\n\",ans[i]&lt;0?-1:ans[i]); return 0;&#125;","categories":[],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://yoursite.com/tags/树状数组/"},{"name":"倍增","slug":"倍增","permalink":"http://yoursite.com/tags/倍增/"},{"name":"最近公共祖先","slug":"最近公共祖先","permalink":"http://yoursite.com/tags/最近公共祖先/"}]}]}