<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「HDU 5632」Rikka with Array]]></title>
    <url>%2F2018%2F05%2F22%2Fhdu5632%2F</url>
    <content type="text"><![CDATA[给定一个数 nnn ，问有多少个数对 (i,j)(i,j)(i,j) ，满足 1≤i&lt;j≤n1\leq i&lt;j \leq n1≤i&lt;j≤n 且 f[i]&gt;f[j]f[i]&gt;f[j]f[i]&gt;f[j] ，f[x]f[x]f[x] 为 xxx 二进制表示下 111 的个数。 Constraints n≤10300n \leq 10^{300}n≤10300 Solution （在打模拟赛时写到的题目……好像写了一种跟所有人都不一样的写法） 首先考虑一个数 xxx ，我们需要统计满足 1≤i&lt;x1\leq i&lt;x1≤i&lt;x 且 f[i]&gt;f[x]f[i]&gt;f[x]f[i]&gt;f[x] 的 iii 的个数。考虑数位 dpdpdp ，将 xxx 转为二进制形式，从低位往高位推。假设当前在第 iii 位，从第 111 位到第 iii 位共有 kkk 个 111 ：若当前位为 000 ，则直接跳过进行下一位的统计；否则钦定当前要统计进答案的数字的比第 iii 位高的位置与 xxx 相同，且第 iii 位为 000 ，则此时最低的第 i−1i-1i−1 位至少要有 k+1k+1k+1 个 111 ，可任意选取，即需要统计进答案里的方案数为 ∑j=k+1i−1(i−1j)\sum _{j=k+1}^{i-1} \binom{i-1}{j}∑j=k+1i−1​(ji−1​) ，令 s(i,j)=∑d=0j(id)s(i,j)=\sum _{d=0}^{j}\binom{i}{d}s(i,j)=∑d=0j​(di​) ，则公式简化为 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 。 现在我们需要统计总答案，且因为 nnn 很大，无法直接枚举。考虑将 nnn 转成二进制形式，共有 cntcntcnt 位，aia_{i}ai​ 为 nnn 在二进制下第 iii 位上的数字。统计每一个 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 被统计进答案的贡献。若 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 会在数字 xxx 时被统计进答案里， xxx 需要满足以下几个条件：1. 1≤x≤n1\leq x\leq n1≤x≤n ，2. xxx 的第 iii 位为 111 ，3. xxx 的前 iii 位恰好有 kkk 个 111 。答案转化为统计满足条件的 xxx 的个数。 我们递推一个数组 fff ，f(i,j)f(i,j)f(i,j) 表示数值小于等于 nnn 最低的 iii 位，且二进制下恰好含有 jjj 个 111 的数字的方案数。可得： f(i,j)={f(i−1,j) (ai=0)f(i−1,j−1)+(i−1j) (ai=1)f(i,j)=\begin{cases}f(i-1,j)~~~~~~~~~~~~~~~~~~~~~~~(a_{i}=0)\\f(i-1,j-1)+\binom{i-1}{j}~~~(a_{i}=1)\end{cases} f(i,j)={f(i−1,j) (ai​=0)f(i−1,j−1)+(ji−1​) (ai​=1)​ 特殊的，f(i,0)=1(0≤i≤cnt)f(i,0)=1(0\leq i\leq cnt)f(i,0)=1(0≤i≤cnt) 。然后就可以数位 dpdpdp 出对于每一个 (i−1,k)(i-1,k)(i−1,k) 的组合，所有符合条件的数 xxx 了。 枚举当前在第 iii 位，前 i−1i-1i−1 位总共有 kkk 个 111 ，我们令 num=∑d=i+1cnt2d−(i+1)⋅adnum=\sum _{d=i+1}^{cnt} 2^{d-(i+1)}\cdot a_{d}num=∑d=i+1cnt​2d−(i+1)⋅ad​ ，即大于第 iii 位的部分的 000 到 num−1num-1num−1 的方案，则 s(i−1,i−1)−s(i−1,k+1)s(i-1,i-1)-s(i-1,k+1)s(i−1,i−1)−s(i−1,k+1) 的系数 ttt 计算方式如下： t={num⋅(i−1k) (ai=0)num⋅(i−1k)+f(i−1,k) (ai=1)t=\begin{cases}num\cdot \binom{i-1}{k}~~~~~~~~~~~~~~~~~~~~~~~~~(a_{i}=0)\\num\cdot \binom{i-1}{k}+f(i-1,k)~~~(a_{i}=1)\end{cases} t={num⋅(ki−1​) (ai​=0)num⋅(ki−1​)+f(i−1,k) (ai​=1)​ 然后就可以得到最终的答案了。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e3+5;const int mod=998244353;int T,n,cnt,ans,tmp,num,now,t;int x[N],a[N],C[N][N],s[N][N],f[N][N];char ch[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;int main()&#123; for(int i=0;i&lt;=1000;i++)C[i][0]=1; for(int i=1;i&lt;=1000;i++) for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; for(int i=0;i&lt;=1000;i++) for(int j=0;j&lt;=1000;j++) if(j)s[i][j]=(s[i][j-1]+C[i][j])%mod; else s[i][j]=C[i][j]; T=read(); while(T--) &#123; cnt=ans=0; scanf("%s",ch+1); n=strlen(ch+1); for(int i=1;i&lt;=n;i++)x[n-i+1]=ch[i]-'0'; if(n==1&amp;&amp;(x[1]==0||x[1]==1))&#123;printf("0\n");continue;&#125; while(n) &#123; if(x[1]&amp;1)a[++cnt]=1,x[1]--; else a[++cnt]=0; for(int i=n;i&gt;=1;i--) if(x[i]&amp;1)x[i]/=2,x[i-1]+=10; else x[i]/=2; while(n&amp;&amp;x[n]==0)n--; &#125; memset(f,0,sizeof(f)); for(int i=0;i&lt;=cnt;i++)f[i][0]=1; for(int j=1;j&lt;=cnt;j++) for(int i=j;i&lt;=cnt;i++) if(!a[i])Mod(f[i][j],f[i-1][j]); else &#123; Mod(f[i][j],f[i-1][j-1]); Mod(f[i][j],C[i-1][j]); &#125; for(int i=1;i&lt;=cnt;i++) &#123; num=0; for(int j=cnt;j&gt;i;j--)num=(num*2+a[j])%mod; for(int j=0;j&lt;i;j++) &#123; t=1ll*num*C[i-1][j]%mod; Mod(ans,1ll*(s[i-1][i-1]-s[i-1][j+1]+mod)%mod*t%mod); if(!a[i])continue; Mod(ans,1ll*(s[i-1][i-1]-s[i-1][j+1]+mod)%mod*f[i-1][j]%mod); &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 914H」Ember and Storm's Tree Game]]></title>
    <url>%2F2018%2F05%2F22%2Fcf914h%2F</url>
    <content type="text"><![CDATA[Ember 和 Storm 正在玩游戏。首先，Ember 构造一棵 nnn 个节点且每个节点度数不超过 ddd 的带节点编号的树 TTT 。然后，Storm 选择两个不同的节点 uuu 和 vvv ，并写下从 uuu 到 vvv 路径上的节点编号，记为序列 a1,a2⋯aka_1,a_2\cdots a_ka1​,a2​⋯ak​ 。最后，Ember 在序列中选择一个位置 i(1≤i&lt;k)i(1\leq i &lt; k)i(1≤i&lt;k) ，并在以下两个操作选择一个执行： 翻转 ai+1⋯aka_{i+1}\cdots a_kai+1​⋯ak​ 并将这一段加上 aia_iai​，操作后序列变为 a1a_1a1​，⋯ai\cdots a_i⋯ai​，ak+aia_k+a_iak​+ai​，ak−1+aia_{k-1}+a_iak−1​+ai​，⋯ai+1+ai\cdots a_{i+1}+a_i⋯ai+1​+ai​ 取负 ai+1⋯aka_{i+1}\cdots a_kai+1​⋯ak​ 并将这一段加上 aia_iai​，操作后序列变为 a1a_1a1​，⋯ai\cdots a_i⋯ai​，−ai+1+ai-a_{i+1}+a_i−ai+1​+ai​，−ai+2+ai-a_{i+2}+a_i−ai+2​+ai​，⋯−ak+ai\cdots -a_k+a_i⋯−ak​+ai​ 如果最后的序列是严格单调的，则 Ember 获胜，否则 Storm 获胜。 游戏情形可以用一个元组 (T,u,v,i,op)(T,u,v,i,op)(T,u,v,i,op) 来描述，opopop 为翻转或是取负取决于 Ember 的决策。若 Ember 和 Storm 都使用最优策略（若有多种必胜策略，任选一种执行；若必败，也任选一种执行），试统计所有可能的游戏情形的数量，并输出其取模 mmm 的结果。 Constraints 2≤n≤2002\leq n \leq 2002≤n≤200 ，1≤d&lt;n1 \leq d &lt; n1≤d&lt;n ，1≤m≤2⋅1091 \leq m \leq 2\cdot 10^91≤m≤2⋅109 Solution 首先，Ember 一定会构造出一棵能让自己必胜的树。而 Ember 获胜当而仅当原序列 aaa 为单调的或是单峰的；且对于每一个合法的序列，有2种合法的 (i,op)(i,op)(i,op) 的组合。没有什么好证明的……在草稿纸上自己模拟一下两种操作就可以得到了。 问题转换为：统计满足以下条件的树的数量 SSS ：1. 包含nnn个节点，2. 每个节点度数不超过 ddd ，3. 树上任意两个节点间路径的编号序列为单调的或单峰的。最终答案为 2⋅n⋅(n−1)⋅S2\cdot n\cdot(n-1)\cdot S2⋅n⋅(n−1)⋅S 。 而对于一棵合法的树，一定存在一个特殊点，满足以这个节点为起点或终点的所有路径都是单调的。为了方便统计，我们令合法树的根节点为特殊点。观察可得，对于一棵合法树，除根节点以外的子树都满足：父亲节点编号大于儿子编号，或是父亲编号小于儿子编号。所以我们只需要统计这两种情况的答案，然后在根节点处拼起来即可。而实际上，这两种情况是等价的。 令 f(i,j)f(i,j)f(i,j) 表示节点数为 iii ，根节点度数为 jjj ，且父亲编号小于儿子编号的方案数。 枚举当前要拼接的子树大小 kkk ，钦定根节点编号最小，拼接过来的子树的根节点编号次小，可得到以下递推公式： f(i,j)=∑k=1i−1f(i−k,j−1)⋅(i−2k−1)⋅∑l=1d−1f(k,l)f(i,j)=\sum _{k=1}^{i-1}f(i-k,j-1)\cdot \binom{i-2}{k-1}\cdot \sum _{l=1}^{d-1}f(k,l) f(i,j)=k=1∑i−1​f(i−k,j−1)⋅(k−1i−2​)⋅l=1∑d−1​f(k,l) 令 sum(i)=∑j=1d−1f(i,j)sum(i)=\sum _{j=1}^{d-1}f(i,j)sum(i)=∑j=1d−1​f(i,j)，可得： f(i,j)=∑k=1i−1f(i−k,j−1)⋅(i−2k−1)⋅sum(k)f(i,j)=\sum _{k=1}^{i-1}f(i-k,j-1)\cdot \binom{i-2}{k-1}\cdot sum(k) f(i,j)=k=1∑i−1​f(i−k,j−1)⋅(k−1i−2​)⋅sum(k) 时间复杂度为 O(n3)O(n^{3})O(n3) ，初始化 f(1,0)=sum(1)=1f(1,0)=sum(1)=1f(1,0)=sum(1)=1 。 （这种方法是在评论区看到的……然后参考了一下wxh大爷的博客。官方题解给了另一种统计 fff 数组的方式，要稍微复杂一些，以及因为不保证 mmm 是质数，会有一些细节需要处理。详见官方题解，细节处理详见评论区。） 统计出 fff 数组后就可以开始拼接了，枚举满足父亲节点编号小于儿子编号的点数 iii 、度数 jjj , 满足父亲节点编号大于儿子编号的度数 kkk ，可得到以下公式： S=∑i=0n−1∑j=0d∑k=0d−jf(i+1,j)⋅f(n−i,k)S=\sum _{i=0}^{n-1}\sum _{j=0}^{d}\sum _{k=0}^{d-j}f(i+1,j)\cdot f(n-i,k) S=i=0∑n−1​j=0∑d​k=0∑d−j​f(i+1,j)⋅f(n−i,k) 而实际上一棵合法树是可以有多个合法根的，比如最简单的 n=2n=2n=2 的情况，合法根既可以是 111 也可以是 222 。我们可以得出另一个结论，如果一棵树有多个合法根，那么这些点一定构成一条单调链，一端是 j=1j=1j=1 且 k≠1k≠1k≠1 ，另一端是 j≠1j≠1j≠1 且 k=1k=1k=1 ，中间是 j=1j=1j=1 且 k=1k=1k=1 ，我们把这棵树放在第一种情况统计。 得到最终公式： S=∑i=0n−1∑j+k≤d,k≠1f(i+1,j)⋅f(n−i,k)S=\sum _{i=0}^{n-1}\sum _{j+k\leq d,k\neq 1}f(i+1,j)\cdot f(n-i,k) S=i=0∑n−1​j+k≤d,k≠1∑​f(i+1,j)⋅f(n−i,k) Code 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=205;int n,d,mod;LL ans,sum[N],c[N][N],f[N][N];int main()&#123; scanf("%d%d%d",&amp;n,&amp;d,&amp;mod); for(int i=0;i&lt;=n;i++)c[i][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; sum[1]=1;f[1][0]=1; for(int i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;=d;j++) for(int k=1;k&lt;i;k++) f[i][j]=(f[i][j]+f[i-k][j-1]*sum[k]%mod*c[i-2][k-1]%mod)%mod; for(int j=1;j&lt;=d-1;j++) sum[i]=(sum[i]+f[i][j])%mod; &#125; for(int i=0;i&lt;=n-1;i++) for(int j=0;j&lt;=d;j++) for(int k=0;j+k&lt;=d;k++) if(k!=1)ans=(ans+f[i+1][j]*f[n-i][k]%mod)%mod; printf("%lld",2*n*(n-1)*ans%mod); return 0;&#125;]]></content>
      <tags>
        <tag>背包dp</tag>
        <tag>排列组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 870F」Paths]]></title>
    <url>%2F2018%2F05%2F22%2Fcf870f%2F</url>
    <content type="text"><![CDATA[给定数字 nnn ，建立一个无向图。对于所有 111 到 nnn 之间的数字，当数字 gcd(u,v)≠1gcd(u,v)\neq 1gcd(u,v)≠1 时将 uuu、vvv 连一条边，边权为 111 。d(u,v)d(u,v)d(u,v) 表示 uuu 到 vvv 的最短路，求所有 d(u,v)d(u,v)d(u,v) 的和，其中 1≤u&lt;v≤n1\leq u &lt; v \leq n1≤u&lt;v≤n。 Constraints $1 \leq n \leq 10^7 $ Solution 对于 111 以及所有大于 n2\frac{n}{2}2n​ 的质数，与其他数字均不联通，直接剔除。 对于剩下的数字： 1.1.1. 当 gcd(u,v)≠1gcd(u,v) \neq 1gcd(u,v)≠1 时，d(u,v)=1d(u,v)=1d(u,v)=1 。即对于数字 uuu，小于 uuu 且 d(u,v)=1d(u,v)=1d(u,v)=1 的数字个数为 x−1−φ(x)x-1-\varphi (x)x−1−φ(x) 。 2.2.2. 令 p[u]p[u]p[u] 表示数字 uuu 的最小质因子，则当 p[u]⋅p[v]≤np[u]\cdot p[v]\leq np[u]⋅p[v]≤n 时，d(u,v)=2d(u,v)=2d(u,v)=2 。维护数组 numnumnum 、sumsumsum ， num[i]num[i]num[i] 代表最小质因子为 iii 的数字个数， sumsumsum 数组为 numnumnum 数组的前缀和。统计 ∑num[i]⋅sum[n/i]\sum num[i]\cdot sum[n/i]∑num[i]⋅sum[n/i] 可以覆盖所有 p[u]⋅p[v]≤np[u]\cdot p[v] \leq np[u]⋅p[v]≤n 的情况，其中减去自身与自身被统计的情况，剩下的所有数对都被统计了两次，其中包含 gcd(u,v)≠1gcd(u,v)\neq 1gcd(u,v)≠1 的情况，需进行相应处理，详见代码。 3.3.3. 剩下的数对最短路一定为 333 ，因为 uuu → 2⋅p[u]2\cdot p[u]2⋅p[u] → 2⋅p[v]2\cdot p[v]2⋅p[v] → vvv 这条路一定存在。可通过数对总数减去 d(u,v)=1d(u,v)=1d(u,v)=1 与 d(u,v)=2d(u,v)=2d(u,v)=2 的情况得到。 Code 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=1e7+5;int n,m,tot,now,pri[N],p[N],phi[N],num[N],sum[N]; LL one,two,three;int main()&#123; scanf("%d",&amp;n); phi[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(!p[i])&#123;p[i]=pri[++tot]=i;phi[i]=i-1;&#125; for(int j=1;j&lt;=tot;j++) &#123; if(i*pri[j]&gt;n)break; p[i*pri[j]]=pri[j]; if(i%pri[j]==0)&#123;phi[i*pri[j]]=phi[i]*pri[j];break;&#125; else phi[i*pri[j]]=phi[i]*(pri[j]-1); &#125; &#125; for(int i=2;i&lt;=n;i++)one+=i-1-phi[i]; for(int i=2;i&lt;=n;i++)num[p[i]]++; for(int i=2;i&lt;=n;i++)sum[i]=sum[i-1]+num[i]; for(int i=2;i&lt;=n;i++)two+=1ll*num[i]*sum[n/i]; for(int i=2;i&lt;=n;i++)if(1ll*p[i]*p[i]&lt;=n)two--; two=two/2-one;m=n-1; for(int i=tot;i&gt;=1;i--) if(pri[i]*2&gt;n)m--; else break; three=1ll*m*(m-1)/2-one-two; printf("%lld\n",one+two*2+three*3); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ARC 063F」Snuke's Coloring 2]]></title>
    <url>%2F2018%2F05%2F22%2Farc063f%2F</url>
    <content type="text"><![CDATA[给定一个 W×HW\times HW×H 的二维平面，初始均为白色，有 nnn 个关键点 (xi,yi)(x_{i},y_{i})(xi​,yi​) ，对于每一个关键点选择一个方向，并将该方向上的所有网格涂成黑色。易得操作后白色部分一定是一个矩形，请最大化矩形周长。 Constraints 0≤n≤2⋅1050 \leq n \leq 2 \cdot 10^50≤n≤2⋅105 ，1≤w,h≤1081 \leq w,h \leq 10^81≤w,h≤108 Solution 观察可以得到一个性质，答案矩形一定会经过直线 x=W2x=\frac{W}{2}x=2W​ 或 y=H2y=\frac{H}{2}y=2H​ 。两种情况可以用相同的方式处理出答案。 将坐标离散化后，枚举矩形的上下边界，可以直接计算出矩形的左右边界。考虑用线段树进行优化。左右各开一个单调栈，在维护单调栈时在线段树上进行区间加减即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long long#define lc(x) x&lt;&lt;1#define rc(x) x&lt;&lt;1|1using namespace std;const int N=3e5+5;int w,h,n,ans,L,R;int mx[N*4],tag[N*4];struct node&#123;int x,y;node(int _x=0,int _y=0):x(_x),y(_y)&#123;&#125;;&#125;p[N],a[N],b[N]; int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void modify(int x,int l,int r,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;mx[x]+=v;tag[x]+=v;return;&#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(lc(x),l,mid,v); if(R&gt;mid)modify(rc(x),mid+1,r,v); mx[x]=max(mx[lc(x)],mx[rc(x)])+tag[x];&#125;bool cmp(node a,node b)&#123;return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);&#125;void work()&#123; memset(mx,0,sizeof(mx)); memset(tag,0,sizeof(tag)); sort(p+1,p+n+1,cmp); int l=0,r=0; for(int i=1;i&lt;=n-1;i++) &#123; if(p[i].y&lt;=h/2) &#123; int nxt=i-1; while(l&amp;&amp;a[l].y&lt;p[i].y) &#123; L=a[l].x;R=nxt;nxt=a[l].x-1; modify(1,1,n,a[l].y-p[i].y);l--; &#125; if(nxt!=i-1)a[++l]=node(nxt+1,p[i].y); &#125; else &#123; int nxt=i-1; while(r&amp;&amp;b[r].y&gt;p[i].y) &#123; L=b[r].x;R=nxt;nxt=b[r].x-1; modify(1,1,n,p[i].y-b[r].y);r--; &#125; if(nxt!=i-1)b[++r]=node(nxt+1,p[i].y); &#125; a[++l]=node(i,0);b[++r]=node(i,h); L=i;R=i;modify(1,1,n,h-p[i].x); ans=max(ans,mx[1]+p[i+1].x); &#125;&#125;int main()&#123; w=read();h=read();n=read(); for(int i=1;i&lt;=n;i++)p[i].x=read(),p[i].y=read(); p[++n]=node(0,0);p[++n]=node(w,h);work(); for(int i=1;i&lt;=n;i++)swap(p[i].x,p[i].y); swap(w,h);work(); printf("%d",ans*2); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4449」[Neerc2015]Distance on Triangulation]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj4449%2F</url>
    <content type="text"><![CDATA[给定一个凸 nnn 边形，以及它的三角剖分。再给定 qqq 个询问，每个询问是一对凸多边行上的顶点 (a,b)(a,b)(a,b) ，问点 aaa 最少经过多少条边(可以是多边形上的边，也可以是剖分上的边)可以到达点 bbb 。 Constraints n≤50000n \leq 50000n≤50000 ，q≤100000q \leq 100000q≤100000 Solution 运用分治的思想，每一次选择一条剖分边，使得凸多边形分成尽量平均的两部分。使用 bfsbfsbfs 得出该条边的两个端点到各个顶点的最短路，对所有的询问在两个端点处进行拼凑并更新答案。然后对两部分的信息分别划开，进行下一层的分治。 （每次分治完，点数会比原来多 222 ，所以空间要开三倍。） Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=3e5+5;const int inf=0x3f3f3f3f;int n,m,cnt,x,y,t,tmp;int first[N],ans[N],id[N];int qq[N],disx[N],disy[N],q1[N],q2[N];bool ok[N];struct node&#123;int x,y,id;&#125;l[N],q[N],h1[N],h2[N];struct edge&#123;int to,next;&#125;e[N&lt;&lt;1];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int find(int l,int r,int x)&#123;return lower_bound(id+l,id+r+1,x)-id;&#125;void bfs(int S,int pl,int pr,int *dis)&#123; int head=0,tail=0; for(int i=pl;i&lt;=pr;i++)dis[id[i]]=inf; qq[tail++]=S;dis[S]=0; while(head!=tail) &#123; int u=qq[head++]; for(int i=first[u];i;i=e[i].next) &#123; int to=e[i].to; if(!ok[to])continue; if(dis[to]==inf)dis[to]=dis[u]+1,qq[tail++]=to; &#125; &#125; &#125;void work(int dl,int dr,int pl,int pr,int ql,int qr)&#123; if(dl&gt;dr||pl&gt;pr||ql&gt;qr)return; int mn=inf,mnid=0; for(int i=dl;i&lt;=dr;i++) &#123; x=find(pl,pr,l[i].x);y=find(pl,pr,l[i].y); if(x&gt;y)swap(x,y); tmp=max(y-x,x-y+pr-pl+1); if(tmp&lt;mn)mn=tmp,mnid=i; &#125; for(int i=pl;i&lt;=pr;i++)ok[id[i]]=true; bfs(l[mnid].x,pl,pr,disx); bfs(l[mnid].y,pl,pr,disy); for(int i=pl;i&lt;=pr;i++)ok[id[i]]=false; int t1=0,t2=0,t3=0,t4=0,t5=0,t6=0; for(int i=ql;i&lt;=qr;i++) &#123; x=q[i].x;y=q[i].y;t=q[i].id; if(x==l[mnid].x&amp;&amp;y==l[mnid].y)&#123;ans[t]=1;continue;&#125; ans[t]=min(ans[t],disx[x]+disx[y]); ans[t]=min(ans[t],disy[x]+disy[y]); ans[t]=min(ans[t],disx[x]+disy[y]+1); ans[t]=min(ans[t],disy[x]+disx[y]+1); if(q[i].x&gt;l[mnid].x&amp;&amp;q[i].y&lt;l[mnid].y)h1[++t1]=q[i]; else if((q[i].x&lt;l[mnid].x||q[i].x&gt;l[mnid].y)&amp;&amp; (q[i].y&lt;l[mnid].x||q[i].y&gt;l[mnid].y))h2[++t2]=q[i]; &#125; for(int i=1;i&lt;=t1;i++)q[ql+i-1]=h1[i]; for(int i=1;i&lt;=t2;i++)q[ql+t1+i-1]=h2[i]; for(int i=pl;i&lt;=pr;i++) &#123; if(id[i]&gt;=l[mnid].x&amp;&amp;id[i]&lt;=l[mnid].y)q1[++t3]=id[i]; if(id[i]&lt;=l[mnid].x||id[i]&gt;=l[mnid].y)q2[++t4]=id[i]; &#125; for(int i=1;i&lt;=t3;i++)id[pl+i-1]=q1[i]; for(int i=1;i&lt;=t4;i++)id[pl+t3+i-1]=q2[i]; for(int i=dl;i&lt;=dr;i++) &#123; if(i==mnid)continue; if(l[i].x&gt;=l[mnid].x&amp;&amp;l[i].y&lt;=l[mnid].y)h1[++t5]=l[i]; else h2[++t6]=l[i]; &#125; for(int i=1;i&lt;=t5;i++)l[dl+i-1]=h1[i]; for(int i=1;i&lt;=t6;i++)l[dl+t5+i-1]=h2[i]; work(dl+t5,dl+t5+t6-1,pl+t3,pl+t3+t4-1,ql+t1,ql+t1+t2-1); work(dl,dl+t5-1,pl,pl+t3-1,ql,ql+t1-1); &#125;int main()&#123; n=read(); for(int i=1;i&lt;=n-3;i++) &#123; l[i].x=read();l[i].y=read(); ins(l[i].x,l[i].y);ins(l[i].y,l[i].x); if(l[i].x&gt;l[i].y)swap(l[i].x,l[i].y); &#125; for(int i=1;i&lt;n;i++)ins(i,i+1),ins(i+1,i); ins(1,n);ins(n,1); m=read(); for(int i=1;i&lt;=m;i++) &#123; q[i].x=read();q[i].y=read();q[i].id=i; if(q[i].x&gt;q[i].y)swap(q[i].x,q[i].y); ans[i]=min(q[i].y-q[i].x,q[i].x-q[i].y+n); &#125; for(int i=1;i&lt;=n;i++)id[i]=i; work(1,n-3,1,n,1,m); for(int i=1;i&lt;=m;i++)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>分治</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4833」[Lydsy1704月赛]最小公倍佩尔数]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj4833%2F</url>
    <content type="text"><![CDATA[令 (1+2)n=e(n)+2⋅f(n)(1+\sqrt 2)^n=e(n)+\sqrt 2\cdot f(n)(1+2​)n=e(n)+2​⋅f(n) ，其中 e(n),f(n)e(n),f(n)e(n),f(n) 都是整数，显然有 (1−2)n=e(n)−2⋅f(n)(1-\sqrt 2)^n=e(n)-\sqrt 2\cdot f(n)(1−2​)n=e(n)−2​⋅f(n)。令 g(n)g(n)g(n) 表示 f(1),f(2),⋯,f(n)f(1),f(2),\cdots ,f(n)f(1),f(2),⋯,f(n) 的最小公倍数，给定两个正整数 nnn 和 ppp ，其中 ppp 是质数，并且保证 f(1),f(2),⋯,f(n)f(1),f(2),\cdots ,f(n)f(1),f(2),⋯,f(n) 在模 ppp 意义下均不为 000，请计算 ∑i=1ni⋅g(i)\sum _{i=1}^{n}i\cdot g(i)∑i=1n​i⋅g(i) 模 ppp 的值。 Constraints T≤210T \leq 2 ^{10}T≤210 ，1≤n≤1061\leq n \leq 10 ^61≤n≤106 ，2≤p≤109+72\leq p \leq 10 ^9 +72≤p≤109+7 Solution 在开始推导前先观察两个式子： gcd(fib(a),fib(b))=fib(gcd(a,b))gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(xa−1,xb−1)=xgcd(a,b)−1gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1 gcd(xa−1,xb−1)=xgcd(a,b)−1 形如 f(n)=a⋅f(n−1)+b⋅f(n−2)f(n)=a\cdot f(n-1)+b\cdot f(n-2)f(n)=a⋅f(n−1)+b⋅f(n−2) 的式子具有性质 gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y)) 。 而题目中的式子等价于： f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)f(0)=0,f(1)=1,f(n)=2f(n-1)+f(n-2)f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)，同样满足这个性质。 （以下集合 TTT 均满足 $T\neq \varnothing $） 再由式子： lcm(S)=∏T⊂Sgcd(T)(−1)∣T∣+1lcm(S)=\prod_{T\subset S}gcd(T)^{(-1)^{|T|+1}} lcm(S)=T⊂S∏​gcd(T)(−1)∣T∣+1 可以得到： g(n)=∏T⊂2[n]f(gcdi∈T(i))(−1)∣T∣+1g(n)=\prod _{T\subset 2^{[n]}}f(gcd_{i\in T}(i))^{(-1)^{|T|+1}} g(n)=T⊂2[n]∏​f(gcdi∈T​(i))(−1)∣T∣+1 构造出 hhh 满足 f(n)=∏d∣nh(d)f(n)=\prod _{d|n}h(d)f(n)=∏d∣n​h(d) 得到式子： g(n)=∏T⊂2[n](∏d∣gcdi∈T(i)h(d))(−1)∣T∣+1=∏d=1nh(d)∑T⊂2 [⌊nd⌋] (−1)∣T∣+1\begin{aligned} g(n)&amp;=\prod _{T\subset 2^{[n]}}\left ( \prod _{d|gcd_{i\in T}(i)}h(d) \right )^{(-1)^{|T|+1}}\\ &amp;=\prod _{d=1}^{n}h(d)^{\sum _{T\subset 2^{~[\lfloor \frac{n}{d}\rfloor ]~}}(-1)^{|T|+1}} \end{aligned} g(n)​=T⊂2[n]∏​⎝⎛​d∣gcdi∈T​(i)∏​h(d)⎠⎞​(−1)∣T∣+1=d=1∏n​h(d)∑T⊂2 [⌊dn​⌋] ​(−1)∣T∣+1​ 又由二项式定理可证： ∑T⊂2[⌊nd⌋](−1)∣T∣+1=−∑i=1nd(−1)i(ndi)=1\sum _{T\subset 2^{[\lfloor \frac{n}{d}\rfloor ]}}(-1)^{|T|+1}=-\sum _{i=1}^{\frac{n}{d}}(-1)^i\binom{\frac{n}{d}}{i}=1 T⊂2[⌊dn​⌋]∑​(−1)∣T∣+1=−i=1∑dn​​(−1)i(idn​​)=1 所以 g(n)=∏d=1nh(d)g(n)=\prod _{d=1}^{n}h(d)g(n)=∏d=1n​h(d) 问题解决，时间复杂度 O(nlogn)O(nlogn)O(nlogn)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;int T,n,mod,inv,sum,ans,f[N],h[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; T=read(); while(T--) &#123; n=read();mod=read(); f[0]=0;h[1]=f[1]=1; for(int i=2;i&lt;=n;i++) h[i]=f[i]=(1ll*f[i-1]*2+f[i-2])%mod; for(int i=1;i&lt;=n;i++) &#123; inv=power(h[i],mod-2); for(int j=i+i;j&lt;=n;j+=i)h[j]=1ll*h[j]*inv%mod; &#125; sum=1;ans=0; for(int i=1;i&lt;=n;i++) sum=1ll*sum*h[i]%mod,ans=(ans+1ll*sum*i)%mod; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2159」Crash的文明世界]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj2159%2F</url>
    <content type="text"><![CDATA[给定一棵 nnn 个节点的树，对于每个节点，计算出：S(i)=∑j=1ndist(i,j)k(mod10007)S(i)=\sum _{j=1}^ndist(i,j)^k \pmod {10007}S(i)=∑j=1n​dist(i,j)k(mod10007)。其中 dist(i,j)dist(i, j)dist(i,j) 表示第 iii 个节点到第 jjj 个节点路径上的边数，kkk 为一个常数且为正整数。 Constraints n≤50000n \leq 50000n≤50000 ，k≤150k \leq 150k≤150 Solution 用结论来化简式子：xn=∑i=1nS(n,i)⋅F(x,i)x^n=\sum _{i=1}^n S(n,i)\cdot F(x,i)xn=∑i=1n​S(n,i)⋅F(x,i) S(n,i)S(n,i)S(n,i)为第二类斯特林数，F(x,i)=x!(x−i)!F(x,i)=\frac{x!}{(x-i)!}F(x,i)=(x−i)!x!​ 可得： ans(i)=∑j=1ndist(i,j)m=∑j=1n∑k=1mS(m,k)⋅F(dist(i,j),k)=∑k=1mS(m,k)∑j=1nF(dist(i,j),k)=∑k=1mS(m,k)⋅k!⋅∑j=1nC(dist(i,j),k)\begin{aligned} ans(i)&amp;=\sum _{j=1}^ndist(i,j)^m\\ &amp;=\sum_{j=1}^{n}\sum_{k=1}^{m}S(m,k)\cdot F(dist(i,j),k)\\ &amp;=\sum_{k=1}^{m}S(m,k)\sum_{j=1}^{n} F(dist(i,j),k)\\ &amp;=\sum_{k=1}^{m}S(m,k)\cdot k!\cdot \sum_{j=1}^{n} C(dist(i,j),k) \end{aligned} ans(i)​=j=1∑n​dist(i,j)m=j=1∑n​k=1∑m​S(m,k)⋅F(dist(i,j),k)=k=1∑m​S(m,k)j=1∑n​F(dist(i,j),k)=k=1∑m​S(m,k)⋅k!⋅j=1∑n​C(dist(i,j),k)​ 根据组合数递推公式：C(n,m)=C(n−1,m)+C(n−1,m−1)C(n,m)=C(n-1,m)+C(n-1,m-1)C(n,m)=C(n−1,m)+C(n−1,m−1) 就可以很方便的对后面的部分进行树形dp了。 具体地，令 up(x,i)up(x,i)up(x,i) 为不在 xxx 的子树中的部分的贡献，令 dn(x,i)dn(x,i)dn(x,i) 为 xxx 的子树的贡献。特别的，dn(x,0)=1dn(x,0)=1dn(x,0)=1。 详见代码。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e4+5;const int M=155;const int mod=1e4+7;int n,m,u,v,cnt,ans,tmp;int first[N],fac[M],s[M][M];int up[N][M],dn[N][M];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void dfs1(int x,int fa)&#123; dn[x][0]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs1(to,x); Mod(dn[x][0],dn[to][0]); for(int j=1;j&lt;=m;j++) Mod(dn[x][j],(dn[to][j]+dn[to][j-1])%mod); &#125;&#125;void dfs2(int x,int fa)&#123; if(fa!=-1) &#123; up[x][0]=n-dn[x][0]; for(int i=1;i&lt;=m;i++) &#123; Mod(up[x][i],(up[fa][i]+up[fa][i-1])%mod); Mod(up[x][i],(dn[fa][i]+dn[fa][i-1])%mod); Mod(up[x][i],(2*mod-dn[x][i]-dn[x][i-1])%mod); Mod(up[x][i],(mod-dn[x][i-1])%mod); if(i!=1)Mod(up[x][i],(mod-dn[x][i-2])%mod); &#125; &#125; for(int i=first[x];i;i=e[i].next) if(e[i].to!=fa)dfs2(e[i].to,x);&#125;int main()&#123; int L,now,A,B,Q; n=read();m=read();L=read(); now=read();A=read();B=read();Q=read(); for(int i=1;i&lt;n;i++) &#123; now=(now*A+B)%Q; tmp=i&lt;L?i:L; u=i-now%tmp;v=i+1; ins(u,v);ins(v,u); &#125;// n=read();m=read();// for(int i=1;i&lt;n;i++)// &#123;// u=read();v=read();// ins(u,v);ins(v,u);// &#125; fac[0]=s[0][0]=1; for(int i=1;i&lt;=m;i++) &#123; fac[i]=fac[i-1]*i%mod; for(int j=1;j&lt;=i;j++) s[i][j]=(s[i-1][j]*j+s[i-1][j-1])%mod; &#125; dfs1(1,-1);dfs2(1,-1); for(int i=1;i&lt;=n;i++) &#123; ans=0; for(int j=1;j&lt;=m;j++) Mod(ans,s[m][j]*fac[j]%mod*(up[i][j]+dn[i][j])%mod); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3495」PA2010 Riddle]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj3495%2F</url>
    <content type="text"><![CDATA[有 nnn 个城镇被分成了 kkk 个郡，有 mmm 条连接城镇的无向边。要求给每个郡选择一个城镇作为首都，满足每条边至少有一个端点是首都。 Constraints 1≤n≤1061\leq n \leq 10 ^61≤n≤106 ，0≤m≤1060\leq m \leq 10 ^60≤m≤106 ，1≤k≤n1\leq k \leq n1≤k≤n Solution 每个点 xxx 拆成两对点，xxx 代表选择 xxx 为首都，x+nx+nx+n 表示不选择 xxx 为首都，x+2nx+2nx+2n 表示 xxx 的前缀已包含首都，x+3nx+3nx+3n 表示 xxx 的前缀不包含首都。 对于每一条原图中无向边 (x,y)(x,y)(x,y) ，因为至少有一个端点为首都，连边 (x+n,y)(x+n,y)(x+n,y) ，(y+n,x)(y+n,x)(y+n,x)。 对于每一个点 xxx ，连边 (x,x+2n)(x,x+2n)(x,x+2n) ，(x+3n,x+n)(x+3n,x+n)(x+3n,x+n)。 对于每一个点 xxx 与它的上一个点 lastlastlast ，连边方式如下：(last+2n,x+2n)(last+2n,x+2n)(last+2n,x+2n)，(x+3n,last+3n)(x+3n,last+3n)(x+3n,last+3n)，(last+2n,x+n)(last+2n,x+n)(last+2n,x+n)，(x,last+3n)(x,last+3n)(x,last+3n)。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=4e6+5;int n,m,k,cnt,x,y,last,tim,top,color;int first[N],dfn[N],low[N],sta[N],c[N];bool vis[N];struct edge&#123;int to,next;&#125;e[N*3];void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++tim; sta[++top]=x;vis[x]=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!dfn[to])tarjan(to),low[x]=min(low[x],low[to]=min(low[x],low[to])); else if(vis[to])low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; color++; while(sta[top]!=x)vis[sta[top]]=false,c[sta[top--]]=color; vis[x]=false;c[x]=color;top--; &#125;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) if(c[i]==c[i+n]||c[i+2*n]==c[i+3*n])return false; return true;&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=m;i++) &#123; x=read();y=read(); ins(x+n,y);ins(y+n,x); &#125; for(int i=1;i&lt;=k;i++) &#123; x=read();last=0; for(int j=1;j&lt;=x;j++) &#123; y=read(); ins(y,y+2*n);ins(y+3*n,y+n); if(last) &#123; ins(last+2*n,y+2*n); ins(y+3*n,last+3*n); ins(last+2*n,y+n); ins(y,last+3*n); &#125; last=y; &#125; &#125; for(int i=1;i&lt;=4*n;i++)if(!dfn[i])tarjan(i); if(check())printf("TAK"); else printf("NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>2-SAT</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 983E」NN country]]></title>
    <url>%2F2018%2F05%2F21%2Fcf983e%2F</url>
    <content type="text"><![CDATA[给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。 Constraints 2≤n≤2⋅1052\leq n \leq 2\cdot 10 ^52≤n≤2⋅105 ，1≤m≤2⋅1051\leq m \leq 2\cdot 10 ^51≤m≤2⋅105 ，1≤q≤2⋅1051\leq q \leq 2\cdot 10 ^51≤q≤2⋅105 Solution 对于每一条 aaa 与 bbb 间的路径，都可拆分为 aaa 到 lcalcalca 的路径和 bbb 到 lcalcalca 的路径 采用贪心策略， low[x][i]low[x][i]low[x][i] 表示从 xxx 点出发向上选择不超过 2i2^i2i 条链可抵达的深度最浅的点。这时对于每一个询问可将询问的两个端点修改为利用贪心策略跳到的深度大于 lcalcalca 且深度最小的节点，并记录下答案，这个过程可以用倍增完成。注意特判端点即 lcalcalca 的情况。 然后出现两种情况。若修改后的两个端点出现在同一条给定链上，答案为原答案 +1+1+1 ，否则答案为原答案 +2+2+2 。问题模型转换为，每次询问一个点对是否出现在同一条给定链上。记录下 dfsdfsdfs 序，在深搜过程中利用树状数组统计即可。 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int n,m,Q,cnt,val,x,y,ind;int deep[N],in[N],out[N],last[N];int first[N],ans[N],tr[N];int fa[N][20],low[N][20];bool ok[N];vector&lt;int&gt; a[N],b[N];struct edge&#123;int to,next;&#125;e[N];struct chain&#123;int x,y,t;&#125;c[N],q[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x)&#123; in[x]=++ind; for(int i=1;(1&lt;&lt;i)&lt;=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=first[x];i;i=e[i].next) &#123; deep[e[i].to]=deep[x]+1; dfs(e[i].to); &#125; out[x]=ind;&#125;int lca(int x,int y)&#123; if(deep[x]&lt;deep[y])swap(x,y); int d=deep[x]-deep[y]; for(int i=0;(1&lt;&lt;i)&lt;=d;i++) if((1&lt;&lt;i)&amp;d)x=fa[x][i]; if(x==y)return x; for(int i=17;i&gt;=0;i--) if((1&lt;&lt;i)&lt;=deep[x]&amp;&amp;fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfslow(int x)&#123; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to;dfslow(to); if(deep[low[to][0]]&lt;deep[low[x][0]]) low[x][0]=low[to][0]; &#125;&#125;int find(int x,int t)&#123; if(deep[low[x][17]]&gt;deep[t])&#123;val=-inf;return -1;&#125; if(x==t)&#123;val=-1;return 0;&#125; val=0; for(int i=17;i&gt;=0;i--) if(deep[low[x][i]]&gt;deep[t]) x=low[x][i],val|=(1&lt;&lt;i); return x;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x))tr[x]+=v;&#125;int query(int x)&#123;int ans=0;for(;x;x-=lowbit(x))ans+=tr[x];return ans;&#125;void work(int x)&#123; for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; last[t]=query(out[q[t].y])-query(in[q[t].y]-1); &#125; for(int sz=a[x].size(),i=0;i&lt;sz;i++)add(in[a[x][i]],1); for(int i=first[x];i;i=e[i].next)work(e[i].to); for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; if(query(out[q[t].y])-query(in[q[t].y]-1)!=last[t])ok[t]=true; &#125;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) fa[i][0]=read(),ins(fa[i][0],i); dfs(1); for(int i=1;i&lt;=n;i++)low[i][0]=i; m=read(); for(int i=1;i&lt;=m;i++) &#123; c[i].x=read();c[i].y=read(); c[i].t=lca(c[i].x,c[i].y); if(deep[c[i].t]&lt;deep[low[c[i].x][0]]) low[c[i].x][0]=c[i].t; if(deep[c[i].t]&lt;deep[low[c[i].y][0]]) low[c[i].y][0]=c[i].t; a[c[i].x].push_back(c[i].y); a[c[i].y].push_back(c[i].x); &#125; dfslow(1); for(int t=1;t&lt;=n;t++) for(int i=1;i&lt;=17;i++) low[t][i]=low[low[t][i-1]][i-1]; Q=read(); for(int i=1;i&lt;=Q;i++) &#123; q[i].x=read();q[i].y=read(); q[i].t=lca(q[i].x,q[i].y); ans[i]=2; x=find(q[i].x,q[i].t);ans[i]+=val; y=find(q[i].y,q[i].t);ans[i]+=val; if(x&gt;0&amp;&amp;y&gt;0) &#123; q[i].x=x;q[i].y=y; b[x].push_back(i); &#125; &#125; work(1); for(int i=1;i&lt;=Q;i++) if(ok[i])ans[i]--; for(int i=1;i&lt;=Q;i++) printf("%d\n",ans[i]&lt;0?-1:ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>倍增</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
</search>
