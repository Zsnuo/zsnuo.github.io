<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「LOJ 2669」「NOI2013」快餐店]]></title>
    <url>%2Floj2669%2F</url>
    <content type="text"><![CDATA[小 T 打算在城市 C 开设一家外送快餐店。送餐到某一个地点的时间与外卖店到该地点之间最短路径长度是成正比的，小 T 希望快餐店的地址选在离最远的顾客距离最近的地方。 快餐店的顾客分布在城市 C 的 NNN 个建筑中，这 NNN 个建筑通过恰好 NNN 条双向道路连接起来，不存在任何两条道路连接了相同的两个建筑。任意两个建筑之间至少存在一条由双向道路连接而成的路径。小 T 的快餐店可以开设在任一建筑中，也可以开设在任意一条道路的某个位置上（该位置与道路两端的建筑的距离不一定是整数）。 现给定城市 C 的地图（道路分布及其长度），请找出最佳的快餐店选址，输出其与最远的顾客之间的距离。 Constraints 1≤n≤1000001\leq n \leq 1000001≤n≤100000 Solution 题目给出的图为一棵基环树。对于普通的树的情况，答案即为直径的 12\frac{1}{2}21​ 。而对于基环树来说，答案有两种情况，经过环和不经过环。 对于不经过环的部分，我们可以直接树形 dp 求解。而对于经过环的部分，观察可得，一定有一条边没有经过，破环成链之后对应的就是一个区间。我们令 fif_ifi​ 为以 iii 为端点且另一个端点位于 iii 的子树中的最长链的长度，令 disi,jdis_{i,j}disi,j​ 表示破环成链后序列上 iii 和 jjj 的距离，则最长链为 fi+disi,j+fjf_i+dis_{i,j}+f_jfi​+disi,j​+fj​ 。令 sis_isi​ 表示序列上到 iii 的距离前缀和，则 disi,j=si−sjdis_{i,j}=s_i-s_jdisi,j​=si​−sj​ ，则最长链为 fi+si+fj−sjf_i+s_i+f_j-s_jfi​+si​+fj​−sj​ 。对于一个区间，我们分别求出 fi+sif_i+s_ifi​+si​ 和 fi−sif_i-s_ifi​−si​ 的最大值即可。因为最大值有可能位于同一个位置，所以还需要维护次大值。在这里我们使用线段树进行维护。 关于统计答案时，序列上 jjj 的位置一定在 iii 前面的证明，详见 《【树DP+基环树】[NOI2013]快餐店》 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)#define LL long longusing namespace std;const int N=1e5+5;const LL inf=0x3f3f3f3f3f3f3f3f;int n,x,y,w,vertex,tot,cnt=1;int first[N],pre[N],edg[N],cir[N*2];LL ans,f[N],g[N],s[N*2];int L,R,cpos[2],pos[N*8][2];LL cmx[2],cmn[2],mx[N*8][2],mn[N*8][2];bool vis[N*2];struct edge&#123;int to,next,w;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void insert(int u,int v,int w)&#123; e[++cnt]=(edge)&#123;v,first[u],w&#125;;first[u]=cnt; e[++cnt]=(edge)&#123;u,first[v],w&#125;;first[v]=cnt;&#125;bool circle(int x,int last,int fa)&#123; if(pre[x])&#123;pre[x]=fa;vertex=x;return true;&#125; pre[x]=fa; for(int i=first[x];i;i=e[i].next) &#123; if((i^1)==last)continue; int to=e[i].to; if(circle(to,i,x)) &#123; vis[i]=vis[i^1]=true; edg[to]=i;return true; &#125; &#125; return false;&#125;void dfs(int x,int fa)&#123; LL mx=0,mn=0; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa||vis[i])continue; dfs(to,x); if(f[to]+e[i].w&gt;mx)mn=mx,mx=f[to]+e[i].w; else if(f[to]+e[i].w&gt;mn)mn=f[to]+e[i].w; g[x]=max(g[x],g[to]); &#125; f[x]=mx;g[x]=max(g[x],mx+mn);&#125;void update(int x,int p)&#123; if(mx[lc][p]&gt;mx[rc][p]) &#123; mx[x][p]=mx[lc][p];pos[x][p]=pos[lc][p]; mn[x][p]=max(mn[lc][p],mx[rc][p]); &#125; else &#123; mx[x][p]=mx[rc][p];pos[x][p]=pos[rc][p]; mn[x][p]=max(mx[lc][p],mn[rc][p]); &#125;&#125;void build(int x,int l,int r,int p,int v)&#123; if(l==r) &#123; mx[x][p]=f[cir[l]]+v*s[l]; pos[x][p]=l;mn[x][p]=-inf; return; &#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid,p,v); build(rc,mid+1,r,p,v); update(x,p);&#125;void query(int x,int l,int r,int p)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; if(mx[x][p]&gt;cmx[p]) &#123; cmn[p]=cmx[p];cmx[p]=mx[x][p]; cpos[p]=pos[x][p]; &#125; else if(mx[x][p]&gt;cmn[p])cmn[p]=mx[x][p]; return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)query(lc,l,mid,p); if(R&gt;mid)query(rc,mid+1,r,p);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; x=read();y=read();w=read(); insert(x,y,w); &#125; circle(1,0,-1); cir[++tot]=vertex;x=pre[vertex]; while(x!=vertex)&#123;cir[++tot]=x;x=pre[x];&#125; for(int i=1;i&lt;=tot;i++) &#123; dfs(cir[i],-1);ans=max(ans,g[cir[i]]); cir[tot+i]=cir[i]; &#125; LL cans=inf; for(int i=2;i&lt;=tot*2;i++) s[i]=s[i-1]+e[edg[cir[i-1]]].w; build(1,1,tot*2,0,1); build(1,1,tot*2,1,-1); for(int i=1;i&lt;=tot;i++) &#123; L=i;R=i+tot-1;cpos[0]=cpos[1]=0; cmx[0]=cmx[1]=cmn[0]=cmn[1]=-inf; query(1,1,tot*2,0);query(1,1,tot*2,1); if(cpos[0]==cpos[1])cans=min(cans,max(cmx[0]+cmn[1],cmx[1]+cmn[0])); else cans=min(cans,cmx[0]+cmx[1]); &#125; ans=max(ans,cans); printf("%.1lf",ans/2.0); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2665」「NOI2013」树的计数]]></title>
    <url>%2Floj2665%2F</url>
    <content type="text"><![CDATA[我们知道一棵有根树可以进行深度优先遍历（DFS）以及广度优先遍历（BFS）来生成这棵树的 DFS 序以及 BFS 序。两棵不同的树的 DFS 序有可能相同，并且它们的 BFS 序也有可能相同。 现给定一个 DFS 序和 BFS 序，我们想要知道，符合条件的有根树中，树的高度的平均值。即，假如共有 KKK 棵不同的有根树具有这组 DFS 序和 BFS 序，且他们的高度分别是 h1,h2,…,hKh_1, h_2, \ldots, h_Kh1​,h2​,…,hK​​ ，那么请你输出： h1+h2+⋯+hKK\frac{h_1+h_2+\cdots +h_K}{K} Kh1​+h2​+⋯+hK​​ Constraints 2≤n≤2000002 \leq n \leq 2000002≤n≤200000 Solution 编号对结果没有影响，我们可以将 BFS 序改成 1,2,⋯n1,2,\cdots n1,2,⋯n 并对应地修改 DFS 序。 然后我们可以观察到一个结论：如果编号为 iii 的节点在 DFS 序中位置大于 i+1i+1i+1 号点，则 iii 与 i+1i+1i+1 一定分层。 因为在 DFS 序中，对于相邻的点对 (x,y)(x,y)(x,y) ， deepydeep_ydeepy​ 的深度一定不大于 deepx+1deep_x+1deepx​+1 ，所以要限制在 BFS 序中分层的时候，区间 [x,y][x,y][x,y] 的分层数不能超过 111 。可以根据 BFS 序中的位置判断 xxx 是否是 yyy 的父亲，若是，则他们之间一定会强制分层，用差分来限制区间内的点对不可分层。 对于没有限制的点对 (i,i+1)(i,i+1)(i,i+1) ，对答案的贡献为 0.50.50.5 。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;int n,sum,ans=2;int dfn[N],bfn[N],pos[N];int f[N],cnt[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)dfn[i]=read(); for(int i=1;i&lt;=n;i++)bfn[i]=read(); for(int i=1;i&lt;=n;i++)pos[bfn[i]]=i; for(int i=1;i&lt;=n;i++)dfn[i]=pos[dfn[i]]; for(int i=1;i&lt;=n;i++)pos[dfn[i]]=i; f[1]=1; for(int i=1;i&lt;n;i++) if(pos[i]&gt;pos[i+1])f[i]=1; for(int i=2;i&lt;=n;i++)f[i]+=f[i-1]; for(int i=1;i&lt;n;i++) &#123; int x=dfn[i],y=dfn[i+1]; if(x&gt;=y)continue; y--;if(f[y]-f[x-1])cnt[x]++,cnt[y+1]--; &#125; for(int i=n;i&gt;=1;i--)f[i]-=f[i-1]; for(int i=1;i&lt;n;i++) &#123; sum+=cnt[i]; if(!sum&amp;&amp;!f[i])f[i]=2; &#125; for(int i=1;i&lt;=n;i++) if(f[i]==1)ans+=2; else if(f[i])ans++; printf("%.3lf\n",ans/2.0); return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2249」「NOI2014」购票]]></title>
    <url>%2Floj2249%2F</url>
    <content type="text"><![CDATA[今年夏天，NOI 在 SZ 市迎来了她 30 周岁的生日。来自全国 nnn 个城市的 OIer 们都会从各地出发，到 SZ 市参加这次盛会。 全国的城市构成了一棵以 SZ 市为根的有根树，每个城市与它的父亲用道路连接。为了方便起见，我们将全国的 nnn 个城市用 111 到 nnn 的整数编号。其中 SZ 市的编号为 111 。对于除 SZ 市之外的任意一个城市 vvv ，我们给出了它在这棵树上的父亲城市 fvf_vfv​ 以及到父亲城市道路的长度 svs_vsv​ 。 从城市 vvv 前往 SZ 市的方法为：选择城市 vvv 的一个祖先 aaa，支付购票的费用，乘坐交通工具到达 aaa。再选择城市 aaa 的一个祖先 bbb ，支付费用并到达 bbb 。以此类推，直至到达 SZ 市。 对于任意一个城市 vvv ，我们会给出一个交通工具的距离限制 lvl_vlv​ 。对于城市 vvv 的祖先 aaa ，只有当它们之间所有道路的总长度不超过 lvl_vlv​ 时，从城市 vvv 才可以通过一次购票到达城市 aaa ，否则不能通过一次购票到达。对于每个城市 vvv ，我们还会给出两个非负整数 pv,qvp_v,q_vpv​,qv​ 作为票价参数。若城市 vvv 到城市 aaa 所有道路的总长度为 ddd ，那么从城市 vvv 到城市 aaa 购买的票价为 dpv+qvdp_v+q_vdpv​+qv​​​ 。 每个城市的 OIer 都希望自己到达 SZ 市时，用于购票的总资金最少。你的任务就是，告诉每个城市的 OIer 他们所花的最少资金是多少。 Constraints n≤2×105n \leq 2\times 10^5n≤2×105 Solution 由题意可得，令 di,jd_{i,j}di,j​ 表示点 iii 到点 jjj 的距离，我们利用祖先去更新节点，可以得到以下式子： dpi=max{dpj+pi⋅di,j+qi}dp_i=max \{ dp_j+p_i\cdot d_{i,j}+q_i \} dpi​=max{dpj​+pi​⋅di,j​+qi​} 考虑斜率优化，令点 kkk 为点 jjj 的祖先，则可以得到式子：dpj−dpk≥pi⋅(di,k−di,j)dp_j-dp_k \geq p_i\cdot (d_{i,k}-d_{i,j})dpj​−dpk​≥pi​⋅(di,k​−di,j​) 。 令 disidis_idisi​ 表示点 iii 到根节点的距离，则式子可以变换为：dpj−dpkdisj−disk≥pi\frac{dp_j-dp_k}{dis_j-dis_k}\geq p_idisj​−disk​dpj​−dpk​​≥pi​ 。 所以只需要维护凸包，每一次在凸包上二分斜率即可。为了保证复杂度，在点分治的基础上，我们将所有需要更新的点按照有效的祖先节点进行排序。处理时先处理祖先部分的节点，再用祖先部分的信息来更新其他节点。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const LL inf=(1ll&lt;&lt;62);int n,cnt,tot,now;int first[N],fa[N],sz[N],mx[N],st[N];LL x,p[N],q[N],L[N],dis[N],dp[N];bool vis[N];struct edge&#123;int to,next;LL w;&#125;e[N];struct node&#123;int id;LL v;&#125;a[N];LL read()&#123; LL x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v,LL w)&#123;e[++cnt]=(edge)&#123;v,first[u],w&#125;;first[u]=cnt;&#125;bool cmp(node a,node b)&#123;return a.v&gt;b.v;&#125;LL K(int x,int y)&#123;return 1.0*(dp[y]-dp[x])/(dis[y]-dis[x]);&#125;LL calc(int x,int y)&#123;return dp[y]+(dis[x]-dis[y])*p[x]+q[x];&#125;void dfs(int x)&#123; sz[x]=1; for(int i=first[x];i;i=e[i].next) &#123; dis[e[i].to]=dis[x]+e[i].w; dfs(e[i].to);sz[x]+=sz[e[i].to]; &#125;&#125;void findrt(int x,int S,int&amp; rt)&#123; mx[x]=0;sz[x]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(vis[to])continue; findrt(to,S,rt); sz[x]+=sz[to]; mx[x]=max(mx[x],sz[to]); &#125; mx[x]=max(mx[x],S-sz[x]); if(mx[x]&lt;mx[rt]&amp;&amp;sz[x]&gt;1)rt=x;&#125;void mark(int x)&#123; a[++tot].id=x;a[tot].v=dis[x]-L[x]; for(int i=first[x];i;i=e[i].next) if(!vis[e[i].to])mark(e[i].to);&#125;void solve(int x,int S)&#123; if(S==1)return; int rt=0;findrt(x,S,rt); for(int i=first[rt];i;i=e[i].next)vis[e[i].to]=true; solve(x,S-sz[rt]+1); tot=0;now=rt; for(int i=first[rt];i;i=e[i].next)mark(e[i].to); sort(a+1,a+tot+1,cmp); int l,r,mid,pos,tail=0; for(int i=1;i&lt;=tot;i++) &#123; while(now!=fa[x]&amp;&amp;a[i].v&lt;=dis[now]) &#123; while(tail&gt;1&amp;&amp;K(st[tail],now)&gt;=K(st[tail-1],st[tail]))tail--; st[++tail]=now;now=fa[now]; &#125; if(tail&gt;0) &#123; l=1;r=tail;pos=1; while(l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(mid==tail)&#123;pos=tail;break;&#125; if(K(st[mid],st[mid+1])&gt;=p[a[i].id])l=mid+1,pos=mid+1; else r=mid-1; &#125; dp[a[i].id]=min(dp[a[i].id],calc(a[i].id,st[pos])); &#125; &#125; for(int i=first[rt];i;i=e[i].next)solve(e[i].to,sz[e[i].to]);&#125;int main()&#123; n=read();read(); for(int i=2;i&lt;=n;i++) &#123; fa[i]=read();x=read();ins(fa[i],i,x); p[i]=read();q[i]=read();L[i]=read(); &#125; dfs(1);mx[0]=n+1; for(int i=2;i&lt;=n;i++)dp[i]=inf; solve(1,sz[1]); for(int i=2;i&lt;=n;i++)printf("%lld\n",dp[i]); return 0;&#125;]]></content>
      <tags>
        <tag>点分治</tag>
        <tag>cdq分治</tag>
        <tag>斜率优化dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2248」「NOI2014」随机数生成器]]></title>
    <url>%2Floj2248%2F</url>
    <content type="text"><![CDATA[小 H 有一个 NNN 行 MMM 列的棋盘，她首先按照上述过程，通过 N×M+QN\times M+QN×M+Q 次交换操作，生成一个 1∼N×M1 \sim N \times M1∼N×M 的随机排列 {Ti}i≥1N×M\{T_i\}^{N \times M}_{i \geq 1}{Ti​}i≥1N×M​ ，然后将这 N×MN \times MN×M 个数逐行逐列依次填入这个棋盘：也就是第 iii 行第 jjj 列的格子上所填入的数应为 T(i−1)M+jT_{(i-1)M+j}T(i−1)M+j​​​ 。 接着小 H 希望从棋盘的左上角，也就是第一行第一列的格子出发，每次向右走或向下走，在不走出棋盘的前提下，走到棋盘的右下角，也就是第 NNN 行第 MMM 列的格子。 小 H 把所经过格子上的数字都记录了下来，并从小到大排序，这样，对于任何一条合法的移动路径，小 H 都可以得到一个长度为 N+M−1N+M-1N+M−1 的升序序列，我们称之为路径序列。 小 H 想知道，她可能得到的字典序最小的路径序列应该是怎样的呢？ Constraints 2≤N,M≤50002 \leq N,M \leq 50002≤N,M≤5000 Solution 按照题意模拟一遍将数组求出来，然后从小到大填依次判断是否可行即可。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5005;const int M=25000005;int n,m,q,s,X,Y,cnt;LL a,b,c,d;int x[M],t[M],l[N],r[N],ans[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; x[0]=read();a=read();b=read();c=read();d=read(); n=read();m=read();q=read();s=n*m; for(int i=1;i&lt;=s;i++) x[i]=(x[i-1]*(x[i-1]*a+b)+c)%d,t[i]=i; for(int i=1;i&lt;=s;i++) swap(t[i],t[(x[i]%i)+1]); for(int i=1;i&lt;=q;i++) X=read(),Y=read(),swap(t[X],t[Y]); for(int i=1;i&lt;=s;i++)x[t[i]]=i; memset(r,0x3f,sizeof(r)); for(int i=1;i&lt;=s;i++) &#123; X=(x[i]-1)/m+1; Y=x[i]%m;if(!Y)Y+=m; if(Y&gt;=l[X]&amp;&amp;Y&lt;=r[X]) &#123; for(int j=1;j&lt;=n;j++) &#123; if(j&lt;X)r[j]=min(r[j],Y); if(j&gt;X)l[j]=max(l[j],Y); &#125; ans[++cnt]=i; if(cnt==n+m-1)break; &#125; &#125; for(int i=1;i&lt;=cnt;i++) &#123; printf("%d",ans[i]); if(i!=cnt)putchar(' '); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2246」「NOI2014」动物园]]></title>
    <url>%2Floj2246%2F</url>
    <content type="text"><![CDATA[近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。 下课前，园长提出了一个问题： KMP 算法只能求出 nextnextnext 数组。我现在希望求出一个更强大 numnumnum 数组——对于字符串 SSS 的前 iii 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 numinum_inumi​ 。 最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出 numnumnum 数组呢？ Constraints nleq5nleq 5nleq5 ， L≤106L\leq 10^6L≤106 Solution 即是后缀又是前缀的性质与 KMP 算法的 fail 数组很接近，在处理时顺便记录答案即可。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;const int mod=1e9+7;int T,n,ans,j,fail[N],num[N];char s[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; T=read(); while(T--) &#123; scanf("%s",s+1); n=strlen(s+1);ans=1; num[1]=1;j=0; for(int i=2;i&lt;=n;i++) &#123; while(j&amp;&amp;s[j+1]!=s[i])j=fail[j]; if(s[j+1]==s[i])j++; fail[i]=j;num[i]=num[j]+1; &#125; j=0; for(int i=1;i&lt;=n;i++) &#123; while(j&amp;&amp;s[j+1]!=s[i])j=fail[j]; if(s[j+1]==s[i])j++; while(j*2&gt;i)j=fail[j]; ans=1ll*ans*(num[j]+1)%mod; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2245」「NOI2014」魔法森林]]></title>
    <url>%2Floj2245%2F</url>
    <content type="text"><![CDATA[为了得到书法大家的真传，小 E 同学下定决心去拜访住在魔法森林中的隐士。 魔法森林可以被看成一个包含 NNN 个节点 MMM 条边的无向图，节点标号为 1,…,N1,\ldots,N1,…,N ，边标号为 1,…,M1,\ldots,M1,…,M 。初始时小 E 同学在号节点 111 ，隐士则住在 NNN 号节点。小 E 需要通过这一片魔法森林，才能够拜访到隐士。 魔法森林中居住了一些妖怪。每当有人经过一条边的时候，这条边上的妖怪就会对其发起攻击。幸运的是，在 111 号节点住着两种守护精灵： AAA 型守护精灵与 BBB 型守护精灵。小 E 可以借助它们的力量，达到自己的目的。 只要小 E 带上足够多的守护精灵，妖怪们就不会发起攻击了。具体来说，无向图中的每一条边 EiE_iEi​ 包含两个权值 AiA_iAi​ 与 BiB_iBi​ 。若身上携带的 A 型守护精灵个数不少于 AiA_iAi​ ，且 BBB 型守护精灵个数不少于 BiB_iBi​ ，这条边上的妖怪就不会对通过这条边的人发起攻击。当且仅当通过这片魔法森林的过程中没有任意一条边的妖怪向小 E 发起攻击，他才能成功找到隐士。 由于携带守护精灵是一件非常麻烦的事，小 E 想要知道，要能够成功拜访到隐士，最少需要携带守护精灵的总个数。守护精灵的总个数为 AAA 型守护精灵的个数与 BBB 型守护精灵的个数之和。 Constraints 2≤n≤500002\leq n\leq 500002≤n≤50000 ， 0≤m≤1000000\leq m\leq 1000000≤m≤100000 ， 1≤ai,bi≤500001\leq a_i,b_i\leq 500001≤ai​,bi​≤50000 Solution 按照权值 AAA 排序后，从小到大加边，利用并查集维护连通关系，利用 LCT 维护加边与删边、链上最大值的位置。边可以转化为一个点，点权为原边权，向原端点连边。 加边时若两端点不联通，则直接加入，否则替换掉路径上的最大值。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int N=200050;const int inf=0x3f3f3f3f;int n,m,ans=inf,st[N];struct edge&#123;int u,v,a,b;&#125;e[N];struct node&#123;int fa,c[2],mx,val,p;bool rev;&#125;tr[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(edge a,edge b)&#123;return a.a&lt;b.a;&#125;int find(int k)&#123;return k==tr[k].p?k:tr[k].p=find(tr[k].p);&#125;bool isroot(int k)&#123;return tr[tr[k].fa].c[0]!=k&amp;&amp;tr[tr[k].fa].c[1]!=k;&#125;void up(int k)&#123; int l=tr[k].c[0],r=tr[k].c[1];tr[k].mx=k; if(tr[tr[l].mx].val&gt;tr[tr[k].mx].val)tr[k].mx=tr[l].mx; if(tr[tr[r].mx].val&gt;tr[tr[k].mx].val)tr[k].mx=tr[r].mx;&#125;void down(int k)&#123; if(tr[k].rev) &#123; int l=tr[k].c[0],r=tr[k].c[1]; tr[k].rev^=1;tr[l].rev^=1;tr[r].rev^=1; swap(tr[k].c[0],tr[k].c[1]); &#125;&#125;void rotate(int x)&#123; int y=tr[x].fa,z=tr[y].fa,l,r; if(tr[y].c[0]==x)l=0;else l=1;r=l^1; if(!isroot(y))&#123;if(tr[z].c[0]==y)tr[z].c[0]=x;else tr[z].c[1]=x;&#125; tr[x].fa=z;tr[y].fa=x;tr[tr[x].c[r]].fa=y; tr[y].c[l]=tr[x].c[r];tr[x].c[r]=y; up(y);up(x);&#125;void splay(int x)&#123; int top=0;st[++top]=x; for(int i=x;!isroot(i);i=tr[i].fa)st[++top]=tr[i].fa; for(int i=top;i;i--)down(st[i]); while(!isroot(x)) &#123; int y=tr[x].fa,z=tr[y].fa; if(!isroot(y)) &#123; if((tr[y].c[0]==x)^(tr[z].c[0]==y))rotate(x); else rotate(y); &#125; rotate(x); &#125;&#125;void acs(int x)&#123;int t=0;while(x)&#123;splay(x);tr[x].c[1]=t;up(x);t=x;x=tr[x].fa;&#125;&#125;void mkroot(int x)&#123;acs(x);splay(x);tr[x].rev^=1;&#125;void link(int x,int y)&#123;mkroot(x);tr[x].fa=y;splay(x);&#125;void cut(int x,int y)&#123;mkroot(x);acs(y);splay(y);tr[x].fa=tr[y].c[0]=0;&#125;int query(int x,int y)&#123;mkroot(x);acs(y);splay(y);return tr[y].mx;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++)tr[i].p=i; for(int i=1;i&lt;=m;i++)&#123;e[i].u=read();e[i].v=read();e[i].a=read();e[i].b=read();&#125; sort(e+1,e+m+1,cmp); for(int i=1;i&lt;=m;i++) &#123; int u=e[i].u,v=e[i].v,a=e[i].a,b=e[i].b; if(find(u)==find(v)) &#123; int t=query(u,v); if(tr[t].val&gt;b)&#123;cut(t,e[t-n].u);cut(t,e[t-n].v);&#125; else continue; &#125; else tr[find(u)].p=find(v); tr[i+n].val=b;tr[i+n].mx=i+n;link(u,i+n);link(v,i+n); if(find(1)==find(n))ans=min(ans,a+tr[query(1,n)].val); &#125; if(ans==inf)printf("-1"); else printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>Link-Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2244」「NOI2014」起床困难综合症]]></title>
    <url>%2Floj2244%2F</url>
    <content type="text"><![CDATA[21 世纪，许多人得了一种奇怪的病：起床困难综合症，其临床表现为：起床难，起床后精神不佳。作为一名青春阳光好少年，atm 一直坚持与起床困难综合症作斗争。通过研究相关文献，他找到了该病的发病原因：在深邃的太平洋海底中，出现了一条名为 drd 的巨龙，它掌握着睡眠之精髓，能随意延长大家的睡眠时间。正是由于 drd 的活动，起床困难综合症愈演愈烈，以惊人的速度在世界上传播。为了彻底消灭这种病，atm 决定前往海底，消灭这条恶龙。 历经千辛万苦，atm 终于来到了 drd 所在的地方，准备与其展开艰苦卓绝的战斗。drd 有着十分特殊的技能，他的防御战线能够使用一定的运算来改变他受到的伤害。具体说来，drd 的防御战线由 nnn 扇防御门组成。每扇防御门包括一个运算 opopop 和一个参数 ttt ，其中运算一定是 OR、XOR、AND 中的一种，参数则一定为非负整数。如果还未通过防御门时攻击力为 xxx ，则其通过这扇防御门后攻击力将变为 xxx opopop ttt 。最终 drd 受到的伤害为对方初始攻击力 xxx 依次经过所有 nnn 扇防御门后转变得到的攻击力。 由于 atm 水平有限，他的初始攻击力只能为 000 到 mmm 之间的一个整数（即他的初始攻击力只能在 0,1,⋯m0,1,\cdots m0,1,⋯m 中任选，但在通过防御门之后的攻击力不受 mmm 的限制）。为了节省体力，他希望通过选择合适的初始攻击力使得他的攻击能让 drd 受到最大的伤害，请你帮他计算一下，他的一次攻击最多能使 drd 受到多少伤害。 Constraints 2≤n≤1052\leq n\leq 10^52≤n≤105 ， 2≤m≤2302 \leq m \leq 2^302≤m≤230 Solution 转化为二进制后每一位都是互相独立的，对每一位初始分别为 000 或 111 的情况进行模拟，最后贪心地从大到小取即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,m,now,num,ans;int op[N],t[N],x[30][2];char ch[4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",ch+1);t[i]=read(); if(ch[1]=='X')op[i]=1; if(ch[1]=='O')op[i]=2; if(ch[1]=='A')op[i]=3; &#125; for(int k=0;k&lt;30;k++) for(int j=0;j&lt;2;j++) &#123; now=j&lt;&lt;k; for(int i=1;i&lt;=n;i++) &#123; if(op[i]==1)now^=(t[i]&amp;(1&lt;&lt;k)); if(op[i]==2)now|=(t[i]&amp;(1&lt;&lt;k)); if(op[i]==3)now&amp;=(t[i]&amp;(1&lt;&lt;k)); &#125; x[k][j]=now; &#125; for(int i=29;i&gt;=0;i--) &#123; if(x[i][0]!=0||x[i][1]==0)&#123;ans+=x[i][0];continue;&#125; if(num+(1&lt;&lt;i)&lt;=m)num+=(1&lt;&lt;i),ans+=x[i][1]; &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2134」「NOI2015」小园丁与老司机]]></title>
    <url>%2Floj2134%2F</url>
    <content type="text"><![CDATA[小园丁 Mr. S 负责看管一片田野，田野可以看作一个二维平面。田野上有 nnn 棵许愿树，编号 1,2,3,…,n1,2,3, \ldots ,n1,2,3,…,n ，每棵树可以看作平面上的一个点，其中第 iii 棵树（1≤i≤n1 \leq i \leq n1≤i≤n）位于坐标 (xi,yi)(x_i,y_i)(xi​,yi​) 。任意两棵树的坐标均不相同。 老司机 Mr. P 从原点 (0,0)(0,0)(0,0) 驾车出发，进行若干轮行动。每一轮，Mr. P 首先选择任意一个满足以下条件的方向： 为左、右、上、左上 45∘45^{\circ}45∘ 、右上 45∘45^{\circ}45∘ 五个方向之一。 沿此方向前进可以到达一棵他尚未许愿过的树。 完成选择后，Mr. P 沿该方向直线前进，必须到达该方向上距离最近的尚未许愿的树，在树下许愿并继续下一轮行动。如果没有满足条件的方向可供选择，则停止行动。他会采取最优策略，在尽可能多的树下许愿。若最优策略不唯一，可以选择任意一种。 Constraints n≤50000n\leq 50000n≤50000 ， ∣xi∣≤109|x_i| \leq 10^9∣xi​∣≤109 ， 1&lt;y≤1091&lt;y\leq 10^91&lt;y≤109 Solution 码农题，只写了第一问……第二问是求方案，第三问上下界最小流。非常闹心，弃疗。 第一问可以用 dp 解决，具体地，将左右与其他情况分开解决。令 f(i)f(i)f(i) 表示上一步是在左边或右边的答案，g(i)g(i)g(i) 表示上一步 yyy 小于当前步的答案。具体地，先按 yyy 排序后按 xxx 排序。然后先更新 g(i)g(i)g(i) ，直接枚举三种情况来更新即可，可以用 map 记下最近的点。对于 f(i)f(i)f(i) ，观察可得最优方案下一定会取一段前缀或一段后缀，从左向右和从右向左分别更新一遍即可。 期望得分 20 分。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;map&gt;#define LL long longusing namespace std;const int N=5e4+5;const int inf=0x3f3f3f3f;int n,x,y,w,tot,mx,ans;int t[N],f[N],g[N];bool ok[N][2];vector&lt;int&gt; v[N];map&lt;int,int&gt; ml,mm,mr;struct node&#123;int x,y;&#125;o,a[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(int x,int y)&#123;return a[x].x&lt;a[y].x;&#125;void modify()&#123; w=max(f[y],g[y]); g[x]=max(g[x],w+1); ok[x][1]=true;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; x=read();y=read(); a[i]=(node)&#123;x,y&#125;;t[i]=y; &#125; a[++n]=(node)&#123;0,0&#125;;sort(t+1,t+n+1); tot=unique(t+1,t+n+1)-t-1; for(int i=1;i&lt;=n;i++) &#123; x=lower_bound(t+1,t+tot+1,a[i].y)-t; v[x].push_back(i); &#125; ml[0]=n;mm[0]=n;mr[0]=n;ok[n][0]=ok[n][1]=true; for(int i=2;i&lt;=tot;i++) &#123; int sz=v[i].size(); sort(v[i].begin(),v[i].end(),cmp); for(int j=0;j&lt;sz;j++) &#123; x=v[i][j];o=a[x]; if(mm.count(o.x))y=mm[o.x],modify(); if(ml.count(o.x-o.y))y=ml[o.x-o.y],modify(); if(mr.count(o.x+o.y))y=mr[o.x+o.y],modify(); &#125; mx=ok[v[i][0]][1]?g[v[i][0]]:-inf; for(int j=1;j&lt;sz;j++) &#123; x=v[i][j]; if(mx!=-inf)f[x]=mx+1,ok[x][0]=true; if(ok[x][1])mx=max(mx+1,g[x]+j); else if(mx!=-inf)mx++; &#125; mx=ok[v[i][sz-1]][1]?g[v[i][sz-1]]:-inf; for(int j=sz-2;j&gt;=0;j--) &#123; x=v[i][j]; if(mx!=-inf)f[x]=max(f[x],mx+1),ok[x][0]=true; if(ok[x][1])mx=max(mx+1,g[x]+sz-1-j); else if(mx!=-inf)mx++; &#125; for(int j=0;j&lt;sz;j++) &#123; x=v[i][j];o=a[x]; if(ok[x][0]||ok[x][1])mm[o.x]=ml[o.x-o.y]=mr[o.x+o.y]=x; &#125; &#125; for(int i=1;i&lt;=n;i++)ans=max(ans,max(f[i],g[i])); printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>普通dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2133」「NOI2015」品酒大会]]></title>
    <url>%2Floj2133%2F</url>
    <content type="text"><![CDATA[一年一度的「幻影阁夏日品酒大会」隆重开幕了。大会包含品尝和趣味挑战两个环节，分别向优胜者颁发「首席品酒家」和「首席猎手」两个奖项，吸引了众多品酒师参加。 在大会的晚餐上，调酒师 Rainbow 调制了 nnn 杯鸡尾酒。这 nnn 杯鸡尾酒排成一行，其中第 iii 杯酒 （1≤i≤n1 \leq i \leq n1≤i≤n） 被贴上了一个标签 sis_isi​ ，每个标签都是 262626 个小写英文字母之一。设 Str(l,r)\mathrm{Str}(l, r)Str(l,r) 表示第 lll 杯酒到第 rrr 杯酒的 r−l+1r-l+1r−l+1 个标签顺次连接构成的字符串。若 Str(p,p0)=Str(q,q0)\mathrm{Str}(p, p_0) = \mathrm{Str}(q, q_0)Str(p,p0​)=Str(q,q0​) ，其中 1≤p≤p0≤n1 \leq p \leq p_0 \leq n1≤p≤p0​≤n ， 1≤q≤q0≤n1 \leq q \leq q_0 \leq n1≤q≤q0​≤n ， p≠qp \neq qp≠q ， p0−p+1=q0−q+1=rp_0-p+1=q_0-q+1=rp0​−p+1=q0​−q+1=r ，则称第 ppp 杯酒与第 qqq 杯酒是「 rrr 相似」的。当然两杯「 rrr 相似」（ r&gt;1r &gt; 1r&gt;1 ）的酒同时也是「 111 相似」、「 222 相似」、 $\cdots $ 、「 r−1r-1r−1 相似」的。特别地，对于任意的 1≤p,q≤n1 \leq p, q \leq n1≤p,q≤n ， p≠qp \neq qp≠q ，第 ppp 杯酒和第 qqq 杯酒都是「 000 相似」的。 在品尝环节上，品酒师 Freda 轻松地评定了每一杯酒的美味度，凭借其专业的水准和经验成功夺取了「首席品酒家」的称号，其中第 iii 杯酒 （ 1≤i≤n1 \leq i \leq n1≤i≤n ） 的美味度为 aia_iai​ 。现在 Rainbow 公布了挑战环节的问题：本次大会调制的鸡尾酒有一个特点，如果把第 ppp 杯酒与第 qqq 杯酒调兑在一起，将得到一杯美味度为 ap⋅aqa_p \cdot a_qap​⋅aq​ 的酒。现在请各位品酒师分别对于 r=0,1,2,⋯n−1r=0,1,2,\cdots n-1r=0,1,2,⋯n−1 ， 统计出有多少种方法可以选出两杯「 rrr 相似」的酒，并回答选择两杯「 rrr 相似」的酒调兑可以得到的美味度的最大值。 Constraints n≤300000n\leq 300000n≤300000 ， ∣ai∣≤109|a_i|\leq 10^9∣ai​∣≤109 Solution 题意中的「 rrr 相似」即为两个后缀的最长公共前缀，等价于倒着建的后缀自动机 parent 树上的 lca 。 我们需要在 parent 树上统计以下信息：子树有效节点个数，子树内最大值，子树内次大值，子树内最小值，子树内次小值。 每到达一个节点，将来自两个不同儿子的有效节点两两组合的和，就是恰好「 deepdeepdeep 相似」的答案，可以利用差分来更新到 「 111 相似」到「 deepdeepdeep 相似」的答案里。同时，用最大值 $\cdot $ 次大值和最小值 $\cdot $ 次小值更新美味度的答案，可以用树状数组倒过来实现。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=6e5+5;const LL inf=-1e18-1;int n,last,size,root,cnt;int a[N],first[N],sz[N],w[N];int mx[N],cmx[N],mn[N],cmn[N];LL tmp,tr[N],num[N],ans[N];char ch[N];struct SAM&#123;int mx,fa,ch[26];&#125;t[N];struct edge&#123;int to,next;&#125;e[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void add(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void ins(int c,int pos)&#123; int np=++size; sz[np]=1;w[np]=a[pos]; t[np].mx=t[last].mx+1; int x=last;last=np; while(x&amp;&amp;!t[x].ch[c])t[x].ch[c]=np,x=t[x].fa; if(!x)t[np].fa=root; else &#123; int y=t[x].ch[c]; if(t[y].mx==t[x].mx+1)t[np].fa=y; else &#123; int nq=++size;t[nq]=t[y]; t[nq].mx=t[x].mx+1; t[y].fa=t[np].fa=nq; while(x&amp;&amp;t[x].ch[c]==y)t[x].ch[c]=nq,x=t[x].fa; &#125; &#125;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void modify(int x,LL v)&#123;for(;x&lt;=n;x+=lowbit(x))tr[x]=max(tr[x],v);&#125;LL query(int x)&#123;LL ans=inf;for(;x;x-=lowbit(x))ans=max(ans,tr[x]);return ans;&#125;void dfs(int x)&#123; int deep=t[x].mx; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to;dfs(to); num[deep]+=1ll*sz[x]*sz[to];sz[x]+=sz[to]; if(mn[to]&lt;mn[x])cmn[x]=mn[x],mn[x]=mn[to]; else if(mn[to]&lt;cmn[x])cmn[x]=mn[to]; if(mx[to]&gt;mx[x])cmx[x]=mx[x],mx[x]=mx[to]; else if(mx[to]&gt;cmx[x])cmx[x]=mx[to]; &#125; if(cmn[x]!=1e9+1)modify(n-deep,1ll*cmn[x]*mn[x]); if(cmx[x]!=-1e9-1)modify(n-deep,1ll*cmx[x]*mx[x]);&#125;int main()&#123; n=read();scanf("%s",ch+1); last=size=root=1; for(int i=1;i&lt;=n;i++)a[i]=read(); for(int i=n;i&gt;=1;i--)ins(ch[i]-'a',i); for(int i=2;i&lt;=size;i++)add(t[i].fa,i); for(int i=1;i&lt;=size;i++) &#123; cmn[i]=1e9+1;cmx[i]=-1e9-1; if(sz[i])mx[i]=mn[i]=w[i]; else mn[i]=1e9+1,mx[i]=-1e9-1; &#125; for(int i=1;i&lt;=n;i++)tr[i]=inf; dfs(1); for(int i=n-1;i&gt;=0;i--)ans[i]=ans[i+1]+num[i]; for(int i=0;i&lt;n;i++) &#123; tmp=query(n-i); printf("%lld %lld\n",ans[i],tmp==inf?0:tmp); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>SAM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2132」「NOI2015」荷马史诗]]></title>
    <url>%2Floj2132%2F</url>
    <content type="text"><![CDATA[Allison 最近迷上了文学。她喜欢在一个慵懒的午后，细细地品上一杯卡布奇诺，静静地阅读她爱不释手的《荷马史诗》。但是由《奥德赛》和《伊利亚特》组成的鸿篇巨制《荷马史诗》实在是太长了，Allison 想通过一种编码方式使得它变得短一些。 一部《荷马史诗》中有 nnn 种不同的单词，从 111 到 nnn 进行编号。其中第 iii 种单词出现的总次数为 wiw_iwi​​​ 。Allison 想要用 kkk 进制串 sis_isi​ 来替换第 iii 种单词，使得其满足如下要求： 对于任意的 1≤i,j≤n, i≠j1 \leq i,j \leq n, \ i \neq j1≤i,j≤n, i≠j，都有：sis_isi​ 不是 sjs_jsj​ 的前缀。 现在 Allison 想要知道，如何选择 sis_isi​ ，才能使替换以后得到的新的《荷马史诗》长度最小。在确保总长度最小的情况下，Allison 还想知道最长的 sis_isi​ 的最短长度是多少？ Constraints 2≤n≤1000002 \leq n \leq 1000002≤n≤100000 ， $ 2 \leq k \leq 9$ ， $ 0 \lt w_i \leq 10^{11}$ Solution kkk 维哈夫曼编码，将 kkk 小的元素按规则合并即可。 哈夫曼编码具体右转 《霍夫曼编码（Huffman Coding）》 by xgf415 Code 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;queue&gt;#define LL long longusing namespace std;const int N=1e5+5;LL n,k,w,ans;struct node&#123; LL w,h; bool operator &lt; (const node&amp; a) const &#123;return w==a.w?h&gt;a.h:w&gt;a.w;&#125;&#125;t,tp;priority_queue&lt;node&gt; Q;LL read()&#123; LL x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read();k=read(); for(int i=1;i&lt;=n;i++) w=read(),Q.push((node)&#123;w,0&#125;); if(k&gt;2)while(n%(k-1)!=1)n++,Q.push((node)&#123;0,0&#125;); for(int i=1;i&lt;=n/(k-1)-(k==2);i++) &#123; t.w=t.h=0; for(int j=1;j&lt;=k;j++) &#123; tp=Q.top();Q.pop(); t.w+=tp.w;t.h=max(t.h,tp.h+1); &#125; ans+=t.w;Q.push(t); &#125; printf("%lld\n%lld",ans,Q.top().h); return 0;&#125;]]></content>
      <tags>
        <tag>哈夫曼编码</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2131」「NOI2015」寿司晚宴]]></title>
    <url>%2Floj2131%2F</url>
    <content type="text"><![CDATA[为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。 在晚宴上，主办方为大家提供了 n−1n-1n−1 种不同的寿司，编号 1,2,3,⋯,n−11,2,3,\cdots ,n-11,2,3,⋯,n−1 ，其中第 iii 种寿司的美味度为 i+1i+1i+1 （即寿司的美味度为从 222 到 nnn ）。 现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 xxx 的寿司，小 W 品尝的寿司中存在一种美味度为 yyy 的寿司，而 xxx 与 yyy 不互质。 现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 ppp 取模）。注意一个人可以不吃任何寿司。 Constraints 2≤n≤5002\leq n \leq 5002≤n≤500 ， 0&lt;p≤10000000000 &lt; p \leq 10000000000&lt;p≤1000000000 Solution 可以观察到选择一种寿司等价于选择它所有的质因子，又因为 nnn 以内的数最多只有一个大于 n\sqrt{n}n​ 的质因子，小于 n\sqrt{n}n​ 的质因子有 888 个，所以我们可以把每个数包含的质因子压成一个 282^828 的状态，单独记录那个大于 n\sqrt{n}n​ 的质因子。 然后进行状压 dp ，大于 n\sqrt{n}n​ 的质因子相同的部分要放在一起处理，且只能由其中一个人选择。 令 f[i][j]f[i][j]f[i][j] 表示小 G 已选择的质因子集合为 jjj ，小 W 已选择的质因子集合为 kkk 的方案数；令 g[0/1][j][k]g[0/1][j][k]g[0/1][j][k] 表示当前块由小 G / 小 W 选择且小 G 已选择的质因子集合为 jjj ，小 W 已选择的质因子集合为 kkk 的方案数，可以得到转移方程： g[0][j∣ai][k]=(g[0][j∣ai][k]+g[0][j][k])modpg[0][j|a_i][k]=(g[0][j|a_i][k]+g[0][j][k]) \bmod p g[0][j∣ai​][k]=(g[0][j∣ai​][k]+g[0][j][k])modp g[1][j][k∣ai]=(g[1][j][k∣ai]+g[1][j][k])modpg[1][j][k|a_i]=(g[1][j][k|a_i]+g[1][j][k]) \bmod p g[1][j][k∣ai​]=(g[1][j][k∣ai​]+g[1][j][k])modp 在一个块开始时初始化 g[0/1][j][k]=f[j][k]g[0/1][j][k]=f[j][k]g[0/1][j][k]=f[j][k] 。 在一个块结束时减去被多算的两个人都不选的方案并更新 fff ： f[j][k]=(g[0][j][k]+g[1][j][k]−f[j][k])modpf[j][k]=(g[0][j][k]+g[1][j][k]-f[j][k]) \bmod p f[j][k]=(g[0][j][k]+g[1][j][k]−f[j][k])modp Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=505;const int pri[8]=&#123;2,3,5,7,11,13,17,19&#125;;int n,mod,t,ans,mx=1&lt;&lt;8;int f[N][N],g[2][N][N];struct node&#123;int p,mx;&#125;a[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.mx==b.mx?a.p&lt;b.p:a.mx&lt;b.mx;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;int main()&#123; n=read();mod=read(); for(int i=2;i&lt;=n;i++) &#123; t=i; for(int j=0;j&lt;8;j++) &#123; if(t%pri[j])continue; a[i].p|=(1&lt;&lt;j); while(t%pri[j]==0)t/=pri[j]; &#125; a[i].mx=t; &#125; sort(a+2,a+n+1,cmp); f[0][0]=1; for(int i=2;i&lt;=n;i++) &#123; if(i==2||a[i].mx==1||a[i].mx!=a[i-1].mx) memcpy(g[0],f,sizeof(f)),memcpy(g[1],f,sizeof(f)); for(int j=mx-1;j&gt;=0;j--) for(int k=mx-1;k&gt;=0;k--) &#123; if(!(j&amp;a[i].p))Mod(g[1][j][k|a[i].p],g[1][j][k]); if(!(k&amp;a[i].p))Mod(g[0][j|a[i].p][k],g[0][j][k]); &#125; if(i==n||a[i].mx==1||a[i].mx!=a[i+1].mx) for(int j=0;j&lt;mx;j++) for(int k=0;k&lt;mx;k++) f[j][k]=((g[0][j][k]+g[1][j][k]-f[j][k])%mod+mod)%mod; &#125; for(int i=0;i&lt;mx;i++) for(int j=0;j&lt;mx;j++) if(!(i&amp;j))Mod(ans,f[i][j]); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「康复训练」6月15日联考]]></title>
    <url>%2Fnoi-sim-2%2F</url>
    <content type="text"><![CDATA[NOI2018 前的联考第二场。 深邃 Description 当我们伟大的领袖 V 还小的时候，他的目光就十分深邃，显示出他过人的天赋。这一天，他将目光投向了贤者之森里的一棵树。 这是一棵有 nnn 个节点 n−1n-1n−1 条边的树，其中有 kkk 个节点长有果实，V 想删去一些边，使得树分为几个连通块，满足每个连通块都包含至少一个果实，并且最大的连通块最小。V 请你求出答案，thank you sir! Constraints $ n \leq 200000$ Solution 根据题意很容易想到二分，二分答案后在树上贪心地取。 f(x,0)f(x,0)f(x,0) 表示在 xxx 这个点的子树里的点与 xxx 构成连通块且不包含特殊点的连通块大小， f(x,1)f(x,1)f(x,1) 表示包含特殊点的连通块大小，贪心地尽量能包含就包含即可。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int n,k,cnt,x,y,ans,mx;int first[N],f[N][2];bool ok,good[N];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void Min(int&amp; a,int b)&#123;if(b&lt;a)a=b;&#125;void Max(int&amp; a,int b)&#123;if(b&gt;a)a=b;&#125;void dfs(int x,int fa)&#123; if(good[x])f[x][0]=0; int sum=0,mn=good[x]?0:inf; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs(to,x);sum+=f[to][0]; Min(mn,f[to][1]); &#125; if(sum+mn+1&lt;=mx)f[x][1]=sum+mn+1,f[x][0]=0; else if(sum+1&lt;=mx&amp;&amp;x!=1)f[x][0]=sum+1; else ok=false;&#125;bool check(int x)&#123; mx=x;ok=true; memset(f,0x3f,sizeof(f)); dfs(1,-1);return ok;&#125;int main()&#123; n=read();k=read(); for(int i=1;i&lt;n;i++) &#123; x=read();y=read(); ins(x,y);ins(y,x); &#125; for(int i=1;i&lt;=k;i++) x=read(),good[x]=true; int L=1,R=n,mid; while(L&lt;=R) &#123; mid=(L+R)&gt;&gt;1; if(check(mid))ans=mid,R=mid-1; else L=mid+1; &#125; printf("%d\n",ans); return 0;&#125; 黑暗 Description 我们伟大的领袖 V 吃掉了树上的果实，得到了黑暗的力量，战无不胜。当 V 又一次获得了胜利的时候，他开始思考自己为什么会被赋予这样的天赋，决定拜访一些著名的哲学家寻找答案。 新日暮里一共有 nnn 个哲学家，任意两个哲学家之间都有可能有通讯，一个哲学家联盟指的是一个极大的哲学家集合，使得任意两名哲学家都可以直接或者间接地通讯。我们称新日暮里的哲学程度为哲学家联盟的个数的 mmm 次方， V 想知道对于通讯情况的哲学程度的和。 简化版题意：nnn 个点的无向图，每条边都可能存在，一个图的权值是连通块个数的 mmm 次方，求所有可能的图的权值和。 答案对 998244353998244353998244353 取模。 Constraints T≤1000T \leq 1000T≤1000 ， n≤30000n \leq 30000n≤30000 ， m≤15m \leq 15m≤15 Solution 令 f(i,j)f(i,j)f(i,j) 表示 iii 个点构成了 jjj 个连通块的方案数。则对于 j≤2j\leq 2j≤2 的情况，通过枚举 111 所在的连通块大小可得到式子： f(i,j)=∑k=1i−1f(i−k,j−1)f(k,1)(i−1k−1)f(i,j)=\sum_{k=1}^{i-1}f(i-k,j-1)f(k,1)\binom{i-1}{k-1} f(i,j)=k=1∑i−1​f(i−k,j−1)f(k,1)(k−1i−1​) 而对于 j=1j=1j=1 的情况，通过容斥可以得到： f(i,1)=2i(i−1)2−∑k=2if(i,k)f(i,1)=2^{\frac{i(i-1)}{2}}-\sum_{k=2}^{i}f(i,k) f(i,1)=22i(i−1)​−k=2∑i​f(i,k) 期望得分 40 分。 若令 f(i,j)f(i,j)f(i,j) 表示 iii 个点，权值为连通块个数的 jjj 次方的总和，则由式子 (n+1)m=∑i=0m(mi)ni(n+1)^m=\sum_{i=0}^{m}\binom{m}{i}n^i(n+1)m=∑i=0m​(im​)ni 可以推出： f(i,j)=∑k=1ig(k)(i−1k−1)∑t=0j(jt)f(i−k,t)f(i,j)=\sum_{k=1}^{i}g(k)\binom{i-1}{k-1}\sum_{t=0}^{j}\binom{j}{t}f(i-k,t) f(i,j)=k=1∑i​g(k)(k−1i−1​)t=0∑j​(tj​)f(i−k,t) 其中 g(k)g(k)g(k) 为 kkk 个点的连通图方案数，令 h(i)=2i(i−1)2h(i)=2^{\frac{i(i-1)}{2}}h(i)=22i(i−1)​ ，则可以用以下式子得到： g(i)=h(i)−∑j=1i−1g(j)h(i−j)(i−1j−1)g(i)=h(i)-\sum_{j=1}^{i-1}g(j)h(i-j)\binom{i-1}{j-1} g(i)=h(i)−j=1∑i−1​g(j)h(i−j)(j−1i−1​) 可以预处理枚举 ttt 的部分，期望得分 60 分。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=505;const int mod=998244353;int T,n,m,ans;int bit[N*N],a[N][16],f[N][N],C[N][N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;int main()&#123; bit[0]=1; for(int i=1;i&lt;=250000;i++) bit[i]=bit[i-1]*2%mod; for(int i=0;i&lt;=500;i++)C[i][0]=1; for(int i=1;i&lt;=500;i++) for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; f[1][1]=1; for(int x=2;x&lt;=500;x++) &#123; for(int i=2;i&lt;=x;i++) for(int j=i-1;j&lt;x;j++) Mod(f[x][i],1ll*f[j][i-1]*f[x-j][1]%mod*C[x-1][j]%mod); int sum=0; for(int i=2;i&lt;=x;i++)Mod(sum,f[x][i]); f[x][1]=(bit[x*(x-1)/2]-sum+mod)%mod; &#125; for(int i=1;i&lt;=500;i++)a[i][0]=1; for(int i=1;i&lt;=500;i++) for(int j=1;j&lt;=15;j++) a[i][j]=1ll*a[i][j-1]*i%mod; T=read(); while(T--) &#123; n=read();m=read();ans=0; for(int i=1;i&lt;=n;i++) Mod(ans,1ll*f[n][i]*a[i][m]%mod); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2130」「NOI2015」软件包管理器]]></title>
    <url>%2Floj2130%2F</url>
    <content type="text"><![CDATA[Linux 用户和 OSX 用户一定对软件包管理器不会陌生。通过软件包管理器，你可以通过一行命令安装某一个软件包，然后软件包管理器会帮助你从软件源下载软件包，同时自动解决所有的依赖（即下载安装这个软件包的安装所依赖的其它软件包），完成所有的配置。Debian/Ubuntu 使用的 apt-get，Fedora/CentOS 使用的 yum，以及 OSX 下可用的 Homebrew 都是优秀的软件包管理器。 你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包 AAA 依赖软件包 BBB，那么安装软件包 AAA 以前，必须先安装软件包 BBB。同时，如果想要卸载软件包 BBB，则必须卸载软件包 AAA。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除 000 号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而 000 号软件包不依赖任何一个软件包。依赖关系不存在环，当然也不会有一个软件包依赖自己。 现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为 000。 Constraints n,q≤100000n,q \le 100000n,q≤100000 Solution 直接树链剖分然后上线段树。需要维护几个操作：查询子树有效节点数，查询到根节点路径上的有效节点数，子树区间赋值，到根节点路径区间赋值。 时间复杂度 O(nlog2n)O(nlog^2n)O(nlog2n) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)#define LL long longusing namespace std;const int N=1e5+5;int n,m,cnt,L,R,val,ans,dfn,x;int fa[N],first[N],deep[N];int tp[N],son[N],sz[N],in[N],out[N];int s[N*4],tag[N*4];char op[10];struct edge&#123;int to,next;&#125;e[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs1(int x)&#123; sz[x]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; deep[to]=deep[x]+1; dfs1(to);sz[x]+=sz[to]; if(sz[to]&gt;sz[son[x]])son[x]=to; &#125;&#125;void dfs2(int x,int top)&#123; in[x]=++dfn;tp[x]=top; if(!son[x])&#123;out[x]=dfn;return;&#125; dfs2(son[x],top); for(int i=first[x];i;i=e[i].next) if(e[i].to!=son[x])dfs2(e[i].to,e[i].to); out[x]=dfn;&#125;void down(int x,int l,int r)&#123; int mid=(l+r)&gt;&gt;1,t=tag[x]; if(t==-1)return;tag[x]=-1; s[lc]=(mid-l+1)*t;tag[lc]=t; s[rc]=(r-mid)*t;tag[rc]=t;&#125;void modify(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;s[x]=(r-l+1)*val;tag[x]=val;return;&#125; down(x,l,r);int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(lc,l,mid); if(R&gt;mid)modify(rc,mid+1,r); s[x]=s[lc]+s[rc];&#125;void query(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;ans+=s[x];return;&#125; down(x,l,r);int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)query(lc,l,mid); if(R&gt;mid)query(rc,mid+1,r);&#125;void change(int x)&#123; while(tp[x]!=1) &#123; L=in[tp[x]];R=in[x];val=1; modify(1,1,n);x=fa[tp[x]]; &#125; L=in[1];R=in[x];val=1; modify(1,1,n);x=fa[tp[x]];&#125;int ask(int x)&#123; int cur=0; while(tp[x]!=1) &#123; L=in[tp[x]];R=in[x];ans=0; query(1,1,n);cur+=ans;x=fa[tp[x]]; &#125; L=in[1];R=in[x];ans=0; query(1,1,n);cur+=ans;x=fa[tp[x]]; return cur;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) fa[i]=read()+1,ins(fa[i],i); deep[1]=1;dfs1(1);dfs2(1,1); memset(tag,-1,sizeof(tag)); m=read(); while(m--) &#123; scanf("%s",op);x=read()+1; if(op[0]=='u') &#123; L=in[x];R=out[x];ans=0; query(1,1,n);printf("%d\n",ans); val=0;modify(1,1,n); &#125; else &#123; printf("%d\n",deep[x]-ask(x)); change(x); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2129」「NOI2015」程序自动分析]]></title>
    <url>%2Floj2129%2F</url>
    <content type="text"><![CDATA[在实现程序自动分析的过程中,常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设 x1,x2,x3,…x_1, x_2, x_3,\ldotsx1​,x2​,x3​,… 代表程序中出现的变量，给定 nnn 个形如 xi=xjx_i=x_jxi​=xj​ 或 xi≠xjx_i \neq x_jxi​≠xj​ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。现在给出一些约束满足问题，请分别对它们进行判定。 Constraints T≤10T \leq 10T≤10 ， n≤106n \leq 10^6n≤106 Solution 直接离散化后使用并查集维护即可。先处理相等关系，再处理不相等关系。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;int T,n,cnt,p,q;int x[N],y[N],e[N];int a[N*2],f[N*2];bool ans;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int find(int t)&#123;return f[t]==t?t:f[t]=find(f[t]);&#125;int main()&#123; T=read(); while(T--) &#123; n=read();ans=true; for(int i=1;i&lt;=n;i++) &#123; x[i]=read();y[i]=read();e[i]=read(); a[++cnt]=x[i];a[++cnt]=y[i]; &#125; sort(a+1,a+cnt+1); cnt=unique(a+1,a+cnt+1)-a-1; for(int i=1;i&lt;=n;i++) x[i]=lower_bound(a+1,a+cnt+1,x[i])-a, y[i]=lower_bound(a+1,a+cnt+1,y[i])-a; for(int i=1;i&lt;=cnt*2;i++)f[i]=i; for(int i=1;i&lt;=n;i++) if(e[i]) &#123; p=find(x[i]);q=find(y[i]); if(p!=q)f[p]=q; &#125; for(int i=1;i&lt;=n;i++) if(!e[i]) &#123; p=find(x[i]);q=find(y[i]); if(p==q)ans=false; &#125; if(!ans)printf("NO\n"); else printf("YES\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2086」「NOI2016」区间]]></title>
    <url>%2Floj2086%2F</url>
    <content type="text"><![CDATA[在数轴上有 nnn 个闭区间 [l1,r1],[l2,r2],...,[ln,rn][l_1,r_1],[l_2,r_2],...,[l_n,r_n][l1​,r1​],[l2​,r2​],...,[ln​,rn​] 。现在要从中选出 mmm 个区间，使得这 mmm 个区间共同包含至少一个位置。换句话说，就是使得存在一个 xxx，使得对于每一个被选中的区间 [li,ri][l_i,r_i][li​,ri​] 。 对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。区间 [li,ri][l_i,r_i][li​,ri​] 的长度定义为 ri−lir_i-l_iri​−li​ ，即等于它的右端点的值减去左端点的值。 求所有合法方案中最小的花费。如果不存在合法的方案，输出 −1-1−1 。 Constraints n≤500000n \leq 500000n≤500000 ， m≤200000m \leq 200000m≤200000 ， 0≤li≤ri≤1090 \leq l_i \leq r_i \leq 10^90≤li​≤ri​≤109 Solution 将区间按长度排序，然后观察可得，答案一定是在覆盖了同一个点连续的 mmm 个区间里。所以可以按顺序用线段树维护一个点被覆盖的次数，当覆盖次数达到 mmm 时更新答案，移动头指针并撤销影响。区间端点需要离散化。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long long#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)using namespace std;const int N=5e5+5;int n,m,cnt,L,R;int x[N*2],s[N*8],tag[N*8];struct node&#123;int l,r,len;&#125;a[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.len&lt;b.len;&#125;void down(int x)&#123; s[lc]+=tag[x];tag[lc]+=tag[x]; s[rc]+=tag[x];tag[rc]+=tag[x]; tag[x]=0;&#125;void modify(int x,int l,int r,int val)&#123; if(tag[x]&amp;&amp;l!=r)down(x); if(L&lt;=l&amp;&amp;r&lt;=R)&#123;s[x]+=val;tag[x]+=val;return;&#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(lc,l,mid,val); if(R&gt;mid)modify(rc,mid+1,r,val); s[x]=max(s[lc],s[rc]);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) &#123; a[i].l=read();a[i].r=read(); x[++cnt]=a[i].l;x[++cnt]=a[i].r; a[i].len=a[i].r-a[i].l; &#125; sort(a+1,a+n+1,cmp); sort(x+1,x+cnt+1); cnt=unique(x+1,x+cnt+1)-x-1; for(int i=1;i&lt;=n;i++) a[i].l=lower_bound(x+1,x+cnt+1,a[i].l)-x, a[i].r=lower_bound(x+1,x+cnt+1,a[i].r)-x; int head=1,tail=1,ans=0x3f3f3f3f; while(tail&lt;=n) &#123; L=a[tail].l;R=a[tail].r;modify(1,1,cnt,1); while(s[1]&gt;=m) &#123; ans=min(ans,a[tail].len-a[head].len); L=a[head].l;R=a[head].r; modify(1,1,cnt,-1);head++; &#125; tail++; &#125; printf("%d\n",ans!=0x3f3f3f3f?ans:-1); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2085」「NOI2016」循环之美]]></title>
    <url>%2Floj2085%2F</url>
    <content type="text"><![CDATA[牛牛是一个热爱算法设计的高中生。在他设计的算法中，常常会使用带小数的数进行计算。牛牛认为，如果在 kkk 进制下，一个数的小数部分是纯循环的，那么它就是美的。 现在，牛牛想知道：对于已知的十进制数 nnn 和 mmm，在 kkk 进制下，有多少个数值上互不相等的纯循环小数，可以用分数 xy\frac{x}{y}yx​ 表示，其中 1≤x≤n,1≤y≤m1\le x\le n,1\le y\le m1≤x≤n,1≤y≤m ，且 x,yx,yx,y 是整数。 一个数是纯循环的，当且仅当其可以写成以下形式：a.c1˙c2c3⋯cp−1cp˙a.\dot{c_1}c_2 c_3\cdots c_{p-1}\dot{c_p}a.c1​˙​c2​c3​⋯cp−1​cp​˙​ 。 ​​ 其中，aaa 是一个整数， p≥1p\ge 1p≥1 ；对于 1≤i≤p1\le i\le p1≤i≤p ，cic_ici​ 是 kkk 进制下的一位数字。 需要特别注意的是，我们认为一个整数是纯循环的，因为它的小数部分可以表示成 000 的循环或是 k−1k-1k−1 的循环；而一个小数部分非 000 的有限小数不是纯循环的。 Constraints 1≤n,m≤1091\le n,m \le 10^91≤n,m≤109 ， 2≤k≤20002 \le k \le 20002≤k≤2000 Solution 分数可以通过除法，用分子除以分母化为对应的小数。有些分数在除法过程中无法除尽,这样的分数在不断进行的除法过程中余数一定会重复出现。从商数的个位所对应的余数起，设第一次重复出现的余数前两次出现的位置所对应的商数位分别是小数点后第 aaa 位和小数点后第 bbb 位（特殊地：如果其中一个对应的商数位是个位，则认为 a=0a = 0a=0；不妨设 a&lt;ba &lt; ba&lt;b），则其循环部分可以用小数点后第 a+1a + 1a+1 位到小数点后第 bbb 位的循环来表示。 例如：在十进制下，将 511\frac{5}{11}115​ 转化为小数时，个位开始的商数依次为 4,5,4,…4, 5, 4, \ldots4,5,4,… ，对应的余数分别为 6,5,6,…6, 5, 6, \ldots6,5,6,… 。余数第一次重复出现的位置是个位和小数点后第 222 位，那么 a=0,b=2a = 0, b = 2a=0,b=2 即其循环部分可以用小数点第 111 位到第 333 位来表示。表示为：511=0.45454545…=0.4˙5˙\frac{5}{11} = 0.45454545 \ldots = 0. \dot{4}\dot{5}115​=0.45454545…=0.4˙5˙。 在十进制下，将 16\frac{1}{6}61​ 转化为小数时，个位开始的商数依次为 1,6,6,…1, 6, 6, \ldots1,6,6,… ，对应的余数分别为 4,4,4,…4,4,4, \ldots4,4,4,… 。余数第一次重复出现的位置是小数点后第 111 位和小数点后第 222 位，即其循环部分可以用小数点后第 222 位来表示。表示为：16=0.1666……=0.16˙\frac{1}{6} = 0.1666 \ldots \ldots = 0.1\dot{6}61​=0.1666……=0.16˙。 需要注意的是：商数重复出现并不代表进入了循环节。 由以上提示，我们可以得到一个结论：若循环节长度为 nnn ，则 xkn≡x(mody)xk^n\equiv x \pmod yxkn≡x(mody) 。又因为相同的数字只计算一次，所以 gcd(x,y)=1gcd(x,y)=1gcd(x,y)=1 ，则可得结论 kn≡1(mody)k^n\equiv 1 \pmod ykn≡1(mody) ，即 gcd(k,y)=1gcd(k,y)=1gcd(k,y)=1 。 所以可以推导以下公式： ∑x=1n∑y=1m[gcd(y,k)=1][gcd(x,y)=1]=∑d=1min(n,m)[gcd(d,k)=1]μ(d)⌊nd⌋∑y=1⌊md⌋[gcd(y,k)=1]\begin{aligned} &amp;~~~~\sum_{x=1}^{n}\sum_{y=1}^{m}[gcd(y,k)=1][gcd(x,y)=1] \\ &amp;= \sum_{d=1}^{min(n,m)}[gcd(d,k)=1]\mu (d)\left \lfloor \frac{n}{d} \right \rfloor \sum_{y=1}^{\left \lfloor \frac{m}{d} \right \rfloor}[gcd(y,k)=1]\\ \end{aligned} ​ x=1∑n​y=1∑m​[gcd(y,k)=1][gcd(x,y)=1]=d=1∑min(n,m)​[gcd(d,k)=1]μ(d)⌊dn​⌋y=1∑⌊dm​⌋​[gcd(y,k)=1]​ 令 f(i)=∑y=1i[gcd(y,k)=1]f(i)=\sum_{y=1}^{i}[gcd(y,k)=1]f(i)=∑y=1i​[gcd(y,k)=1] ，则当 i&gt;ki&gt;ki&gt;k 时， f(i)=⌊ik⌋f(k)+f(imodk)f(i)=\left \lfloor \frac{i}{k} \right \rfloor f(k)+f(i\bmod k)f(i)=⌊ki​⌋f(k)+f(imodk) 。 可以得到 84 分。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e7+5;const int K=2e3+5;int n,m,k,mx,cnt;int f[K],miu[N],pri[N];LL ans;bool np[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int gcd(int a,int b)&#123;return !b?a:gcd(b,a%b);&#125;LL F(int x)&#123; if(x&lt;=k)return f[x]; return x/k*f[k]+f[x%k];&#125;int main()&#123; n=read();m=read();k=read(); mx=min(n,m);miu[1]=1; for(int i=2;i&lt;=mx;i++) &#123; if(!np[i])miu[i]=-1,pri[++cnt]=i; for(int j=1;i*pri[j]&lt;=mx;j++) &#123; np[i*pri[j]]=true; if(i%pri[j]==0)&#123;miu[i*pri[j]]=0;break;&#125; miu[i*pri[j]]=-miu[i]; &#125; &#125; for(int i=1;i&lt;=k;i++)f[i]=f[i-1]+(gcd(i,k)==1); for(int i=1;i&lt;=mx;i++) &#123; if(gcd(i,k)!=1)continue; ans+=1ll*miu[i]*(n/i)*F(m/i); &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>容斥原理</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2084」「NOI2016」网格]]></title>
    <url>%2Floj2084%2F</url>
    <content type="text"><![CDATA[跳蚤国王和蛐蛐国王在玩一个游戏。 他们在一个 nnn 行 mmm 列的网格上排兵布阵。其中的 ccc 个格子中 (0≤c≤nm)(0 \leq c \leq nm)(0≤c≤nm) ，每个格子有一只蛐蛐，其余的格子中，每个格子有一只跳蚤。 我们称占据的格子有公共边的两只跳蚤是相邻的。我们称两只跳蚤是连通的，当且仅当这两只跳蚤相邻，或存在另一只跳蚤与这两只跳蚤都连通。 现在，蛐蛐国王希望，将某些（零个，一个或多个）跳蚤替换成蛐蛐，使得在此之后存在至少两只跳蚤不连通。你需要首先判断蛐蛐国王的希望能否被达成。如果能够达成，你还需要最小化被替换的跳蚤的个数。 Constraints 1≤n,m≤1091 \leq n,m \leq 10^91≤n,m≤109 ， ∑c≤105\sum c \leq 10^5∑c≤105 ， 1≤T≤201 \leq T \leq 201≤T≤20 Solution 观察可得：答案为 −1,0,1,2-1,0,1,2−1,0,1,2 。分情况讨论如下： 1.1.1. 当跳蚤数量 ≤1\leq 1≤1 或跳蚤数量为 222 且只有一个连通块时，答案为 −1-1−1 。 2.2.2. 存在至少两个连通块时，答案为 000 。 3.3.3. 连通块个数为 111 但存在割点时，答案为 111 。 4.4.4. 其他情况答案为 222 。 主要过程在离散化建图。需要提取出每只蛐蛐周围的八个点，然后判断这些点里每只跳蚤向右和向下的最近的一个点，若是跳蚤则连上一条边。需要手动多围上一圈边界。 跑 tarjan 求割点即可。记得判断 n=1n=1n=1 和 m=1m=1m=1 的特殊情况。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int T,n,m,C,tot,cnt,cntx,cnty,cntb;int up,dn,le,ri,tim;int X[N*3],Y[N*3];int first[N*25],low[N*25],dfn[N*25];bool mode,havecut;struct edge&#123;int to,next;&#125;e[N*100];struct node&#123; int id,x,y; bool operator &lt; (const node&amp; a) const &#123; if(mode) if(x==a.x)return y&lt;a.y; else return x&lt;a.x; else if(y==a.y)return x&lt;a.x; else return y&lt;a.y; &#125; bool operator == (const node&amp; a) const &#123; return x==a.x&amp;&amp;y==a.y; &#125;&#125;a[N],b[N*25];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123; e[++tot]=(edge)&#123;v,first[u]&#125;;first[u]=tot; e[++tot]=(edge)&#123;u,first[v]&#125;;first[v]=tot;&#125;void tarjan(int x,int fa)&#123; dfn[x]=low[x]=++tim;int son=0; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; if(!dfn[to]) &#123; son++;tarjan(to,x); low[x]=min(low[x],low[to]); if(dfn[x]&lt;=low[to]&amp;&amp;(fa!=-1||(fa==-1&amp;&amp;son&gt;=2)))havecut=true; &#125; else low[x]=min(low[x],low[to]); &#125;&#125;void work()&#123; n=read();m=read();C=read(); cnt=cntx=cnty=cntb=tot=tim=0;havecut=false; for(int x,y,i=1;i&lt;=C;i++) &#123; x=read();y=read();a[i]=(node)&#123;0,x,y&#125;; X[++cntx]=x;Y[++cnty]=y; if(x&gt;1)X[++cntx]=x-1,b[++cntb]=(node)&#123;0,x-1,y&#125;; if(x&lt;n)X[++cntx]=x+1,b[++cntb]=(node)&#123;0,x+1,y&#125;; if(y&gt;1)Y[++cnty]=y-1,b[++cntb]=(node)&#123;0,x,y-1&#125;; if(y&lt;m)Y[++cnty]=y+1,b[++cntb]=(node)&#123;0,x,y+1&#125;; if(x&gt;1&amp;&amp;y&gt;1)b[++cntb]=(node)&#123;0,x-1,y-1&#125;; if(x&gt;1&amp;&amp;y&lt;m)b[++cntb]=(node)&#123;0,x-1,y+1&#125;; if(x&lt;n&amp;&amp;y&gt;1)b[++cntb]=(node)&#123;0,x+1,y-1&#125;; if(x&lt;n&amp;&amp;y&lt;m)b[++cntb]=(node)&#123;0,x+1,y+1&#125;; &#125; if(1ll*n*m-C&lt;=1)&#123;printf("-1\n");return;&#125; le=n+1;up=m+1;ri=dn=0; memset(dfn,0,sizeof(dfn)); memset(low,0,sizeof(low)); memset(first,0,sizeof(first)); for(int i=1;i&lt;=cntx;i++)le=min(le,X[i]),ri=max(ri,X[i]); for(int i=1;i&lt;=cnty;i++)up=min(up,Y[i]),dn=max(dn,Y[i]); if(le&gt;1)le--;if(up&gt;1)up--; if(ri&lt;n)ri++;if(dn&lt;m)dn++; X[++cntx]=le;X[++cntx]=ri; Y[++cnty]=up;Y[++cnty]=dn; sort(X+1,X+cntx+1); cntx=unique(X+1,X+cntx+1)-X-1; sort(Y+1,Y+cnty+1); cnty=unique(Y+1,Y+cnty+1)-Y-1; for(int i=1;i&lt;=cntx;i++) b[++cntb]=(node)&#123;0,X[i],Y[1]&#125;,b[++cntb]=(node)&#123;0,X[i],Y[cnty]&#125;; for(int i=1;i&lt;=cnty;i++) b[++cntb]=(node)&#123;0,X[1],Y[i]&#125;,b[++cntb]=(node)&#123;0,X[cntx],Y[i]&#125;; mode=false;sort(a+1,a+C+1);sort(b+1,b+cntb+1); cntb=unique(b+1,b+cntb+1)-b-1; for(int i=1;i&lt;=C;i++) a[i].x=lower_bound(X+1,X+cntx+1,a[i].x)-X, a[i].y=lower_bound(Y+1,Y+cnty+1,a[i].y)-Y; for(int i=1;i&lt;=cntb;i++) b[i].x=lower_bound(X+1,X+cntx+1,b[i].x)-X, b[i].y=lower_bound(Y+1,Y+cnty+1,b[i].y)-Y, b[i].id=i; for(int ta=1,tb=1,i=1;i&lt;=cntb;i++) &#123; node tmp=b[i]; while(ta&lt;=C&amp;&amp;a[ta]&lt;tmp)ta++; if(ta&gt;=1&amp;&amp;ta&lt;=C&amp;&amp;a[ta]==tmp)continue; cnt++;tmp.x++; while(ta&lt;=C&amp;&amp;a[ta]&lt;tmp)ta++; while(tb&lt;=cntb&amp;&amp;b[tb]&lt;tmp)tb++; if(ta&gt;=1&amp;&amp;ta&lt;=C&amp;&amp;a[ta]==tmp)continue; if(tb&gt;=1&amp;&amp;tb&lt;=cntb&amp;&amp;b[tb].y==b[i].y)ins(b[i].id,b[tb].id); &#125; mode=true;sort(a+1,a+C+1);sort(b+1,b+cntb+1); for(int ta=1,tb=1,i=1;i&lt;=cntb;i++) &#123; node tmp=b[i]; while(ta&lt;=C&amp;&amp;a[ta]&lt;tmp)ta++; if(ta&gt;=1&amp;&amp;ta&lt;=C&amp;&amp;a[ta]==tmp)continue; tmp.y++; while(ta&lt;=C&amp;&amp;a[ta]&lt;tmp)ta++; while(tb&lt;=cntb&amp;&amp;b[tb]&lt;tmp)tb++; if(ta&gt;=1&amp;&amp;ta&lt;=C&amp;&amp;a[ta]==tmp)continue; if(tb&gt;=1&amp;&amp;tb&lt;=cntb&amp;&amp;b[tb].x==b[i].x)ins(b[i].id,b[tb].id); &#125; if(tot)tarjan(e[1].to,-1); if(tim&lt;cnt)printf("0\n"); else &#123; if(1ll*n*m-C==2)printf("-1\n"); else if(n==1||m==1)printf("1\n"); else if(havecut)printf("1\n"); else printf("2\n"); &#125;&#125;int main()&#123; T=read();while(T--)work(); return 0;&#125;]]></content>
      <tags>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2083」「NOI2016」优秀的拆分]]></title>
    <url>%2Floj2083%2F</url>
    <content type="text"><![CDATA[如果一个字符串可以被拆分为 AABB\text{AABB}AABB 的形式，其中 A\text{A}A 和 B\text{B}B 是任意非空字符串，则我们称该字符串的这种拆分是优秀的。 一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。 现在给出一个长度为 nnn 的字符串 SSS，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。 以下事项需要注意： 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。 在一个拆分中，允许出现 A=B\text{A}=\text{B}A=B 。 字符串本身也是它的一个子串。 Constraints $ 1 \leq T \leq 10$ ， 1≤n≤300001 \leq n \leq 300001≤n≤30000 Solution 我们以 ABABAB 为分界线，只需求出分界线左右的 AAAAAA 串然后组合即可。 考虑枚举长度 lenlenlen ，对于两个位置 iii 与 i−leni-leni−len ，求出向前的最长公共后缀和向后的最长公共前缀（二分 + 哈希），组合可以得到一个长度为 2⋅len2\cdot len2⋅len 的 AAAAAA 串。具体的结尾有效区间为 [i−lsp+len,i+lcp−1][i-lsp+len,i+lcp-1][i−lsp+len,i+lcp−1] ，需要注意边界。 时间复杂度 O(nlog2n)O(nlog^2n)O(nlog2n) 。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=3e4+5;const int mod=998244353;int T,n,l,r,mid,last,cur,head,tail;LL ans,bit[N],h[N],st[N],ed[N];char s[N];LL gethash(int L,int R)&#123;return (h[R]-h[L-1]*bit[R-L+1]%mod+mod)%mod;&#125;int main()&#123; scanf("%d",&amp;T);bit[0]=1; for(int i=1;i&lt;=30000;i++) bit[i]=bit[i-1]*29%mod; while(T--) &#123; scanf("%s",s+1);n=strlen(s+1); for(int i=1;i&lt;=n;i++)h[i]=(h[i-1]*29+s[i]-'a')%mod; memset(st,0,sizeof(st)); memset(ed,0,sizeof(ed)); for(int len=1;len*2&lt;=n;len++) for(int i=len*2;i&lt;=n;i+=len) &#123; if(s[i]!=s[i-len])continue; last=i-len;cur=0;l=1;r=i-len; while(l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(gethash(last-mid+1,last)==gethash(i-mid+1,i))cur=mid,l=mid+1; else r=mid-1; &#125; head=max(i-cur+len,i); l=1;r=n-i+1;cur=0; while(l&lt;=r) &#123; mid=(l+r)&gt;&gt;1; if(gethash(last,last+mid-1)==gethash(i,i+mid-1))cur=mid,l=mid+1; else r=mid-1; &#125; tail=min(i+cur-1,i+len-1); if(head&lt;=tail) &#123; st[head-len*2+1]++;st[tail-len*2+2]--; ed[head]++;ed[tail+1]--; &#125; &#125; ans=0; for(int i=1;i&lt;=n;i++)st[i]+=st[i-1],ed[i]+=ed[i-1]; for(int i=1;i&lt;n;i++)ans+=ed[i]*st[i+1]; printf("%lld\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「康复训练」6月12日联考]]></title>
    <url>%2Fnoi-sim-1%2F</url>
    <content type="text"><![CDATA[NOI2018 前的联考第一场。 奥义商店 Description 乐滋滋经常参加各种拍卖会，前不久，他收到了来自滋滋国最大的商店——奥义商店的拍卖会邀请函。 为了让拍卖会看起来更加奥妙重重，奥义商店设置了一个极为复杂的拍卖规则：一共 nnn 个物品排成一排，第 iii 个物品价格是 viv_ivi​ 。对于一次拍卖，商店会指定 ttt 种颜色，并对每种颜色指定一个数目 cjc_jcj​ 满足 ∑j=1tcj=n−1\sum_{j=1}^{t}c_j=n-1∑j=1t​cj​=n−1 ，另外还会指定一个下标 kkk 和一个公差 ddd 。 买家需要给第 kkk 个物品染上一种颜色（在 ttt 种颜色中选择一种）。接着，把剩下的 n−1n-1n−1 个物品随机染成 ttt 种颜色之一，并保证这 n−1n-1n−1 个物品中第 jjj 种颜色的恰好有 cjc_jcj​ 个。 买家需要购买的物品按这样的方式计算：找到 kkk 所在的最长的以 ddd 为公差的等差数列 ax=kx+d(x∈[L,R],L≤0≤R)a_x=kx+d(x\in [L,R],L\le 0 \le R)ax​=kx+d(x∈[L,R],L≤0≤R) 满足其中所有物品都与第 kkk 个物品同色。买家需要买下这个等差数列中的所有物品，显然花费就是 ∑x=LRvk+xd\sum_{x=L}^{R}v_{k+xd}∑x=LR​vk+xd​ 。 乐滋滋最近出现了点“经济危机”，希望你能帮他给第 kkk 个物品选择合适的颜色，以此来最小化他花费的期望，你只需要输出这个期望即可。 当然商品的价格是可能出现变动的，你需要维护这些变化。 Constraints 1≤n,m≤1051 \leq n,m \leq 10^51≤n,m≤105 Solution 对于 t=1t=1t=1 的部分，当 d≤100d \le 100d≤100 时通过预处理好的表 O(1)O(1)O(1) 查询结果，当 d&gt;100d&gt;100d&gt;100 时直接暴力计算即可。 对于 t&gt;1t&gt;1t&gt;1 的部分，贪心可得一定是选择 ccc 最小的颜色。在 k+idk+idk+id 的序列里，对于 i&gt;0i&gt;0i&gt;0 的部分， i=1i=1i=1 时同颜色概率为 cn−1\frac{c}{n-1}n−1c​ ， i=2i=2i=2 时概率为 cn−1⋅c−1n−2\frac{c}{n-1}\cdot \frac{c-1}{n-2}n−1c​⋅n−2c−1​ ，由此递推， i&lt;0i&lt;0i&lt;0 的部分同理。且由于 t!=1t!=1t!=1 且 ccc 最小，所以当递推到后面的部分时，概率已经小到几乎可以忽略不计。为保证复杂度可以舍弃掉后面的部分，这里我选择了 500500500 。 详见代码。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,m,op,x,y,t,k,d;int v[N],c[N];double s[101][101];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void work1()&#123; if(d&lt;=100)&#123;printf("%.6lf\n",s[d][k%d]);return;&#125; double ans=v[k]; for(int i=k+d;i&lt;=n;i+=d)ans+=v[i]; for(int i=k-d;i&gt;=1;i-=d)ans+=v[i]; printf("%.6lf\n",ans);&#125;void work2()&#123; int mn=c[1]; for(int i=2;i&lt;=t;i++)mn=min(mn,c[i]); double ans=v[k],base=1; for(int i=1;i&lt;=500&amp;&amp;k+i*d&lt;=n;i++) &#123; base=1.0*base*(mn-i+1)/(n-i); ans+=1ll*v[k+i*d]*base; &#125; base=1; for(int i=1;i&lt;=500&amp;&amp;k-i*d&gt;=1;i++) &#123; base=1.0*base*(mn-i+1)/(n-i); ans+=1ll*v[k-i*d]*base; &#125; printf("%.6lf\n",ans);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) &#123; v[i]=read(); for(int j=1;j&lt;=100;j++) s[j][i%j]+=v[i]; &#125; while(m--) &#123; op=read(); if(op==1) &#123; x=read();y=read(); for(int j=1;j&lt;=100;j++) s[j][x%j]+=(y-v[x]); v[x]=y; &#125; else &#123; t=read();k=read();d=read(); for(int i=1;i&lt;=t;i++)c[i]=read(); if(t==1)work1(); else work2(); &#125; &#125; return 0;&#125; 访问计划 Description 前不久，滋滋国来了一位白尛 FA 师，在滋滋国到处谈笑风生，滋滋国国王妹滋滋认为这个人姿势水平很高，便向他请教提高姿势水平的办法，白尛 FA 师说“滋滋国的哪一条路我没去过！”妹滋滋心想自己还没有好好考察过滋滋国的每一条道路呢，便计划进行一次访问来提高自己的姿势水平。 滋滋国有 NNN 个城市，编号从 000 到 N−1N-1N−1 ，其中 000 号城市是首都，这些城市被 N−1N-1N−1 条道路连成一棵树，每个道路都有一个通过的花费，这个花费是每次通过时都需要付出的。 现在妹滋滋想要从首都出发，沿着道路行走，经过每条道路至少一次，并最终返回首都，除了沿着道路行走之外，妹滋滋还可以花费 CCC 元乘坐跳蚤巴士从一个城市直接跳到任意一个城市，然而因为各种奥妙重重的原因，妹滋滋最多只能搭乘 KKK 次跳蚤巴士。 现在妹滋滋找到了你，希望你为他安排一个最优的访问路径使得总花费最少，你只需要输出最小总花费即可。 Constraints $ 1 \leq N,K \leq 2000$ Solution 由题意易得，若不使用跳跃，则每条边需要经过两次。若使用跳跃从 uuu 跳跃到 vvv ，则 uuu 到 vvv 路径上的边都可以少走一次。但由于每条边至少经过一次，所以问题可以转化为：求不超过 kkk 条边不相交的链的最大权值和。 令 f(x,k,0/1)f(x,k,0/1)f(x,k,0/1) 表示点 xxx 的子树里，已使用了 kkk 条链， xxx 在/不在链上的最小代价。分类讨论一下做树上背包即可。注意 kkk 只需枚举到子树大小，维持复杂度为 O(n2)O(n^2)O(n2) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e3+5;const int inf=0x3f3f3f3f;int n,K,C,cnt,u,v,w,base,border;int sz[N],first[N],f[N][N][2],g[N][2];struct edge&#123;int to,next,w;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v,int w)&#123;e[++cnt]=(edge)&#123;v,first[u],w&#125;;first[u]=cnt;&#125;void init()&#123; cnt=0; memset(f,0x3f,sizeof(f)); memset(first,0,sizeof(first));&#125;void Min(int&amp; a,int b)&#123;if(b&lt;a)a=b;&#125;void dfs(int x,int fa,int edg)&#123; bool isleaf=true;sz[x]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs(to,x,e[i].w); sz[x]+=sz[to]; if(isleaf) for(int k=0;k&lt;=sz[to];k++) &#123; Min(f[x][k][0],f[to][k][0]); Min(f[x][k][1],f[to][k][1]); if(k+1&lt;=K)Min(f[x][k+1][0],f[to][k][1]); &#125; else &#123; memset(g,0x3f,sizeof(g)); for(int xk=0;xk&lt;=sz[x];xk++) &#123; if(f[x][xk][0]!=inf) &#123; base=f[x][xk][0]; border=min(K-xk,sz[to]); for(int tk=0;tk&lt;=border;tk++) &#123; Min(g[xk+tk][0],base+f[to][tk][0]); Min(g[xk+tk][1],base+f[to][tk][1]); if(xk+tk+1&lt;=K)Min(g[xk+tk+1][0],base+f[to][tk][1]); &#125; &#125; if(f[x][xk][1]!=inf) &#123; base=f[x][xk][1]; border=min(K-xk,sz[to]); for(int tk=0;tk&lt;=border;tk++) &#123; Min(g[xk+tk][1],base+f[to][tk][0]); if(xk+tk+1&lt;=K)Min(g[xk+tk+1][0],base+f[to][tk][1]-C); if(xk+tk+1&lt;=K)Min(g[xk+tk+1][1],base+f[to][tk][1]); &#125; &#125; &#125; for(int k=0;k&lt;=K;k++) for(int j=0;j&lt;=1;j++) f[x][k][j]=g[k][j]; &#125; isleaf=false; &#125; if(isleaf) &#123; f[x][0][0]=2*edg; f[x][0][1]=C+edg; &#125; else &#123; for(int k=0;k&lt;=K;k++) Min(f[x][k][1],f[x][k][0]+C); for(int k=0;k&lt;=K;k++) for(int j=0;j&lt;=1;j++) f[x][k][j]+=(2-j)*edg,Min(f[x][k][j],inf); &#125;&#125;int main()&#123; while(scanf("%d",&amp;n)==1) &#123; K=read();C=read();init(); for(int i=1;i&lt;n;i++) &#123; u=read()+1;v=read()+1;w=read(); ins(u,v,w);ins(v,u,w); &#125; dfs(1,-1,0); int ans=inf; for(int k=0;k&lt;=K;k++) Min(ans,f[1][k][0]); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>解题报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「学习笔记」计算几何相关]]></title>
    <url>%2Fgeometry%2F</url>
    <content type="text"><![CDATA[走上计算几何的漫漫不归路（雾）。 基本概念 点积 a⋅b=∣a∣∣b∣cosθa\cdot b=|a||b|cos\theta a⋅b=∣a∣∣b∣cosθ 令 a=(x1,y1),b=(x2,y2)a=(x_1,y_1),b=(x_2,y_2)a=(x1​,y1​),b=(x2​,y2​) ，则它们的点积等于 x1x2+y1y2x_1x_2+y_1y_2x1​x2​+y1​y2​ 。 应用：两向量垂直，其点积为 000 。 叉积 a×b=∣a∣∣b∣sinθa\times b=|a||b|sin\theta a×b=∣a∣∣b∣sinθ 令 a=(x1,y1),b=(x2,y2)a=(x_1,y_1),b=(x_2,y_2)a=(x1​,y1​),b=(x2​,y2​) ，则它们的点积等于 x1y2−x2y1x_1y_2-x_2y_1x1​y2​−x2​y1​ 。 应用：叉积的几何意义为两向量 a,ba,ba,b 共起点时所构成平行四边形的面积。叉积 =0=0=0 ，两向量平行；叉积 &gt;0&gt;0&gt;0 ，向量 aaa 在向量 bbb 的顺时针方向；叉积 &lt;0&lt;0&lt;0 ，向量 aaa 在向量 bbb 的逆时针方向。 旋转向量 将向量 a=(x,y)a=(x,y)a=(x,y) 旋转 $\theta $ 角度后，坐标为 (xcosθ−ysinθ,xsinθ+ycosθ)(x cos\theta - y sin\theta , x sin\theta + y cos\theta)(xcosθ−ysinθ,xsinθ+ycosθ) 。 证明：令向量 aaa 与 xxx 轴夹角为 $\alpha $ ，则旋转之后夹角为 $\alpha + \theta $ 。利用 x=∣a∣cosαx=|a|cos \alphax=∣a∣cosα 与 y=∣a∣sinαy=|a|sin \alphay=∣a∣sinα 及和角公式可得证。 多边形的面积 若已知一个简单多边形的顶点按逆时针顺序依次为 P1,P2,⋯PnP_1,P_2,\cdots P_nP1​,P2​,⋯Pn​ ，则其面积为： S=Pn×P1+∑i=1n−1Pi×Pi+12S=\frac{P_n\times P_1+\sum _{i=1}^{n-1}P_i\times P_{i+1}}{2} S=2Pn​×P1​+∑i=1n−1​Pi​×Pi+1​​ 极角排序 在平面上取一定点 OOO ，从 OOO 引一条水平射线 OxOxOx ，规定方向自左至右，再选定一个长度单位并规定角旋转的正方向，通常取逆时针方向，这样就构成了一个极坐标系。点 OOO 叫作极点，射线 OxOxOx 叫作极轴。 常见的极角排序方法有四种，这里给出利用叉积进行排序的代码（以原点为极点）。 12345678struct node&#123;double x,y;&#125;;double cross(double x1,double y1,double x2,double y2)&#123;return x1*y2-x2*y1;&#125;bool cmp(node a,node b)&#123; double cros=cross(a.x,a.y,b.x,b.y); if(fabs(cros)&lt;eps)return a.x&lt;b.x; return cros&gt;0;&#125; 凸包 Graham扫描法 一个点集的凸包就是能包围给定点的最小的凸多边形。 构造出点集的凸包的方式为：以点集中纵坐标最小的点为极点（纵坐标相同则横坐标最小，易得这个点一定在凸包上），其他点做极角排序，然后按照极角序扫描，加入一个点时利用叉积判断之前的点是否合法即可。 相关应用 查询一个点是否位于凸包内部：按照极角序二分出在哪两个点之间，判断一下是否在该线段内侧。 一条斜率为 kkk 的直线从正无穷远处向下平移，碰到的第一个点：在凸包上二分斜率。 支持插入操作的动态凸包：离线写法可以使用 cdq 分治，在线写法可以利用平衡树来维护。 坐标范围为 nnn 的整点凸包的点数上界： O(n23)O(n^{\frac{2}{3}})O(n32​) 。 旋转卡壳 对踵点 如果过凸包上的两个点可以画一对平行直线，使凸包上的所有点都夹在两条平行线之间或落在平行线上，那么这两个点叫做一对对踵点。使用旋转卡壳算法可以求出凸多边形的所有对踵点。 算法原理 我们只需要维护两条平行直线中至少有一条卡住了一条边的情况，即可求出所有的对踵点。 枚举凸包上的每一条边，当它被一条直线卡住时，另一条直线一定卡住了离该边最远的点，且该点与该边的两个端点构成了两对对踵点。因为凸包上的点距离固定边的距离是单峰的，改变枚举边时只需要直接移动到对应点即可，且移动过程中经过的点都能与这两条相邻边的交点构成对踵点。时间复杂度 O(n)O(n)O(n) 。 应用 详见博客 《计算几何之旋转卡壳算法》 半平面交 基本概念 半平面是指二维平面上一条直线的一侧的所有空间。通常使用点对 (P,Q)(P,Q)(P,Q) 表示在向量 PQPQPQ 左侧的半平面。 多个半平面的交是空集或非空凸集。 构造方法 首先对所有的半平面进行极角排序，对于极角相同的半平面有选择性地保留，并在双端队列中加入最开始的两个半平面。 考虑加入一个新的半平面：当队头的两个半平面的交点在该半平面外，删除队头的半平面；队尾同理；然后将新的半平面加入队尾。 添加完所有的半平面后，删除两端多余的半平面的方法为：若队头的两个半平面的交点在队尾半平面外，删除队头的半平面；队尾同理。 判断交点在半平面外可以利用叉积解决。 参考资料 《计算几何选讲》，dwjshift 极角 - 百度百科 半平面交 - 百度百科]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2306」「NOI2017」蔬菜]]></title>
    <url>%2Floj2306%2F</url>
    <content type="text"><![CDATA[小 N 是蔬菜仓库的管理员，负责设计蔬菜的销售方案。 在蔬菜仓库中，共存放有 nnn 种蔬菜，小 N 需要根据不同蔬菜的特性，综合考虑各方面因素，设计合理的销售方案，以获得最多的收益。 在计算销售蔬菜的收益时，每销售一个单位第 iii 种蔬菜，就可以获得 aia_iai​ 的收益。特别地，由于政策鼓励商家进行多样化销售，第一次销售第 iii 种蔬菜时，还会额外得到 sis_isi​ 的额外收益。 在经营开始时，第 iii 种蔬菜的库存为 cic_ici​ 个单位。然而，蔬菜的保鲜时间非常有限，一旦变质就不能进行销售，不过聪明的小 N 已 经计算出了每个单位蔬菜变质的时间：对于第 iii 种蔬菜，存在保鲜值 xix_ixi​，每天结束时会有 xix_ixi​ 个单位的蔬菜变质，直到所有蔬菜都变质。（注意：每一单位蔬菜的变质时间是固定的，不随销售发生变化） 形式化地：对于所有的满足条件 d×xi≤cid\times x_i \leq c_id×xi​≤ci​ 的正整数 ddd ，有 xix_ixi​ 个单位的蔬菜将在 第 ddd 天结束时变质。 特别地，若 (d−1)×xi≤ci&lt;d×xi(d-1)\times x_i \le c_i &lt; d\times x_i(d−1)×xi​≤ci​&lt;d×xi​ ，则有 ci−(d−1)×xic_i-(d-1)\times x_ici​−(d−1)×xi​ 单位的蔬菜将在第 ddd 天结束时变质。 注意，当 xi=0x_i = 0xi​=0 时，意味着这种蔬菜不会变质。 同时，每天销售的蔬菜，总量也是有限的，最多不能超过 mmm 个单位。 现在，小 N 有 kkk 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 pjp_jpj​ ，如果需要销售 pjp_jpj​ 天，最多能获得多少收益？ Constraints n,pj≤105n,p_j\leq 10^5n,pj​≤105 ， m≤10m\leq 10m≤10 ， 0&lt;ai,ci≤1090 &lt; a_i,c_i \leq 10^90&lt;ai​,ci​≤109 ， 0≤si,xi≤1090\leq s_i,x_i \leq 10^90≤si​,xi​≤109 Solution 贪心可得，我们要尽量多地卖出收益高的，且尽量晚卖。对于一份蔬菜，拆成 ai+sia_i+s_iai​+si​ 和 aia_iai​ 两种，并钦定第一种过期时间最晚。 对于所有的蔬菜，我们先按价格从大到小排序。按照顺序处理方式为：从过期的最后一天开始尽量卖出，如果当前天已经满了就再往前卖。使用并查集可以保证复杂度。 对于询问，考虑从第 xxx 天到第 x−1x-1x−1 天的转移，贪心地丢弃最便宜的，且份数为从第 xxx 天开始卖出的蔬菜 −-− 从第一天到第 x−1x-1x−1 天的空隙。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;int n,m,k,A,S,C,X,cnt,tmp;int tot,mxd,id,res,cur,mn;int Q[N],f[N],v[N],p[N],d[N];LL ans,sum,t,emp[N],del[N],s[N];struct node&#123;int a,c,x,d;&#125;a[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.a&gt;b.a;&#125;int find(int t)&#123;return f[t]==t?t:f[t]=find(f[t]);&#125;void link(int x,int y)&#123;x=find(x);y=find(y);if(y!=x)f[y]=x;&#125;void modify(int id,int c,int a)&#123; ans+=1ll*c*a;v[tot]+=c;p[tot]=a; d[id]+=c;if(d[id]==m)link(id-1,id);&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=n;i++) &#123; A=read();S=read();C=read();X=read(); a[++cnt]=(node)&#123;A+S,1,0,X?(C-1)/X+1:N&#125;; C--;if(C)a[++cnt]=(node)&#123;A,C,X,X?(C-1)/X+1:N&#125;; &#125; for(int i=1;i&lt;=k;i++) Q[i]=read(),mxd=max(mxd,Q[i]); sort(a+1,a+cnt+1,cmp); for(int i=1;i&lt;=mxd;i++)f[i]=i; for(int i=1;i&lt;=cnt;i++) &#123; tot++;id=find(min(a[i].d,mxd)); res=(id-1)*a[i].x;cur=a[i].c-res; while(id&amp;&amp;cur) &#123; mn=min(m-d[id],cur); modify(id,mn,a[i].a);cur-=mn; tmp=id;id=find(id-1);tmp-=id; cur+=min(res,tmp*a[i].x); res-=min(res,tmp*a[i].x); &#125; if(!find(mxd))break; &#125; for(int i=1;i&lt;=mxd;i++)emp[i]=emp[i-1]+m-d[i]; for(int i=mxd;i&gt;=1;i--)del[i]=max(0ll,sum-emp[i]),sum+=d[i]; for(int i=mxd;i&gt;=1;i--) &#123; s[i]=ans;t=del[i-1]-del[i]; while(t) &#123; mn=min(t,1ll*v[tot]);ans-=1ll*mn*p[tot]; t-=mn;v[tot]-=mn;if(!v[tot])tot--; &#125; &#125; for(int i=1;i&lt;=k;i++)printf("%lld\n",s[Q[i]]); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2305」「NOI2017」游戏]]></title>
    <url>%2Floj2305%2F</url>
    <content type="text"><![CDATA[小 L 计划进行 nnn 场游戏，每场游戏使用一张地图，小 L 会选择一辆车在该地图上完成游戏。 小 L 的赛车有三辆，分别用大写字母 AAA、BBB、CCC 表示。地图一共有四种，分别用小写字母 xxx、aaa、bbb、ccc 表示。 其中，赛车 AAA 不适合在地图 aaa 上使用，赛车 BBB 不适合在地图 bbb 上使用，赛车 CCC 不适合在地图 ccc 上使用，而地图 xxx 则适合所有赛车参加。适合所有赛车参加的地图并不多见，最多只会有 ddd 张。 nnn 场游戏的地图可以用一个小写字母组成的字符串描述。 小 L 对游戏有一些特殊的要求，这些要求可以用四元组 (i,hi,j,hj)(i, h_i, j, h_j)(i,hi​,j,hj​) 来描述，表示若在第 iii 场使用型号为 hih_ihi​ 的车子，则第 jjj 场游戏要使用型号为 hjh_jhj​ 的车子。 你能帮小 L 选择每场游戏使用的赛车吗？如果有多种方案，输出任意一种方案。如果无解，输出 −1-1−1 。 Constraints n≤50000n\leq 50000n≤50000 ， m≤100000m\leq 100000m≤100000 ， d≤8d \leq 8d≤8 Solution 据题意显然需要为 2-SAT 。因为 xxx 的地图适合三种赛车，且最多只有 888 张，所以我们可以通过枚举每张 xxx 的地图为 aaa 或 bbb 来将问题转化为 2-SAT 的裸题。 对于一条限制，点 iii 代表第 iii 场选择了赛车 hih_ihi​ ，点 i′i&#x27;i′ 代表不选择赛车 hih_ihi​ ，点 jjj 与点 j′j&#x27;j′ 同理。具体连边方式为：若第 iii 场无法使用 hih_ihi​ ，直接跳过；若第 jjj 场无法使用 hjh_jhj​ ，则连边 iii 到 i′i&#x27;i′ ，代表一旦选择 iii 则无解；否则连边 iii 到 jjj ， j′j&#x27;j′ 到 i′i&#x27;i′ 。 建完图以后 tarjan 缩点，判断是否有可行方案。输出方案时输出强连通分量编号较小的一个即可。 时间复杂度 O(m⋅2d)O(m\cdot 2^d)O(m⋅2d) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;int n,d,m,cnt,tim,color,top,pos[10];int first[N],ci[N],hi[N],cj[N],hj[N];int s[N],low[N],dfn[N],sta[N],c[N];bool vis[N];char ch[N];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int get()&#123; char c=getchar(); while(c&lt;'A'||c&gt;'C')c=getchar(); return c-'A';&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++tim; sta[++top]=x;vis[x]=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!dfn[to])tarjan(to),low[x]=min(low[x],low[to]); else if(vis[to])low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; color++; while(sta[top]!=x)vis[sta[top]]=false,c[sta[top--]]=color; vis[x]=false;c[x]=color;top--; &#125;&#125;int id(int x,int c)&#123; if(!s[x])return c==1?x:x+n; else return c==0?x:x+n;&#125;int xo(int x)&#123;return x&gt;n?x-n:x+n;&#125;bool solve(int state)&#123; cnt=tim=color=top=0; memset(c,0,sizeof(c)); memset(vis,0,sizeof(vis)); memset(low,0,sizeof(low)); memset(dfn,0,sizeof(dfn)); memset(first,0,sizeof(first)); for(int i=0;i&lt;d;i++) if(state&amp;(1&lt;&lt;i))s[pos[i+1]]=0; else s[pos[i+1]]=1; for(int i=1;i&lt;=m;i++) &#123; if(hi[i]==s[ci[i]])continue; int x=id(ci[i],hi[i]),y=id(cj[i],hj[i]); if(hj[i]==s[cj[i]])&#123;ins(x,xo(x));continue;&#125; ins(x,y);ins(xo(y),xo(x)); &#125; for(int i=1;i&lt;=n*2;i++) if(!dfn[i])tarjan(i); for(int i=1;i&lt;=n;i++) if(c[i]==c[n+i])return false; for(int i=1;i&lt;=n;i++) if(c[i]&lt;c[i+n]) &#123; if(!s[i])putchar('B'); else putchar('A'); &#125; else &#123; if(s[i]==2)putchar('B'); else putchar('C'); &#125; return true;&#125;int main()&#123; n=read();read(); scanf("%s",ch+1);m=read(); for(int i=1;i&lt;=n;i++) &#123; s[i]=ch[i]-'a'; if(ch[i]=='x')pos[++d]=i; &#125; for(int i=1;i&lt;=m;i++) ci[i]=read(),hi[i]=get(), cj[i]=read(),hj[i]=get(); for(int i=0;i&lt;(1&lt;&lt;d);i++) if(solve(i))return 0; printf("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>2-SAT</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2304」「NOI2017」泳池]]></title>
    <url>%2Floj2304%2F</url>
    <content type="text"><![CDATA[久莲是个爱玩的女孩子。 暑假终于到了，久莲决定请她的朋友们来游泳，她打算先在她家的私人海滩外圈一块长方形的海域作为游泳场。然而大海里有着各种各样的危险，有些地方水太深，有些地方有带毒的水母出没。她想让圈出来的这一块海域都是安全的。 经过初步分析，这块海域可视为一个底边长为 NNN 米，高为 100110011001 米的长方形网格。其中网格的底边对应着她家的私人海滩，每一个 1m×1m1m\times 1m1m×1m 的小正方形都代表着一个单位海域。她拜托了她爸爸明天去测量每一个小正方形是否安全。在得知了信息之后，她要做的就是圈出她想要的游泳场啦。 她心目中理想的游泳场满足如下三个条件： 必须保证安全性。即游泳场中的每一个单位海域都是安全的。 必须是矩形。即游泳场必须是整个网格中的一个 a×ba\times ba×b 的子网格。 必须和海滩相邻。即游泳场的下边界必须紧贴网格的下边界。 为了让朋友们玩的开心，她想让游泳场的面积尽可能的大。 虽然她要明天才能知道每一个单位海域是否安全，但是她现在就想行动起来估计一下她的游泳场面积有多大。经过简单的估计，她假设每一个单位海域都有独立的 qqq 的概率是安全的， 1−q 的概率是不安全的。她想要知道她能选择的最大的游泳场的面积恰好为 KKK 的概率是多少。 然而久莲对数学并不感兴趣，因此她想让你来帮她计算一下这个数值。 Constraints n≤109n \leq 10^9n≤109 ， K≤1000K \leq 1000K≤1000 Solution 转化问题为求游泳场面积小于 KKK 的概率，最终答案为 K+1K+1K+1 的计算结果减去 KKK 的计算结果。 令 f(i,j)f(i,j)f(i,j) 表示长为 iii ，每一行高度至少为 jjj ，且满足条件的概率。可得： f(i,j)={0(i⋅j≥K)f(i,j+1)+qj⋅(1−q)⋅∑k=0i−1f(k,j+1)⋅f(i−k−1,j)(i⋅j&lt;K)f(i,j) = \begin{cases} 0 &amp; (i\cdot j \ge K)\\ f(i,j+1)+q^j\cdot (1-q)\cdot \sum_{k=0}^{i-1} f(k,j+1)\cdot f(i-k-1,j) &amp; (i \cdot j &lt; K) \end{cases} f(i,j)={0f(i,j+1)+qj⋅(1−q)⋅∑k=0i−1​f(k,j+1)⋅f(i−k−1,j)​(i⋅j≥K)(i⋅j&lt;K)​ 特殊地，当 i=0i=0i=0 时， f(i,j)=1f(i,j)=1f(i,j)=1 。 计算结果即为 f(n,0)f(n,0)f(n,0) ，时间复杂度 O(nklogk)O(nklogk)O(nklogk) ，可以通过 70 分，下面放出的代码也是 70 分的代码。 对于接下来的分数，因为当 i≥Ki\ge Ki≥K 时，只有 f(i,0)f(i,0)f(i,0) 的值不为 000 ，所以当 i&gt;=Ki&gt;=Ki&gt;=K 时有式子： f(i,0)=(1−q)⋅∑k=0K−1f(k,1)⋅f(i−k−1,0)f(i,0) = (1-q)\cdot \sum_{k=0}^{K-1} f(k,1)\cdot f(i-k-1,0) f(i,0)=(1−q)⋅k=0∑K−1​f(k,1)⋅f(i−k−1,0) 然后……先屯着了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e3+5;const int mod=998244353;int n,m,x,y,q,K;int ans,tmp,mi[N],f[N][N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int inv(int x)&#123;return power(x,mod-2);&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void work()&#123; memset(f,0,sizeof(f)); for(int i=0;i&lt;=K;i++)f[0][i]=1; for(int i=1;i&lt;=n;i++) for(int j=(K-1)/i;j&gt;=0;j--) &#123; f[i][j]=f[i][j+1]; for(int k=0;k&lt;=i-1;k++) Mod(f[i][j],1ll*(mod+1-q)*mi[j]%mod*f[k][j+1]%mod*f[i-k-1][j]%mod); &#125; ans=f[n][0];&#125;int main()&#123; n=read();m=read();x=read();y=read(); q=1ll*x*inv(y)%mod; mi[0]=1;for(int i=1;i&lt;=m+1;i++)mi[i]=1ll*mi[i-1]*q%mod; K=m;work();tmp=(mod-ans)%mod; K=m+1;work();Mod(ans,tmp); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>概率dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2303」「NOI2017」蚯蚓排队]]></title>
    <url>%2Floj2303%2F</url>
    <content type="text"><![CDATA[蚯蚓幼儿园有 nnn 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。 所有蚯蚓用从 111 到 nnn 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 666 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。 神刀手将会依次进行 mmm 次操作，每个操作都是以下三种操作中的一种： 给出 iii 和 jjj ，令 iii 号蚯蚓与 jjj 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 jjj 号蚯蚓紧挨在 iii 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。 给出 iii ，令 iii 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， iii 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。 给出一个正整数 kkk 和一个长度至少为 kkk 的数字串 sss ，对于 sss 的每个长度为 kkk 的连续子串 ttt （这样的子串共有 ∣s∣−k+1|s|-k+1∣s∣−k+1 个，其中 ∣s∣|s|∣s∣ 为 sss 的长度），定义函数 f(t)f(t)f(t) ，询问所有这些 f(t)f(t)f(t) 的乘积对 998244353998244353998244353 取模后的结果。其中 f(t)f(t)f(t) 的定义如下： 对于当前的蚯蚓队伍，定义某个蚯蚓的向后 kkk 数字串为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 kkk 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 kkk 只，则其没有向后 kkk 数字串。 而 f(t)f(t)f(t) 表示所有蚯蚓中，向后 kkk 数字串恰好为 ttt 的蚯蚓只数。 Constraints n≤2×105n \leq 2 \times 10^{5}n≤2×105 ， m≤5×105m \leq 5 \times 10^{5}m≤5×105 ， k≤50k \leq 50k≤50 ， ∑∣s∣≤107\sum |s| \leq 10^{7}∑∣s∣≤107 Solution 暴力维护对每个队伍链表，维护每条蚯蚓向后长度为 kkk 的字符串的哈希值。 每一次修改操作只需要暴力修改跨越操作点的 k2k^2k2 个字符串，查询时直接枚举。 从总体考虑合并操作，可得时间复杂度实际为 O(ck2+nk+∑∣s∣)O(ck^2+nk+\sum |s|)O(ck2+nk+∑∣s∣) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int L=1e7+5;const int K=55;const int sbas=233;const int bbas=173;const int smod=3715417;const int bmod=1e9+7;const int mod=998244353;int n,m,cnt,ans,num,first[smod+5];int op,x,y,z,leng,nxt[N],lst[N];int a[N],S[K],B[K],s[N][K],b[N][K];int SS,BB,ss[L],bb[L];char ch[L];struct edge&#123;int to,next,k,c;&#125;e[N*K];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void ins(int small,int big,int len,int val)&#123; for(int i=first[small];i;i=e[i].next) if(e[i].to==big&amp;&amp;e[i].k==len)&#123;Mod(e[i].c,val);return;&#125; e[++cnt]=(edge)&#123;big,first[small],len,val&#125;;first[small]=cnt;&#125;int main()&#123; n=read();m=read(); S[0]=1;for(int i=1;i&lt;=50;i++)S[i]=1ll*S[i-1]*sbas%smod; B[0]=1;for(int i=1;i&lt;=50;i++)B[i]=1ll*B[i-1]*bbas%bmod; for(int i=1;i&lt;=n;i++) &#123; a[i]=read(); s[i][1]=b[i][1]=a[i]; ins(a[i],a[i],1,1); &#125; while(m--) &#123; op=read(); if(op==1) &#123; x=read();y=read();nxt[x]=y;lst[y]=x; for(int i=1;i&lt;50&amp;&amp;x;i++) &#123; z=y; for(int j=1;i+j&lt;=50&amp;&amp;z;j++) &#123; s[x][i+j]=(1ll*s[x][i+j-1]*sbas+a[z])%smod; b[x][i+j]=(1ll*b[x][i+j-1]*bbas+a[z])%bmod; ins(s[x][i+j],b[x][i+j],i+j,1);z=nxt[z]; &#125; x=lst[x]; &#125; &#125; else if(op==2) &#123; x=read();y=nxt[x];nxt[x]=lst[y]=0; for(int i=1;i&lt;50&amp;&amp;x;i++) &#123; z=y; for(int j=1;i+j&lt;=50&amp;&amp;z;j++) ins(s[x][i+j],b[x][i+j],i+j,-1),z=nxt[z]; x=lst[x]; &#125; &#125; else &#123; scanf("%s",ch+1);leng=strlen(ch+1); x=read();ans=1; for(int i=1;i&lt;=leng;i++) &#123; ss[i]=(1ll*ss[i-1]*sbas+ch[i]-'0')%smod; bb[i]=(1ll*bb[i-1]*bbas+ch[i]-'0')%bmod; &#125; for(int i=1;i&lt;=leng-x+1;i++) &#123; SS=(ss[i+x-1]-1ll*ss[i-1]*S[x]%smod+smod)%smod; BB=(bb[i+x-1]-1ll*bb[i-1]*B[x]%bmod+bmod)%bmod; num=0; for(int i=first[SS];i;i=e[i].next) if(e[i].to==BB&amp;&amp;e[i].k==x)&#123;num=e[i].c;break;&#125; ans=1ll*ans*num%mod; &#125; printf("%d\n",ans); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
        <tag>哈希</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 2302」「NOI2017」整数]]></title>
    <url>%2Floj2302%2F</url>
    <content type="text"><![CDATA[在人类智慧的山巅，有着一台字长为 104857610485761048576 位的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。 不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你…… P 博士将他的计算任务抽象为对一个整数的操作。 具体来说，有一个整数 xxx ，一开始为 000。 接下来有 nnn 个操作，每个操作都是以下两种类型中的一种： 111 aaa bbb ：将 xxx 加上整数 a⋅2ba \cdot 2 ^ ba⋅2b ，其中 aaa 为一个整数，bbb 为一个非负整数 222 kkk ：询问 xxx 在用二进制表示时，位权为 2k2 ^ k2k​​ 的位的值（即这一位上的 111 代表 2k2 ^ k2k ） 保证在任何时候，x≥0x \ge 0x≥0 。 Constraints $ n\leq 1000000$ ， ∣a∣≤1000000000|a| \leq 1000000000∣a∣≤1000000000 ， 0≤b,k≤30⋅n0\leq b,k \leq 30\cdot n0≤b,k≤30⋅n Solution 数据范围提示得很明显……需要压位，每一个数字储存 303030 位。 首先开两个数组，一个储存加法，一个储存减法，修改的时候在两个数组上暴力加法暴力进位即可。 现在考虑处理询问。因为保证在任何时刻， x≥0x \ge 0x≥0 ，所以我们判断第 kkk 位时其实只与加法、减法第 000 到 k−1k-1k−1 位的数字的大小有关。根据减法的规则，稍微分一下类可得：若后面部分的数字差为负，则答案为相应位上的数字的同或，否则为异或。 判断第 000 到 k−1k-1k−1 位的加法数字和减法数字的大小，等价于判断字典序。找到第一个不相同的位置，判断大小即可。我们使用线段树来维护，利用线段树判断 000 到 k−1k-1k−1 的区间内最靠右的加法数组和减法数组不一样的位置。 时间复杂度 O(nlog2n)O(nlog^2 n)O(nlog2n) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)#define LL long longusing namespace std;const int N=1e6+5;const int base=1&lt;&lt;30;int n,t1,t2,t3,op,pos;LL a,b,p,q,tmp,las,nex;bool fl;int L[N*4],R[N*4];LL add[N],dec[N],id[N],t[N*4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void build(int x,int l,int r)&#123; L[x]=l;R[x]=r; if(l==r)&#123;id[l]=x;return;&#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid); build(rc,mid+1,r);&#125;void change(int x,LL val)&#123; x=id[x];t[x]^=val; while(x!=1)&#123;x&gt;&gt;=1;t[x]=max(t[lc],t[rc]);&#125;&#125;void modify(LL a,int pos,LL *x)&#123; las=x[pos];nex=x[pos+1]; while(a) &#123; x[pos]+=a%base; if(x[pos]&gt;=base) &#123; x[pos+1]+=x[pos]/base; x[pos]%=base; &#125; change(pos,las^x[pos]); pos++;a/=base; las=nex;nex=x[pos+1]; &#125; if(x[pos]&gt;=base) &#123; x[pos+1]+=x[pos]/base; x[pos]%=base; &#125; change(pos,las^x[pos]);&#125;void find(int x)&#123; x=id[x]; while(x!=1) &#123; if((x&amp;1)&amp;&amp;t[x-1])&#123;x--;break;&#125; x&gt;&gt;=1; &#125; if(x==1)return; while(L[x]!=R[x]) &#123; if(t[rc])x=rc; else x=lc; &#125; t3=L[x];return;&#125;int main()&#123; n=read();t1=read();t2=read();t3=read(); build(1,1,n+2); for(int i=1;i&lt;=n;i++) &#123; op=read();a=read(); if(op==1) &#123; b=read();pos=b/30+1;b%=30; if(a==0)continue; if(a&gt;0)fl=true; else a=-a,fl=false; a&lt;&lt;=b; if(fl)modify(a,pos,add); else modify(a,pos,dec); &#125; else &#123; pos=a/30+1;a%=30; p=add[pos]%(1&lt;&lt;a); q=dec[pos]%(1&lt;&lt;a); t1=(add[pos]&gt;&gt;a)&amp;1; t2=(dec[pos]&gt;&gt;a)&amp;1; if(p!=q) &#123; if(p&gt;q)printf("%d\n",t1^t2); else printf("%d\n",t1==t2); continue; &#125; t3=0;find(pos); if(add[t3]&gt;=dec[t3])printf("%d\n",t1^t2); else printf("%d\n",t1==t2); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1618」树或非树]]></title>
    <url>%2F51nod1618%2F</url>
    <content type="text"><![CDATA[GGG 是一张由 nnn 个点和 nnn 条边组成的无向图。 GGG 中没有自环和重边。每条边有两种状态“开”和“关”。一开始，所有的边都是“关”着的。 现在有 mmm 个操作 (v,u)(v,u)(v,u) ，表示将从 vvv 到 uuu 的最短路上的边改变状态（如果状态为“开”则变成“关”，反之，变成“开”）。如果 vvv 到 uuu 存在多条最短路，则我们选取点序列字典序最小的那一条。 比如，将所有从 vvv 到 uuu 的路径上的点表示成序列为 v,v1,v2,⋯,uv,v_1,v_2,\cdots ,uv,v1​,v2​,⋯,u 。那么我们从中取字典序最小的那一条。 在每一次操作后，你需要计算在图中由所有点和状态为“开”的边所组成图的连通块的数目。 Constraints 1≤n,m≤1000001\leq n,m \leq 1000001≤n,m≤100000 Solution 题目保证图是联通的，所以整个图为一棵环套树，去掉环之后则是森林。然后就可以 dfs 序链剖然后上线段树了，修改操作路径异或即可，其中环在线段树上要占用环大小的连续区间。 对于树来说，连通块个数即为点数 - 边数。询问时需要特判一下环上的情况，如果整个环都是开的，则 ans++ 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)#define LL long longusing namespace std;const int N=1e5+5;int n,m,cnt,tot,ctot,tim,son;int x,y,L,R,dx,dy,ans;int first[N],st[N],c[N],pos[N],be[N];int fa[N],sz[N],deep[N],dfn[N],tp[N];int s[N*8],tag[N*8];bool vis[N];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void circle(int x,int fa)&#123; vis[x]=true;st[++tot]=x; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; if(!vis[to])circle(to,x); else &#123; if(ctot)return; y=0;while(y!=to)y=st[tot--],c[++ctot]=y; &#125; &#125; tot--;&#125;void dfs1(int x,int last)&#123; sz[x]=1;deep[x]=deep[last]+1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==last||pos[to])continue; fa[to]=x;be[to]=be[x]; dfs1(to,x);sz[x]+=sz[to]; &#125;&#125;void dfs2(int x,int top)&#123; dfn[x]=++tim;tp[x]=top;son=0; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(dfn[to]||pos[to])continue; if(sz[to]&gt;sz[son])son=to; &#125; if(!son)return; dfs2(son,top); for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(dfn[to]||pos[to])continue; dfs2(to,to); &#125;&#125;void down(int x,int l,int r)&#123; if(!tag[x]||l==r)return; tag[x]=0;int mid=(l+r)&gt;&gt;1; tag[lc]^=1;tag[rc]^=1; s[lc]=mid-l+1-s[lc]; s[rc]=r-mid-s[rc];&#125;void modify(int x,int l,int r)&#123; down(x,l,r); if(L&lt;=l&amp;&amp;r&lt;=R) &#123; s[x]=r-l+1-s[x]; tag[x]^=1;return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(lc,l,mid); if(R&gt;mid)modify(rc,mid+1,r); s[x]=s[lc]+s[rc];&#125;int query(int x,int l,int r)&#123; down(x,l,r); if(L&lt;=l&amp;&amp;r&lt;=R)return s[x]; int mid=(l+r)&gt;&gt;1,sum=0; if(L&lt;=mid)sum+=query(lc,l,mid); if(R&gt;mid)sum+=query(rc,mid+1,r); return sum;&#125;void open(int x,int y)&#123; if(x&gt;y)return; L=x;R=y;modify(1,1,n+ctot);&#125;void change(int x,int y)&#123; while(tp[x]!=tp[y]) &#123; if(deep[tp[x]]&lt;deep[tp[y]])swap(x,y); open(dfn[tp[x]],dfn[x]);x=fa[tp[x]]; &#125; if(deep[x]&lt;deep[y])swap(x,y); open(dfn[y]+1,dfn[x]);&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) &#123; x=read();y=read(); ins(x,y);ins(y,x); &#125; circle(1,-1); for(int i=1;i&lt;=ctot;i++)pos[c[i]]=i; for(int i=1;i&lt;=ctot;i++) &#123; be[c[i]]=c[i]; dfs1(c[i],c[i]);dfs2(c[i],c[i]); &#125; while(m--) &#123; x=read();y=read(); if(be[x]==be[y]) &#123; change(x,y); ans=n-s[1];L=n+1;R=n+ctot; if(query(1,1,n+ctot)==ctot)ans++; printf("%d\n",ans); continue; &#125; change(x,be[x]);change(y,be[y]); x=be[x];y=be[y];dx=pos[x];dy=pos[y]; if(dx&lt;dy) &#123; if(dy-dx&gt;ctot+dx-dy||(dy-dx==ctot+dx-dy&amp;&amp;c[dx+1]&gt;c[(dx-2+ctot)%ctot+1])) open(n+1,n+dx),open(n+dy+1,n+ctot); else open(n+dx+1,n+dy); &#125; else &#123; if(dx-dy&gt;ctot+dy-dx||(dx-dy==ctot+dy-dx&amp;&amp;c[dx-1]&gt;c[dx%ctot+1])) open(n+1,n+dy),open(n+dx+1,n+ctot); else open(n+dy+1,n+dx); &#125; ans=n-s[1];L=n+1;R=n+ctot; if(query(1,1,n+ctot)==ctot)ans++; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1646」幸运的车票]]></title>
    <url>%2F51nod1646%2F</url>
    <content type="text"><![CDATA[华沙收集车票已经有一段时间了。他收集了上千张的车票。华沙已经厌倦了传统幸运车票的定义。所以他想寻找一个不一样的定义。华沙不理解为什么所有的车票要分为幸运的和不幸运的。他认为所有的车票都是幸运的，只是幸运的程度不一样。有了这个想法，他重新定义了车票的幸运程度。一张车票有 2n2n2n 位数字。数字 0−90-90−9 的书写如图。 就像在电子时钟里看到的数字一样，用 777 根线条表示数字。每根线条有两种状态，着色或不着色。着色的线条组成一个数字。华沙认为所有的数字都是这么书写的。把车票号码的右半部分放在左半部分上面，那么第 111 位数字就会和第 n+1n+1n+1 位重合，第 222 位就会和第 n+2n+2n+2 重合…，第 nnn 位数字和第 2n2n2n 位数字重合。对于每对重合的数字，统计这两个数字重合后都着色的线条数量。然后把每对统计的结果加起来，就是车票的幸运程度了。 现在，给定一个 2n2n2n 位数字的车票号码。找出一个 2n2n2n 位数字的车票号码，使得这个号码在数值上大于给定的号码，在幸运程度上也大于给定的号码。如果存在多个这样的号码，我们选择数值最小的那个号码。 Constraints 1≤n≤1000001\leq n \leq 1000001≤n≤100000 Solution 一个数字的结构可以压缩成一个七位的二进制数，每一对数字幸运值即为对应二进制数取与后的 111 的位数。 需要在幸运值大的情况下字典序最小，则可从最后一位开始对每一位枚举要替代的数字。若当前位没有符合条件的可填数，则将其赋值为 888 。当出现第一个幸运值大的情况时，对后面进行贪心，贪心完的结果即为答案。 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int c[10]=&#123;119,36,93,109,46,107,123,37,127,111&#125;;int n,k,t,s,x,cnt,ch,a[N];char ss[N];int calc(int a,int b)&#123;return __builtin_popcount(c[a]&amp;c[b]);&#125;int main()&#123; scanf("%s",ss+1); n=strlen(ss+1);k=n/2; for(int i=1;i&lt;=n;i++)a[i]=ss[i]-'0'; for(int i=n;i&gt;=1;i--) &#123; if(i&gt;k)t=a[i-k]; else t=a[i+k]; cnt=calc(a[i],t); for(int j=a[i]+1;j&lt;=9;j++) &#123; if(s+calc(t,j)&lt;=cnt)continue; a[i]=j;ch=s+calc(t,j)-cnt; for(int l=i+1;l&lt;=n;l++) &#123; x=a[l&gt;k?l-k:l+k]; for(int m=0;m&lt;=9;m++) &#123; if(ch-calc(x,a[l])+calc(x,m)&lt;=0)continue; ch=ch-calc(x,a[l])+calc(x,m); a[l]=m;break; &#125; &#125; for(int l=1;l&lt;=n;l++)printf("%d",a[l]); return 0; &#125; a[i]=8;s+=calc(a[i],t)-cnt; &#125; printf("-1"); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1647」小Z的trie]]></title>
    <url>%2F51nod1647%2F</url>
    <content type="text"><![CDATA[NOIP 编号为 ZJ-267 的小 Z 在 NOIP 中 AK 啦！ 小 Z 打算去冲击省选，于是开始学习 trie 。 有一天，他得到了 NNN 个字符串。 他先建立一个根节点，对于每一个字符串，他都从根节点开始一点点插入。 小 Z 不满足于此。他的大脑里盘旋着 MMM 个问题： 如果给定一个二元组 (s,t)(s,t)(s,t) （ sss，ttt 都是 trie 中的节点且 sss 是 ttt 的祖先），存在多少个二元组 (x,y)(x,y)(x,y) （ xxx，yyy 都是 trie 中的节点且 xxx 是 yyy 的祖先），满足 sss ~ ttt 路径上的字符串和 xxx ~ yyy 路径上的字符串完全一样？ 注意 sss 可以等于 ttt ， xxx 也可以等于 yyy 。 Constraints 1≤N,M≤1000001\leq N,M \leq 1000001≤N,M≤100000 ， 1≤sum≤10000001\leq sum \leq 10000001≤sum≤1000000 Solution 先构建出 trie ，然后在 trie 上面建 sam。分别需要记录下原串的每个节点在 trie 上的位置和 trie 上的每个节点在 sam 上的位置。 对于一个询问，从 ttt 对应在 sam 上面的节点开始，在 parent 树上跳直到深度最浅的满足节点对应长度不小于询问串的节点为止，该节点的 right 集合大小即为答案。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;int n,m,p,l,r,cnt,length,head,tail;int pos[N],spos[N],len[N];char s[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;struct sam&#123; int size,root,len; int mx[N*2],fa[N*2],sz[N*2],ch[N*2][26]; int c[N],id[N*2],f[N*2][21]; sam() &#123; size=root=1; memset(sz,0,sizeof(sz)); memset(ch,0,sizeof(ch)); &#125; int ins(int c,int x) &#123; int np=++size;mx[np]=mx[x]+1; len=max(len,mx[np]);sz[np]=1; while(x&amp;&amp;!ch[x][c])ch[x][c]=np,x=fa[x]; if(!x)fa[np]=root; else &#123; int y=ch[x][c]; if(mx[y]==mx[x]+1)fa[np]=y; else &#123; int nq=++size; memcpy(ch[nq],ch[y],sizeof(ch[y])); mx[nq]=mx[x]+1; fa[nq]=fa[y];fa[y]=fa[np]=nq; while(x&amp;&amp;ch[x][c]==y)ch[x][c]=nq,x=fa[x]; &#125; &#125; return np; &#125; void build() &#123; for(int i=1;i&lt;=size;i++)c[mx[i]]++; for(int i=1;i&lt;=len;i++)c[i]+=c[i-1]; for(int i=1;i&lt;=size;i++)id[c[mx[i]]--]=i; for(int i=size;i&gt;=1;i--)sz[fa[id[i]]]+=sz[id[i]]; for(int i=1;i&lt;=size;i++) &#123; int x=id[i];f[x][0]=fa[x]; for(int j=1;j&lt;=20;j++)f[x][j]=f[f[x][j-1]][j-1]; &#125; &#125; int find(int x,int len) &#123; for(int i=20;i&gt;=0;i--) if(mx[f[x][i]]&gt;=len)x=f[x][i]; return sz[x]; &#125;&#125;S;struct node&#123;int id,np;&#125;t,q[N];struct trie&#123; int sz,ch[N][26]; trie()&#123;sz=0;memset(ch,0,sizeof(ch));&#125; void insert(char *s,int n) &#123; int cur=0; for(int i=0;i&lt;n;i++) &#123; int c=s[i]-'a'; if(!ch[cur][c])ch[cur][c]=++sz; cur=ch[cur][c];pos[++cnt]=cur; &#125; &#125; void bfs() &#123; q[tail++]=(node)&#123;0,1&#125;; while(head!=tail) &#123; t=q[head++]; int u=t.id,last=t.np; for(int c=0;c&lt;26;c++) &#123; if(!ch[u][c])continue; int np=S.ins(c,last); spos[ch[u][c]]=np; q[tail++]=(node)&#123;ch[u][c],np&#125;; &#125; &#125; &#125;&#125;T;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++) &#123; scanf("%s",s); length=strlen(s); len[i]=len[i-1]+length; T.insert(s,length); &#125; T.bfs();S.build(); m=read(); while(m--) &#123; p=read();l=read();r=read(); printf("%d\n",S.find(spos[pos[r+len[p-1]]],r-l+1)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>后缀自动机</tag>
        <tag>trie</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1648」洞]]></title>
    <url>%2F51nod1648%2F</url>
    <content type="text"><![CDATA[小 P 非常喜欢玩。他最喜欢玩的一个游戏就是《洞》，这个游戏遵循以下规则： 有 NNN 个洞呈直线分布，并且从左到右依次编号为 111 到 NNN 。每个洞都有它自己的能量值（编号为 iii 的洞有能量值 aia_iai​ ）。如果你把一个球扔到洞 iii ，它会迅速调到洞 i+aii+a_ii+ai​ ，以此类推。如果没有编号为 i+aii+a_ii+ai​ 的洞，这个球将会跳到这洞外，结束循环。玩家将会执行 MMM 次以下两种操作之一： 设置洞 aaa 的能量值为 bbb 。 将球扔到洞 aaa ，计算球跳到洞外之前跳跃的次数，以及球刚好跳到洞外之前最后经过的洞的编号。 小 P 不擅长数学，所以将由你实现这些计算。 Constraints 1≤n,m≤1000001\leq n,m \leq 1000001≤n,m≤100000 Solution 裸的分块。 需要注意的一点是，要记录下跳出去之前的最后一个洞。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,m,block,l,r,op,x,ans;int a[N],b[N],to[N],cnt[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void modify(int i)&#123; l=(i-1)*block+1; r=min(n,i*block); for(int j=r;j&gt;=l;j--) &#123; if(a[j]&gt;r) &#123; if(a[j]&gt;n)to[j]=j,cnt[j]=0; else to[j]=a[j],cnt[j]=1; &#125; else to[j]=to[a[j]],cnt[j]=cnt[a[j]]+1; &#125;&#125;int main()&#123; n=read();m=read();block=sqrt(n); for(int i=1;i&lt;=n;i++) a[i]=i+read(),b[i]=(i-1)/block+1; for(int i=1;i&lt;=(n-1)/block+1;i++)modify(i); while(m--) &#123; op=read();x=read(); if(!op)a[x]=x+read(),modify(b[x]); else &#123; ans=0; while(x!=to[x])ans+=cnt[x],x=to[x]; printf("%d %d\n",x,ans+1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nood 1769」Clarke and math2]]></title>
    <url>%2F51nod1769%2F</url>
    <content type="text"><![CDATA[克拉克是一名人格分裂患者。某一天他变成一名数学家，在研究奇怪的东西。 他突然想算这么一个式子，给出 f(i),1≤i≤nf(i), 1 \le i \le nf(i),1≤i≤n ，要求算： g(i)=∑i1∣i∑i2∣i1∑i3∣i2⋯∑ik∣ik−1f(ik) mod 1000000007 (1≤i≤n,ij∈N+)\displaystyle g(i) = \sum_{i_1 \mid i} \sum_{i_2 \mid i_1} \sum_{i_3 \mid i_2} \cdots \sum_{i_k \mid i_{k-1}} f(i_k) \text{ mod } 1000000007 \ \ (1 \le i \le n,i_j \in \mathbb{N}^+) g(i)=i1​∣i∑​i2​∣i1​∑​i3​∣i2​∑​⋯ik​∣ik−1​∑​f(ik​) mod 1000000007 (1≤i≤n,ij​∈N+) ∣\mid∣ 是整除的意思,比如 i1=5i_1 = 5i1​=5 , i2=10i_2 = 10i2​=10 则 i1∣i2i_1 \mid i_2i1​∣i2​。 Constraints 1≤n≤5000001 \leq n \leq 5000001≤n≤500000 ， 1≤k≤1010000001 \leq k \leq 10^{1000000}1≤k≤101000000 Solution 考虑从 iki_kik​ 到 iii 的变化过程，等价于 iki_kik​ 乘上 kkk 个数得到 iii ，实际只要求满足 kkk 个数乘起来为 iik\frac{i}{i_k}ik​i​ 的因数的方案数即可。 对 iik\frac{i}{i_k}ik​i​ 分解质因数，考虑其中的一个质因子 ppp 以及它的次数 xxx ，利用隔板法可得当前质因子的贡献是 (k−x−1k−1)\binom{k-x-1}{k-1}(k−1k−x−1​) （将 xxx 个 ppp 分配到这 kkk 个数里）。 kkk 很大，用 Lucas 定理可得直接将 kkk 取模即可。 剩下的就直接线性筛了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e5+5;const int mod=1e9+7;int n,K,cnt,now;int f[N],inv[N],v[N],e[N],pri[N],ans[N];bool np[N];int read()&#123; LL x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=(x*10+c-'0')%mod;c=getchar();&#125; return x*f;&#125;int main()&#123; n=read();K=read(); inv[1]=1; for(int i=2;i&lt;=n;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod; for(int i=1;i&lt;=n;i++)f[i]=read(); v[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(!np[i])&#123;pri[++cnt]=i;v[i]=K;e[i]=1;&#125; for(int j=1;i*pri[j]&lt;=n;j++) &#123; now=i*pri[j]; np[now]=true; if(i%pri[j]==0) &#123; e[now]=e[i]+1; v[now]=1ll*v[i]*(e[now]+K-1)%mod*inv[e[now]]%mod; break; &#125; e[now]=1; v[now]=1ll*v[i]*K%mod; &#125; &#125; for(int i=1;i&lt;=n;i++) for(int j=1;i*j&lt;=n;j++) ans[i*j]=(ans[i*j]+1ll*v[i]*f[j]%mod)%mod; for(int i=1;i&lt;=n;i++)printf("%d ",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1792」Jabby's segment tree]]></title>
    <url>%2F51nod1792%2F</url>
    <content type="text"><![CDATA[线段树是一种经典的数据结构，一颗 [1,n][1,n][1,n] 的线段树他的根是 [1,n][1,n][1,n] ，当一个线段树的结点是 [l,r][l,r][l,r] 时，设 mid=(l+r)/2mid=(l+r)/2mid=(l+r)/2 ，则这个结点的左儿子右儿子分别是 [l,mid][l,mid][l,mid] ， [mid+1,r][mid+1,r][mid+1,r] 。 当我们在线段树上跑 [x,y][x,y][x,y] 询问时，一般是从根节点开始计算的，设现在所在结点是 [l,r][l,r][l,r] ，有以下几种分支： 若 [x,y][x,y][x,y] 包含 [l,r][l,r][l,r] ，计算结束。 否则，若左儿子和 [x,y][x,y][x,y] 有交，计算左儿子，若右儿子和 [x,y][x,y][x,y] 有交，计算右儿子。 定义询问 [x,y][x,y][x,y] 的费用是询问时计算了几个结点。 给定 QQQ 次询问，每次给定 lll , rrr ，求满足 l≤x≤y≤rl\leq x\leq y\leq rl≤x≤y≤r 的 (x,y)(x,y)(x,y) 的费用之和。 Constraints 1≤n,Q≤1000001\leq n,Q \leq 1000001≤n,Q≤100000 Solution 直接在线段树上维护答案。 假设当前节点编号为 xxx ，代表的区间为 [l,r][l,r][l,r] ，则令： t(x)t(x)t(x) 表示两个端点都在区间 [l,r][l,r][l,r] 内的答案； tl(x)tl(x)tl(x) 表示查询左端点为 lll ，右端点位于 [l,r)[l,r)[l,r) 的答案； tr(x)tr(x)tr(x) 表示查询右端点为 rrr ，左端点位于 (l,r](l,r](l,r] 内的答案。 具体的统计方式见代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc (x&lt;&lt;1)#define rc (x&lt;&lt;1|1)#define LL long longusing namespace std;const int N=1e5+5;const int mod=1e9+7;int n,Q,L,R,ans;int t[N*4],tl[N*4],tr[N*4];void Mod(int &amp;a,int b)&#123;a+=b;while(a&gt;=mod)a-=mod;&#125;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void update(int x,int l,int r)&#123; int mid=(l+r)&gt;&gt;1; Mod(tl[x],tl[lc]+1); Mod(tl[x],tl[rc]+r-mid-1); Mod(tl[x],r-l); Mod(tr[x],tr[rc]+1); Mod(tr[x],tr[lc]+mid-l); Mod(tr[x],r-l); Mod(t[x],t[lc]); Mod(t[x],t[rc]); Mod(t[x],1ll*tr[lc]*(r-mid)%mod); Mod(t[x],1ll*tl[rc]*(mid-l+1)%mod); Mod(t[x],r-mid-1); Mod(t[x],mid-l); int len=r-l+1; Mod(t[x],1ll*len*(len+1)/2%mod);&#125;void build(int x,int l,int r)&#123; if(l==r)&#123;t[x]=1;return;&#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid); build(rc,mid+1,r); update(x,l,r);&#125;void calc(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; Mod(ans,t[x]); if(L&lt;l)Mod(ans,1ll*(tl[x]+1)*(l-L)%mod); if(R&gt;r)Mod(ans,1ll*(tr[x]+1)*(R-r)%mod); if(L&lt;l&amp;&amp;R&gt;r)Mod(ans,1ll*(l-L)*(R-r)%mod); return; &#125; int ll=max(L,l),rr=min(R,r),len=rr-ll+1; Mod(ans,1ll*len*(len+1)/2%mod); if(L&lt;l)Mod(ans,1ll*(l-L)*len%mod); if(R&gt;r)Mod(ans,1ll*(R-r)*len%mod); int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)calc(lc,l,mid); if(R&gt;mid)calc(rc,mid+1,r);&#125;int main()&#123; n=read();Q=read(); build(1,1,n); while(Q--) &#123; L=read();R=read(); ans=0;calc(1,1,n); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1743」雪之国度]]></title>
    <url>%2F51nod1743%2F</url>
    <content type="text"><![CDATA[雪之国度有 NNN 座城市，依次编号为 111 到 NNN，又有 MMM 条道路连接了其中的城市，每一条道路都连接了不同的 222 个城市，任何两座不同的城市之间可能不止一条道路。 雪之女王赋予了每一座城市不同的能量，其中第 iii 座城市被赋予的能量为 WiW_iWi​ 。如果城市 uuu 和 vvv 之间有一条道路，那么只要此刻雪之女王的能量不小于 ∣Wu−Wv∣|W_u-W_v|∣Wu​−Wv​∣ ，这条道路就是安全的。如果城市 uuu 和 vvv 之间存在两条没有重复道路的安全路径（其中每一段道路都是安全的），则认为这两座城市之间有着良好的贸易关系。 最近，雪之女王因为情感问题，她的能量产生巨大的波动。为了维持雪之国度的经济贸易，她希望你能帮忙对 QQQ 对城市进行调查。 对于第 jjj 对城市 uju_juj​ 和 vjv_jvj​ ，她希望知道在保证这两座城市之间有着良好贸易关系的前提之下，自己最少需要保持多少的能量。 Constraints 3≤N≤1000003\leq N\leq 1000003≤N≤100000 ， 3≤M≤5000003\leq M\leq 5000003≤M≤500000 ， 1≤Q≤1000001\leq Q\leq 1000001≤Q≤100000 ， 0≤W≤2000000\leq W\leq 2000000≤W≤200000 Solution 城市间存在两条没有重复道路的安全路径，即两座城市在同一个边双里。题意可以转化为，在保证两个城市在同一个边双联通分量的情况下，求最大边权的最小值。很容易想到一种做法：将边按照边权从小到大加入直到两座城市在同一个边双里。 首先构造出原图的最小生成树，然后考虑按照边权从小到大加入非树边。考虑加进一条非树边会造成的影响：在加入非树边 u−vu-vu−v 时，uuu 到 vvv 的简单路径上的所有点都会被缩进一个边双联通分量里，这时候我们可以给路径上的所有点打上这条非树边边权的标记，代表这个点与其父亲第一次进入同一个边双时该边双的最大边权。然后利用并查集将路径上的所有点缩成一个点，避免已更新过的点被重复更新。 现在考虑处理询问。利用并查集可以直接判断两个点最后是否在同一个边双里。若在，则答案为 uuu 和 vvv 路径上的除 lcalcalca 外节点标记最大值。 具体可以用倍增来实现，时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,m,Q,cnt,x,y,tot;int first[N],w[N],f[N];int deep[N],fa[N][17],v[N][17];bool ontr[N*5];struct node&#123;int x,y,v;&#125;a[N*5];struct edge&#123;int to,next,w;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.v&lt;b.v;&#125;void ins(int u,int v,int w)&#123;e[++cnt]=(edge)&#123;v,first[u],w&#125;;first[u]=cnt;&#125; int find(int t)&#123;return f[t]==t?t:f[t]=find(f[t]);&#125;void dfs(int x,int last)&#123; for(int i=1;(1&lt;&lt;i)&lt;=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==last)continue; fa[to][0]=x;v[to][0]=e[i].w; deep[to]=deep[x]+1;dfs(to,x); &#125;&#125;void modify(int &amp;x,int val)&#123;v[x][0]=val;f[x]=find(fa[x][0]);x=f[x];&#125;int tim=0;int lca(int x,int y)&#123; if(deep[x]&lt;deep[y])swap(x,y); int ans=0,d=deep[x]-deep[y]; for(int i=0;(1&lt;&lt;i)&lt;=d;i++) if((1&lt;&lt;i)&amp;d)ans=max(ans,v[x][i]),x=fa[x][i]; if(x==y)return ans; for(int i=16;i&gt;=0;i--) if(fa[x][i]!=fa[y][i]) &#123; ans=max(ans,max(v[x][i],v[y][i])); x=fa[x][i];y=fa[y][i]; &#125; ans=max(ans,max(v[x][0],v[y][0])); return ans;&#125;int main()&#123; n=read();m=read();Q=read(); for(int i=1;i&lt;=n;i++)w[i]=read(); for(int i=1;i&lt;=m;i++) &#123; a[i].x=read();a[i].y=read(); a[i].v=abs(w[a[i].x]-w[a[i].y]); &#125; sort(a+1,a+m+1,cmp); for(int i=1;i&lt;=n;i++)f[i]=i; for(int i=1;i&lt;=m;i++) &#123; x=find(a[i].x);y=find(a[i].y); if(x==y)continue; ins(a[i].x,a[i].y,a[i].v); ins(a[i].y,a[i].x,a[i].v); tot++;ontr[i]=true;f[y]=x; if(tot==n-1)break; &#125; dfs(1,-1); for(int i=1;i&lt;=n;i++)f[i]=i; for(int i=1;i&lt;=m;i++) &#123; if(ontr[i])continue; x=find(a[i].x);y=find(a[i].y); if(x==y)continue; while(x!=y) &#123; if(deep[x]&gt;deep[y])modify(x,a[i].v); else modify(y,a[i].v); &#125; &#125; for(int j=1;j&lt;=16;j++) for(int i=1;i&lt;=n;i++) v[i][j]=max(v[i][j-1],v[fa[i][j-1]][j-1]); while(Q--) &#123; x=read();y=read(); if(find(x)!=find(y))printf("infinitely\n"); else printf("%d\n",lca(x,y)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>最小生成树</tag>
        <tag>并查集</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1860」BigPrime]]></title>
    <url>%2F51nod1860%2F</url>
    <content type="text"><![CDATA[我们把所有大于整数 ppp 的质数称作大质数。 现在我们要统计区间 [a,b][a,b][a,b] 中有多少数其至少有一个约数是大质数。 Constraints p≤106p\leq 10^6p≤106 ， a≤109a\leq 10^9a≤109 ， b−a≤108b-a\leq 10^8b−a≤108 Solution 先把 222 至 ppp 所有质数预处理出来。记第 kkk 个质数为 pkp_kpk​。令 f(x,y,b)f(x,y,b)f(x,y,b) 表示 [x,y][x,y][x,y] 中所有质因子不大于 pbp_bpb​ 的数个数。 分以下几种情况： 若 x&gt;yx&gt;yx&gt;y 则 f(x,y,b)=0f(x,y,b)=0f(x,y,b)=0 若 b=0b=0b=0 且 x=1≤yx=1\leq yx=1≤y 则 f(x,y,b)=1f(x,y,b)=1f(x,y,b)=1 若 x=yx=yx=y 则暴力分解 xxx 看是否满足。（可以部分预处理） 若 y≤pby\leq p_by≤pb​ 则 f(x,y,b)=y−x+1f(x,y,b)=y-x+1f(x,y,b)=y−x+1 否则 f(x,y,b)=f(x,y,b−1)+f(xpb,ypb,b)f(x,y,b)=f(x,y,b-1)+f(\frac{x}{p_b},\frac{y}{p_b},b)f(x,y,b)=f(x,y,b−1)+f(pb​x​,pb​y​,b) （上取整） 最后一种情况的意思是，当前 [x,y][x,y][x,y] 中质因子不包含 pbp_bpb​ 的数。后一个是至少包含一个 pbp_bpb​ 的数，可以把 pbp_bpb​ 除下去以后递归求解。 以上是官方题解。 以下是另一种写法，原理基本一致。 令 f(x,y,c)f(x,y,c)f(x,y,c) 表示在 (x,y](x,y](x,y] 这个区间中所有质因子均不小于 pcp_cpc​ 且不大于 ppp 的数个数。 枚举第 ccc 个及其后面的质数，递归计算 f(xpc,ypc,c)f(\frac{x}{p_c},\frac{y}{p_c},c)f(pc​x​,pc​y​,c) 并累加。由于需要特殊处理 111 的情况，当 x=0x=0x=0 时 ansansans 初值为 111 。其余处理细节详见代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int N=1e6+5;int p,a,b,cnt,limit,pri[N];bool np[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int f(int x,int y,int c)&#123; if(x==y)return 0; int ans=(x==0); while(c&lt;=cnt&amp;&amp;1ll*pri[c]*pri[c]&lt;=y)ans+=f(x/pri[c],y/pri[c],c),c++; ans+=upper_bound(pri+c,pri+cnt+1,y)-upper_bound(pri+c,pri+cnt+1,x); return ans;&#125;int main()&#123; p=read();a=read();b=read(); for(int i=2;i&lt;=p;i++) &#123; if(!np[i])pri[++cnt]=i; for(int j=1;i*pri[j]&lt;=p;j++) &#123; np[i*pri[j]]=true; if(i%pri[j]==0)break; &#125; &#125; printf("%d\n",b-a+1-f(a-1,b,1)); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>线性筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1863」Travel]]></title>
    <url>%2F51nod1863%2F</url>
    <content type="text"><![CDATA[Fancy 年青的时候喜欢旅行。据他回忆说，那曾是一段有始有终的旅行。 他来到了一个叫 Fancy 的理想国。那里有许许多多的 FancyCat 。最开始的时候，同一种 FancyCat 会形成一个部落，拥有特定的一块领地。Fancy 第一次来这里的时候还 Too Young ，现在他将故地重游。但由于多年的演变，部落分分合合，现在两个不一样的部落有可能也是由同一种 FancyCat 组成。 Fancy 开始了他的徒步路程。每次他经过某一个部落，他将收到由该部落种类的纪念品一份。Fancy 很喜欢收集纪念品。他是一个性情中人，越喜欢的纪念品他就越想得到，而且要越多越好。Fancy 列出了一张纪念品喜欢程度的排名表。在这个表中越靠前的纪念品表示 Fancy 越喜欢。 由于理想国过于庞大，虽然拥有地图，但 Fancy 也会因为找不到地图上对应的位置而经常迷路。 Fancy 觉得与其在地图中苦苦挣扎不如随机走。而且他坚信一定能走到终点！ Fancy 在旅行开始前，想到可以先计算一下期望得到的每个纪念品的数量，不过由于图中环的存在，给计算带来了很大困难。于是 Fancy 打算只计算一下自己完全随机乱走的情况下最坏能得到的那些纪念品。对于两条旅行线路的比较，他采取了如下的方法：找出在排名表中最靠前的一个纪念品，满足两条线路中获得的该纪念品数量不相等。这时候，该纪念品多的那一条线路更优。 你要做的工作就是计算出最坏情况下的得到纪念品序列。 Constraints n≤100000n\leq 100000n≤100000 ， m≤500000m\leq 500000m≤500000 Solution 据题意，显然最坏情况就是从 111 到 nnn 的最短路，这里的最短即为题意中的最劣，每个点的 disdisdis 可以按排名表统计为一个序列。 主要问题在两个序列的比较，这里我们使用主席树来维护序列的哈希值，比较两个序列的字典序时在主席树上二分即可。 详见代码，时间复杂度 O((n+m)lognlogn)O((n+m)lognlogn)O((n+m)lognlogn) 。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;queue&gt;#define LL long longusing namespace std;const int N=1e5+5;const LL base=20010311;int n,m,cnt,idx,x,y,t,cur;int first[N],id[N],rk[N],a[N];int rt[N],ls[N*50],rs[N*50];LL bit[N],v[N*50];struct edge&#123;int to,next;&#125;e[N*10];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void add(int &amp;x,int l,int r,int c)&#123; int t=x;x=++idx; ls[x]=ls[t];rs[x]=rs[t];v[x]=v[t]; if(l==r)&#123;v[x]++;return;&#125; int mid=(l+r)&gt;&gt;1; if(c&lt;=mid)add(ls[x],l,mid,c); else add(rs[x],mid+1,r,c); v[x]=v[ls[x]]*bit[r-mid]+v[rs[x]];&#125;bool cmp(int x,int y)&#123; if(v[x]==v[y])return false; int l=1,r=n; while(l&lt;r) &#123; int mid=(l+r)&gt;&gt;1; if(v[ls[x]]!=v[ls[y]])x=ls[x],y=ls[y],r=mid; else x=rs[x],y=rs[y],l=mid+1; &#125; return v[x]&lt;v[y];&#125;struct node&#123; int x,t; bool operator &lt; (const node&amp; a)const&#123;return !cmp(t,a.t);&#125; &#125;;priority_queue&lt;node&gt; q;void dfs(int x,int l,int r)&#123; if(!x)return; if(l==r)&#123;for(int i=1;i&lt;=v[x];i++)printf("%d ",id[l]);return;&#125; int mid=(l+r)&gt;&gt;1; dfs(ls[x],l,mid);dfs(rs[x],mid+1,r);&#125;int main()&#123; n=read();m=read();bit[0]=1; for(int i=1;i&lt;=n;i++)bit[i]=bit[i-1]*base; for(int i=1;i&lt;=n;i++) id[i]=read(),rk[id[i]]=i; for(int i=1;i&lt;=n;i++) a[i]=read(),a[i]=rk[a[i]]; for(int i=1;i&lt;=m;i++) x=read(),y=read(),ins(x,y),ins(y,x); q.push((node)&#123;1,rt[1]&#125;); while(!q.empty()) &#123; x=q.top().x;t=q.top().t;q.pop(); if(t!=rt[x])continue; cur=rt[x];add(cur,1,n,a[x]); for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!rt[to]||cmp(cur,rt[to])) &#123; rt[to]=cur; q.push((node)&#123;to,rt[to]&#125;); &#125; &#125; &#125; add(rt[n],1,n,a[n]); dfs(rt[n],1,n); return 0;&#125;]]></content>
      <tags>
        <tag>主席树</tag>
        <tag>哈希</tag>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1510」最小化序列]]></title>
    <url>%2F51nod1510%2F</url>
    <content type="text"><![CDATA[现在有一个长度为 nnn 的数组 AAA ，另外还有一个整数 kkk 。数组下标从 111 开始。 现在你需要把数组的顺序重新排列一下使得下面这个的式子的值尽可能小。 ∑i=1n−k∣A[i]−A[i+k]∣\sum_{i=1}^{n-k}{|A[i]-A[i+k]|} i=1∑n−k​∣A[i]−A[i+k]∣ 特别的，你也可以不对数组进行重新排列。 Constraints $ 2\leq n\leq 3\cdot 10^5$ ， 1≤k≤min(5000,n−1)1 \leq k \leq min(5000,n-1)1≤k≤min(5000,n−1) Solution 观察可得式子实际上将 nnn 个数字分成了不相关的 kkk 组，其中有 nmodkn \bmod knmodk 组大小为 nk+1\frac{n}{k}+1kn​+1 ，剩余的长度为 nk\frac{n}{k}kn​ 。 将 AAA 数组排序后，贪心地得出每一组都是连续的一段，代价为最后一个数 −-− 第一个数。 令 f(i,j)f(i,j)f(i,j) 表示当前已有 iii 组较大的分组与 jjj 组较小的分组的最小代价，直接 dp 即可。 时间复杂度 O(k2)O(k^2)O(k2) 。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=3e5+5;const int K=5e3+5;int lcnt,scnt,leng,seng;int n,k,t,a[N],f[K][K];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void update(int &amp;a,int b)&#123; if(a==-1)a=b; else a=min(a,b);&#125;int main()&#123; n=read();k=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1); lcnt=n%k;scnt=k-lcnt; leng=n/k+1;seng=n/k; memset(f,-1,sizeof(f)); f[0][0]=0; for(int i=0;i&lt;=lcnt;i++) for(int j=0;j&lt;=scnt;j++) &#123; if(f[i][j]==-1)continue; t=i*leng+j*seng; if(i!=lcnt)update(f[i+1][j],f[i][j]+a[t+leng]-a[t+1]); if(j!=scnt)update(f[i][j+1],f[i][j]+a[t+seng]-a[t+1]); &#125; printf("%d",f[lcnt][scnt]); return 0;&#125;]]></content>
      <tags>
        <tag>普通dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1519」拆方块]]></title>
    <url>%2F51nod1519%2F</url>
    <content type="text"><![CDATA[有 nnn 堆方块，第 iii 堆方块由 hih_ihi​ 个方块堆积而成。 接下来拆方块。一个方块称为内部方块当且仅当他的上下左右都是方块或者是地面。否则方块就是边界方块。每一次操作都要把边界方块拿掉。 问多少次操作之后所有方块会消失。 Constraints 1≤n≤1051 \leq n \leq 10^51≤n≤105 Solution 观察可得，每一轮进行的操作为 hi=min(hi−1,hi−1,hi+1)h_i=min(h_{i-1},h_i-1,h_{i+1})hi​=min(hi−1​,hi​−1,hi+1​) 。当一列方块被拆掉时，下一轮他的相邻两列中未被拆掉的列也会被拆掉。 从左往右和从右往左分别扫一遍，取 min 即是当前列被拆掉的操作次序。时间复杂度 O(n)O(n)O(n) 。 Code 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,ans,h[N],l[N],r[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)h[i]=read(); l[1]=1;for(int i=2;i&lt;=n;i++)l[i]=min(l[i-1]+1,h[i]); r[n]=1;for(int i=n-1;i&gt;=1;i--)r[i]=min(r[i+1]+1,h[i]); for(int i=1;i&lt;=n;i++)ans=max(ans,min(l[i],r[i])); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1055」最长等差数列]]></title>
    <url>%2F51nod1055%2F</url>
    <content type="text"><![CDATA[NNN 个不同的正整数，找出由这些数组成的最长的等差数列。 Constraints $ n \leq 10000$ Solution dp(i,j)dp(i,j)dp(i,j) 表示等差数列最后的两个数字的位置。 转移的时候考虑先固定 jjj 的位置，然后分别向两边扫寻找满足 ai+ak=2⋅aja_i+a_k=2\cdot a_jai​+ak​=2⋅aj​ 的数对 (i,k)(i,k)(i,k) ，并用 dp(i,j)+1dp(i,j)+1dp(i,j)+1 来更新 dp(j,k)dp(j,k)dp(j,k) 。 考虑到空间问题，需要使用 short int 。时间复杂度 O(n2)O(n^2)O(n2) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e4+5;int n,a[N];short int t,ans=2,dp[N][N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read(); sort(a+1,a+n+1); for(int i=1;i&lt;=n;i++) for(int j=i+1;j&lt;=n;j++) dp[i][j]=2; for(int j=2;j&lt;n;j++) &#123; int i=j-1,k=j+1; while(i&gt;=1&amp;&amp;k&lt;=n) &#123; if(a[i]+a[k]&lt;2*a[j])k++; else if(a[i]+a[k]&gt;2*a[j])i--; else &#123; t=dp[i][j]+1; dp[j][k]=max(dp[j][k],t); ans=max(ans,t); i--;k++; &#125; &#125; &#125; printf("%d\n",ans); return 0;&#125;]]></content>
      <tags>
        <tag>普通dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训 2018-04-03」Problem B]]></title>
    <url>%2Fyali0403b%2F</url>
    <content type="text"><![CDATA[求有多少 NNN 个的竞赛图包含至少一个长度为 KKK 的简单环, 输出答案模 109+710^9+7109+7 的结果。 竞赛图: 任意两个点之间都有一条有向边的图。 简单环: 不经过重复节点的回路。 Constraints n≤5000n \leq 5000n≤5000 Solution 首先有一个定理：竞赛图中如果包含一个大小大于等于 kkk 的强连通分量，则这个强连通分量内包含长度为 [3,k][3,k][3,k] 的简单环。则问题转化为：求至少有一个强连通分量大小大于等于 kkk 的方案数。 令 pip_{i}pi​ 表示 iii 个点的竞赛图方案数，则显然有 pi=2i⋅(i−1)2p_{i}=2^{\frac{i\cdot (i-1)}{2}}pi​=22i⋅(i−1)​ 。 令 gig_{i}gi​ 表示 iii 个点的强连通分量且为竞赛图的方案数，则显然有 gi=pi−∑j=1i−1(ij)⋅gj⋅pi−jg_{i}=p_{i}-\sum _{j=1}^{i-1}\binom{i}{j}\cdot g_{j}\cdot p_{i-j}gi​=pi​−∑j=1i−1​(ji​)⋅gj​⋅pi−j​ 。 令 fif_{i}fi​ 表示当前用了 iii 个点，不包含大小大于等于kkk的强连通分量的方案数。枚举最后一个强连通分量的大小进行转移，可得： fi=∑j=1min(k−1,i)(ij)⋅gj⋅fi−jf_{i}=\sum _{j=1}^{min(k-1,i)}\binom{i}{j}\cdot g_{j}\cdot f_{i-j} fi​=j=1∑min(k−1,i)​(ji​)⋅gj​⋅fi−j​ 则最终答案为 pn−fnp_{n}-f_{n}pn​−fn​ ，时间复杂度 O(n2)O(n^{2})O(n2) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e3+5;const int mod=1e9+7;int n,k,C[N][N],g[N],p[N],f[N];int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; freopen("b.in","r",stdin); freopen("b.out","w",stdout); scanf("%d%d",&amp;n,&amp;k); for(int i=0;i&lt;=n;i++)C[i][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; for(int i=1;i&lt;=n;i++)p[i]=power(2,i*(i-1)/2); g[1]=1; for(int i=3;i&lt;=n;i++) &#123; g[i]=p[i]; for(int j=1;j&lt;i;j++) g[i]=(g[i]-1ll*C[i][j]*g[j]%mod*p[i-j]%mod+mod)%mod; &#125; f[0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;k&amp;&amp;j&lt;=i;j++) f[i]=(f[i]+1ll*C[i][j]*g[j]%mod*f[i-j])%mod; printf("%d",(p[n]-f[n]+mod)%mod); return 0;&#125;]]></content>
      <tags>
        <tag>普通dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训 2018-04-03」Problem C]]></title>
    <url>%2Fyali0403c%2F</url>
    <content type="text"><![CDATA[给出一棵 NNN 个点的有根树，这棵树以 111 号节点为根。现在你需要对于每个非叶子节点 YYY 选择它的一个儿子 XXX ，并把连接 X,YX,YX,Y 的边标记为重边，其它的边为轻边。对于这棵树的每个叶子节点，把它到根节点经过的边依次写下来，一条轻边的代价为 111 ，一段连续的重边代价为 ⌊log2L+1⌋\left \lfloor log_2L+1 \right \rfloor⌊log2​L+1⌋ ，LLL 为这段重边的数量，这个叶子的代价等于这些代价之和。求出在最优情况下，所有叶子的代价中的最大值最小是多少。 Constraints n≤2⋅105n \leq 2\cdot 10^5n≤2⋅105 Solution 记一下 O(n2)O(n^{2})O(n2) 的暴力……正解把复杂度优化到了 O(nlogn)O(nlogn)O(nlogn) ，至今仍然不是很理解。 令 gig_{i}gi​ 表示节点 iii 的子树里到 iii 代价最大的叶子节点的代价，每一次贪心的选择 gig_{i}gi​ 最大的儿子节点作为重儿子。 因为贡献不方便计算，令 f(i,k)f(i,k)f(i,k) 表示在节点 iii 有一条向上长度为 kkk 的重链时的答案，则可得： f(i,k)=max(f(heavy,k+1),g(light)+⌈log2k+1⌉+1)f(i,k)=max(f(heavy,k+1),g(light)+\lceil log_{2}k+1\rceil +1) f(i,k)=max(f(heavy,k+1),g(light)+⌈log2​k+1⌉+1) 下面的是正解的代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int T,n,x,y,cnt;int first[N],g[N],f[N][20];struct edge&#123;int to,next;&#125;e[N&lt;&lt;1];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x,int fa)&#123; int mx=-inf,elmx=-inf,son=0; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs(to,x); if(g[to]&gt;mx)elmx=mx,mx=g[to],son=to; else if(g[to]&gt;elmx)elmx=g[to]; &#125; if(mx&lt;0) &#123; g[x]=0;f[x][0]=0; for(int i=1;i&lt;18;i++)f[x][i]=1&lt;&lt;(i-1); return; &#125; elmx++; if(f[son][0])g[x]=mx;else g[x]=mx+1; g[x]=max(g[x],elmx); for(int i=0;i&lt;18;i++) &#123; int v=g[x]+i; if(v==elmx)f[x][i]=0; else f[x][i]=1&lt;&lt;min(20,v-elmx-1); if(v-mx&lt;18)f[x][i]=min(f[x][i],f[son][v-mx]-1); &#125;&#125;void work()&#123; cnt=0;memset(first,0,sizeof(first)); n=read(); for(int i=1;i&lt;n;i++) x=read(),y=read(),ins(x,y),ins(y,x); dfs(1,0);printf("%d\n",g[1]);&#125;int main()&#123; T=read(); while(T--)work(); return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训 2018-04-02」Problem A]]></title>
    <url>%2Fyali0402a%2F</url>
    <content type="text"><![CDATA[有一个长为 NNN 的数列 AAA ，有 QQQ 个操作: 1 L R X1 \ \ L \ \ R \ \ X1 L R X 对于 L≤i≤RL\leq i\leq RL≤i≤R ，把 AiA_iAi​ 变成 Ai∧XA_i \wedge XAi​∧X 。 2 L R X2 \ \ L \ \ R \ \ X2 L R X 对于 L≤i≤RL\leq i\leq RL≤i≤R ，把 AiA_iAi​ 变成 Ai∨XA_i \vee XAi​∨X 。 3 L R3 \ \ L \ \ R3 L R 求 AL,AL+1,⋯,ARA_L,A_{L+1},\cdots ,A_RAL​,AL+1​,⋯,AR​ 中的最大值。 其中 $\wedge $ 为按位与 ，$ \vee $为按位或。 Constraints N,Q≤2⋅105N,Q \leq 2\cdot 10^5N,Q≤2⋅105 ， 0≤A&lt;2200 \leq A &lt; 2^{20}0≤A&lt;220 Solution 按位与和按位或操作会把对一些数位执行区间赋值操作，所以如果区间内的数这些数位上的数相同，则可以直接打上标记，否则需要递归访问额外节点。过程中需记录区间内数字的与、或和最大值，以方便判断数位是否相同。 下传标记时先与后或。 复杂度 O(20nlogn)O(20nlogn)O(20nlogn)（其实主要问题在复杂度分析）。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define l(x) x&lt;&lt;1#define r(x) x&lt;&lt;1|1#define LL long longusing namespace std;const int N=2e5+5;int n,m,op,L,R,v,S=(1&lt;&lt;20)-1;int vor[N*4],vand[N*4],vmx[N*4],tor[N*4],tand[N*4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void mand(int x,int v)&#123; tand[x]&amp;=v;tor[x]&amp;=v; vand[x]&amp;=v;vor[x]&amp;=v;vmx[x]&amp;=v;&#125;void mor(int x,int v)&#123; tor[x]|=v; vand[x]|=v;vor[x]|=v;vmx[x]|=v;&#125;void up(int x)&#123; vand[x]=vand[l(x)]&amp;vand[r(x)]; vor[x]=vor[l(x)]|vor[r(x)]; vmx[x]=max(vmx[l(x)],vmx[r(x)]);&#125;void dn(int x)&#123; if(tand[x]!=S) &#123; mand(l(x),tand[x]); mand(r(x),tand[x]); tand[x]=S; &#125; if(tor[x]!=0) &#123; mor(l(x),tor[x]); mor(r(x),tor[x]); tor[x]=0; &#125;&#125;void build(int x,int l,int r)&#123; tand[x]=S; if(l==r)&#123;vor[x]=vand[x]=vmx[x]=read();return;&#125; int mid=(l+r)&gt;&gt;1; build(l(x),l,mid); build(r(x),mid+1,r); up(x);&#125;void modify(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; if(op==1&amp;&amp;((v^S)&amp;(vand[x]|(vor[x]^S)))==(v^S))&#123;mand(x,v);return;&#125; if(op==2&amp;&amp;(v&amp;(vand[x]|(vor[x]^S)))==v)&#123;mor(x,v);return;&#125; &#125; dn(x);int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(l(x),l,mid); if(R&gt;mid)modify(r(x),mid+1,r); up(x);&#125;int query(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)return vmx[x]; dn(x);int mid=(l+r)&gt;&gt;1,ans=0; if(L&lt;=mid)ans=max(ans,query(l(x),l,mid)); if(R&gt;mid)ans=max(ans,query(r(x),mid+1,r)); return ans;&#125;int main()&#123; n=read();m=read(); build(1,1,n); while(m--) &#123; op=read();L=read();R=read(); if(op==3)printf("%d\n",query(1,1,n)); else v=read(),modify(1,1,n); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训 2018-04-02」Problem B]]></title>
    <url>%2Fyali0402b%2F</url>
    <content type="text"><![CDATA[有一个长宽均为 NNN 的网格，每个格子的长宽均为 111。除了最左下角的网格外，其他格子中均有一个半径为 RRR 的圆，圆心在格子的正中心。现在你站在最左下角的格子的正中心，求你能够看到多少个圆，视线不能够穿过圆。 输入一行包含两个整数 NNN ，R0R_0R0​ ，题目中的 RRR 为R0106\frac{R_0}{10^6}106R0​​ 。 Constraints $ n \leq 10^9$ ， R0≤106R_0 \leq 10^6R0​≤106 Solution 首先可以确定一个结论：只有能够看到圆心才能够看到这个圆。 枚举圆 (x,y)(x,y)(x,y) 和圆 (a,b)(a,b)(a,b) ，根据点到直线的距离公式 ∣Ax0+By0+CA2+B2∣\begin{vmatrix} \frac{Ax_{0}+By_{0}+C}{\sqrt{A^{2}+B^{2}}} \end{vmatrix}∣∣∣​A2+B2​Ax0​+By0​+C​​∣∣∣​ ，可得若 (a,b)(a,b)(a,b) 挡住了 (x,y)(x,y)(x,y) ，则 (ay−bx)2x2+y2≤R2\frac{(ay-bx)^{2}}{x^{2}+y^{2}}\leq R^{2}x2+y2(ay−bx)2​≤R2 。 只考虑 x,yx,yx,y 互质的情况，那么一定存在 a&lt;xa&lt;xa&lt;x ， b&lt;yb&lt;yb&lt;y ， ∣ay−bx∣=1|ay-bx|=1∣ay−bx∣=1 ，这时候只要满足 x2+y2&lt;1R2x^{2}+y^{2}&lt; \frac{1}{R^{2}}x2+y2&lt;R21​ 就不会被挡住。 所以令 r=1Rr=\frac{1}{R}r=R1​ ，枚举约数 ddd ，得出： ∑d=1min(n,r)μ(d)∑x=1⌊rd⌋∑y=1⌊rd⌋[x2+y2&lt;r2d2]\sum _{d=1}^{min(n,r)}\mu(d)\sum _{x=1}^{\lfloor \frac{r}{d} \rfloor}\sum _{y=1}^{\lfloor \frac{r}{d} \rfloor}[x^{2}+y^{2}&lt;\frac{r^{2}}{d^{2}}] d=1∑min(n,r)​μ(d)x=1∑⌊dr​⌋​y=1∑⌊dr​⌋​[x2+y2&lt;d2r2​] 具体计算方式见代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#define LL long longusing namespace std;const int N=1e6+5;int n,r,tot,pri[N],miu[N];LL ans;bool np[N];LL calc(LL lim,LL n)&#123; LL y=sqrt(lim)+1,sum=0; y=min(y,n); for(LL x=1;x*x&lt;lim&amp;&amp;x&lt;=n;x++) &#123; while(y&amp;&amp;x*x+y*y&gt;lim)y--; sum+=y; &#125; return sum;&#125;int main()&#123; miu[1]=1; for(int i=2;i&lt;=1e6;i++) &#123; if(!np[i])&#123;miu[i]=-1;pri[++tot]=i;&#125; for(int j=1;i*pri[j]&lt;=1e6;j++) &#123; int now=i*pri[j]; np[now]=true; if(i%pri[j]==0)&#123;miu[now]=0;break;&#125; miu[now]=-miu[i]; &#125; &#125; scanf("%d%d",&amp;n,&amp;r); LL lim=1ll*999999999999/r/r; for(LL g=1;g*g&lt;=lim;g++) ans+=miu[g]*calc(lim/g/g,(n-1)/g); printf("%lld",ans+2); return 0;&#125;]]></content>
      <tags>
        <tag>容斥原理</tag>
        <tag>计算几何</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训 2018-04-02」Problem C]]></title>
    <url>%2Fyali0402c%2F</url>
    <content type="text"><![CDATA[Alice 和 Bob 在玩游戏。 有一棵 NNN 个节点的树， Alice 和 Bob 轮流操作，Alice 先手。 一开始树上所有节点都没有颜色，Alice 每次会选一个没有被染色的节点并把这个节点染成红色(不能不选)，Bob 每次会选一个没有被染色的节点并把这个节点染成蓝色(不能不选)。当有人操作不了时，游戏就终止了。 Alice 的最终得分为红色连通块的个数，Bob 的最终的分为蓝色连通块的个数。设 Alice 的得分为 KAK_AKA​ ，Bob 的得分为 KBK_BKB​，Alice 想让 KA−KBK_A-K_BKA​−KB​ 尽可能大，Bob 则想让 KA−KBK_A-K_BKA​−KB​ 尽可能小，假设两人都采取最优策略操作，那么 KA−KBK_A-K_BKA​−KB​ 会是多少。 这里指的连通块为一个点集 SSS，满足集合内点的颜色相同，且每个点都能只经过 SSS 内的点走到 SSS 内的其他点，而且如果将任意 u(u⊈S)u(u\nsubseteq S)u(u⊈S) 加入 SSS ，那么上述性质将不能被满足。 Constraints $ n \leq 10^5 $ Solution 显然，KAK_{A}KA​ 等于红色点数减去两端都为红色的边的数量，KBK_{B}KB​ 同理。两种颜色点数是确定的，问题转化为求两边同色的边数之差。对于一条边，将两个端点的点权 +1+1+1 ，若被 Alice 选择则将答案减去点权，否则加上点权。贪心可得，Alice 和 Bob 都会选择点权最小的结点。贪心计算出来的数字即为 ans⋅2ans\cdot 2ans⋅2 。 Code 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,ans,u,v,deg[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int main()&#123; n=read();ans=(n&amp;1)*2; for(int i=1;i&lt;n;i++) &#123; u=read();v=read(); deg[u]++;deg[v]++; &#125; sort(deg+1,deg+n+1); for(int i=1;i&lt;=n;i++) &#123; if(i&amp;1)ans-=deg[i]; else ans+=deg[i]; &#125; printf("%d",ans/2); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训 2018-03-31」Max]]></title>
    <url>%2Fyali0331a%2F</url>
    <content type="text"><![CDATA[一个长为 nnn 的序列 AAA，从 111 开始标号，一开始全为 000，现在小 C 想对它进行 mmm 次操作。对第 iii 次操作，他会选定恰好一个二元组 (j,k)(j,k)(j,k)（1≤j≤n,0≤k≤c1\leq j\leq n,0\leq k\leq c1≤j≤n,0≤k≤c）并令 Aj=Aj+kA_j=A_j+kAj​=Aj​+k，其中选中二元组 (j,k)(j,k)(j,k) 的概率为 Pi,j,kP_{i,j,k}Pi,j,k​。小 C 本来是想问你区间最大值的历史版本和的历史最大值的期望的，但鉴于这是一道签到题，现在他只想知道 mmm 次操作后整个序列最大值的期望，对 109+710^9+7109+7 取模。 Constraints n≤40n \leq 40n≤40 ， m≤10m \leq 10m≤10 ， c≤3c \leq 3c≤3 Solution 令 f(i,S,j)f(i,S,j)f(i,S,j) 表示 AiA_{i}Ai​ 在经过集合 SSS 的操作后，值为 jjj 的概率。 令 dp(i,S,j)dp(i,S,j)dp(i,S,j) 表示前 iii 个元素，用掉了集合 SSS 的操作，最大值为 jjj 的概率，可得： dp(i,S1,j)×f(i+1,S2,k)=dp(i+1,S1+S2,max(j,k))dp(i,S_{1},j)\times f(i+1,S_{2},k)=dp(i+1,S_{1}+S_{2},max(j,k)) dp(i,S1​,j)×f(i+1,S2​,k)=dp(i+1,S1​+S2​,max(j,k)) 详见代码。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=41;const int M=11;const int T=1&lt;&lt;10;const int mod=1e9+7;int n,m,c,S,x,y,val,ans;int p[N][M][4],f[T][M*3],dp[N][T][M*3];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int &amp;x,LL val)&#123;x=(x+val)%mod;&#125;int main()&#123; n=read();m=read();c=read();S=(1&lt;&lt;m)-1; for(int j=0;j&lt;m;j++) for(int i=1;i&lt;=n;i++) for(int k=0;k&lt;=c;k++) p[i][j][k]=read(); dp[0][0][0]=1; for(int i=1;i&lt;=n;i++) &#123; memset(f,0,sizeof(f)); f[0][0]=1; for(int s=0;s&lt;=S;s++) &#123; x=__builtin_popcount(s); for(int j=0;j&lt;m;j++) &#123; if((1&lt;&lt;j)&amp;s)break; for(int k=0;k&lt;=c*x;k++) for(int d=0;d&lt;=c;d++) Mod(f[s|(1&lt;&lt;j)][k+d],1ll*f[s][k]*p[i][j][d]); &#125; &#125; for(int s=0;s&lt;=S;s++) &#123; x=__builtin_popcount(s); for(int k=0;k&lt;=c*x;k++) &#123; val=dp[i-1][s][k]; if(!val)continue; for(int j=s^S;;j=(j-1)&amp;(s^S)) &#123; y=__builtin_popcount(j); for(int d=0;d&lt;=c*y;d++) Mod(dp[i][s^j][max(k,d)],1ll*val*f[j][d]); if(!j)break; &#125; &#125; &#125; &#125; for(int i=0;i&lt;=c*m;i++) ans=(ans+1ll*i*dp[n][S][i])%mod; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训 2018-03-27」Subset]]></title>
    <url>%2Fyali0327b%2F</url>
    <content type="text"><![CDATA[给你三个 111 到 nnn 的排列 aia_iai​，bib_ibi​，cic_ici​。 称三元组 (x,y,z)(x,y,z)(x,y,z) 是合法的，当且仅当存在一个下标集合 SSS 满足 (x,y,z)=(max ai,max bi,max ci)(x,y,z)=(max \ \ a_i,max \ \ b_i,max \ \ c_i)(x,y,z)=(max ai​,max bi​,max ci​) (i⊆S)(i\subseteq S)(i⊆S) 询问合法三元组的数量。 Constraints $ n \leq 10^5 $ Solution 对于每一个合法三元组对应的 SSS ，只保留对三元组有贡献的下标，可以得到 ∣S∣≤3|S|\leq 3∣S∣≤3 ，且与合法三元组一一对应。问题转化为统计 SSS 的数量。 当 ∣S∣=1|S|=1∣S∣=1 时，所有下标集合都是合法的。 当 ∣S∣=2|S|=2∣S∣=2 时，可以用总的下标集合数 −-− 非法下标集合数（即其中一个在 a,b,ca,b,ca,b,c 里都比另一个大）来统计，这一步可以用 cdq 分治来完成。 当 ∣S∣=3|S|=3∣S∣=3 时，同样考虑非法下标集合数。分为几种情况进行讨论： 1.1.1. 存在一个下标在 a,b,ca,b,ca,b,c 中都是最大的，同样可以用 cdq 分治来完成，记为 AAA 。 2.2.2. 一个下标在 a,b,ca,b,ca,b,c 中的两个最大，另一个下标在 a,b,ca,b,ca,b,c 中的一个最大。考虑枚举 a,b,ca,b,ca,b,c 中的两个，计算有多少个下标集合满足其中一个在对应枚举的排列里是最大的，计总和为 BBB 。可以注意到， BBB 中还包含着不合法的 3⋅A3\cdot A3⋅A 种情况，所以实际上 B=B−3⋅AB=B-3\cdot AB=B−3⋅A 。 最后 (n−2)⋅(n−1)⋅n−A−B(n-2)\cdot (n-1)\cdot n-A-B(n−2)⋅(n−1)⋅n−A−B 即可得到 ∣S∣=3|S|=3∣S∣=3 时的下标集合数。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,temp,t[N],mn[N];LL A,B,C,ans; struct node&#123;int a,b,c;&#125;a[N],tmp[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.a&lt;b.a;&#125;bool cmp2(node a,node b)&#123;return a.b&lt;b.b;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int val)&#123;while(x&lt;=n)t[x]+=val,x+=lowbit(x);&#125;int query(int x)&#123;int ans=0;while(x)ans+=t[x],x-=lowbit(x);return ans;&#125;void cdq(int l,int r)&#123; if(l==r)return; int mid=(l+r)&gt;&gt;1; for(int i=l;i&lt;=r;i++) if(a[i].c&lt;=mid)add(a[i].b,1); else mn[a[i].a]+=query(a[i].b); int t1=l,t2=mid+1; for(int i=l;i&lt;=r;i++) if(a[i].c&lt;=mid)add(a[i].b,-1),tmp[t1++]=a[i]; else tmp[t2++]=a[i]; for(int i=l;i&lt;=r;i++)a[i]=tmp[i]; cdq(l,mid);cdq(mid+1,r);&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i].a=read(); for(int i=1;i&lt;=n;i++)a[i].b=read(); for(int i=1;i&lt;=n;i++)a[i].c=read(); sort(a+1,a+n+1,cmp);cdq(1,n); for(int i=1;i&lt;=n;i++) A+=1ll*mn[i]*(mn[i]-1)/2,C+=mn[i]; sort(a+1,a+n+1,cmp); memset(t,0,sizeof(t)); for(int i=1;i&lt;=n;i++) &#123; temp=query(a[i].b); B+=1ll*temp*(temp-1)/2; add(a[i].b,1); &#125; memset(t,0,sizeof(t)); for(int i=1;i&lt;=n;i++) &#123; temp=query(a[i].c); B+=1ll*temp*(temp-1)/2; add(a[i].c,1); &#125; sort(a+1,a+n+1,cmp2); memset(t,0,sizeof(t)); for(int i=1;i&lt;=n;i++) &#123; temp=query(a[i].c); B+=1ll*temp*(temp-1)/2; add(a[i].c,1); &#125; ans=1ll*(n-2)*(n-1)*n/6-(B-A*2); ans+=1ll*n*(n-1)/2-C; printf("%lld",ans+n); return 0;&#125;]]></content>
      <tags>
        <tag>分治</tag>
        <tag>cdq分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「雅礼集训 2018-03-25」cti]]></title>
    <url>%2Fyali0325c%2F</url>
    <content type="text"><![CDATA[有一个n×mn\times mn×m 的地图，地图上的每一个位置可以是空地，炮塔或是敌人。你需要操纵炮塔消灭敌人。 对于每个炮塔都有一个它可以瞄准的方向，你需要在它的瞄准方向上确定一个它的攻击位置，当然也可以不进行攻击。 一旦一个位置被攻击，则在这个位置上的所有敌人都会被消灭。保证对于任意一个炮塔，它所有可能的攻击位置上不存在另外一个炮塔。定义炮弹的运行轨迹为炮弹的起点和终点覆盖的区域。你需要求出一种方案，使得在没有两条炮弹轨迹相交的前提下，最大化消灭敌人的数量。 Constraints $ 1 \leq n,m \leq 50 $ Solution 考虑对于每一个炮塔，将它们可以攻击的位置连成一条链。对于不能相交的限制，可以参考【bzoj3144】[Hnoi2013]切糕。 具体建图方式为：先将横着的链建好，再反着建竖着的链，最后在每一个相交点间连一条无穷大的边。 原理画图易得。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=55;const int M=2e5+5;const int inf=0x3f3f3f3f;int n,m,cnt=1,S,T,tot,ans,all;int first[M],cur[M],map[N][N];int q[M],dis[M];int id[N][N],ord[N][N],chain[255][N];struct edge&#123;int to,next,flow;&#125;e[M*4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v,int w)&#123; e[++cnt]=(edge)&#123;v,first[u],w&#125;;first[u]=cnt; e[++cnt]=(edge)&#123;u,first[v],0&#125;;first[v]=cnt;&#125;bool bfs()&#123; memset(dis,-1,sizeof(dis)); int head=0,tail=1;q[0]=S;dis[S]=0; while(head!=tail) &#123; int u=q[head++]; for(int i=first[u];i;i=e[i].next) &#123; int to=e[i].to; if(dis[to]!=-1||!e[i].flow)continue; dis[to]=dis[u]+1; q[tail++]=to; &#125; &#125; return dis[T]!=-1;&#125;int dfs(int u,int a)&#123; if(u==T||a==0)return a; int f,flow=0; for(int&amp; i=cur[u];i;i=e[i].next) &#123; int to=e[i].to; if(dis[to]==dis[u]+1&amp;&amp;(f=dfs(to,min(e[i].flow,a)))&gt;0) &#123; e[i].flow-=f;e[i^1].flow+=f; flow+=f;a-=f;if(a==0)break; &#125; &#125; return flow;&#125;int main()&#123; n=read();m=read(); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) map[i][j]=read(); S=++tot;T=++tot; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(map[i][j]==-1) &#123; ins(++tot,T,1000);ans+=1000; int ccnt=0,tid=++all; chain[tid][++ccnt]=tot; for(int k=i-1;k&gt;=1;k--) &#123; chain[tid][++ccnt]=++tot; ins(tot,chain[tid][ccnt-1],1000-map[k][j]); id[k][j]=tid;ord[k][j]=ccnt-1; &#125; ins(S,tot,inf); &#125; else if(map[i][j]==-2) &#123; ins(++tot,T,1000);ans+=1000; int ccnt=0,tid=++all; chain[tid][++ccnt]=tot; for(int k=i+1;k&lt;=n;k++) &#123; chain[tid][++ccnt]=++tot; ins(tot,chain[tid][ccnt-1],1000-map[k][j]); id[k][j]=tid;ord[k][j]=ccnt-1; &#125; ins(S,tot,inf); &#125; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=m;j++) if(map[i][j]==-3) &#123; ins(S,++tot,1000);ans+=1000; int last=tot; for(int k=j-1;k&gt;=1;k--) &#123; ins(last,++tot,1000-map[i][k]); if(id[i][k])ins(last,chain[id[i][k]][ord[i][k]],inf); last=tot; &#125; ins(tot,T,inf); &#125; else if(map[i][j]==-4) &#123; ins(S,++tot,1000);ans+=1000; int last=tot; for(int k=j+1;k&lt;=m;k++) &#123; ins(last,++tot,1000-map[i][k]); if(id[i][k])ins(last,chain[id[i][k]][ord[i][k]],inf); last=tot; &#125; ins(tot,T,inf); &#125; while(bfs()) &#123; for(int i=1;i&lt;=tot;i++)cur[i]=first[i]; ans-=dfs(S,inf); &#125; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1273」旅行计划]]></title>
    <url>%2F51nod1273%2F</url>
    <content type="text"><![CDATA[某个国家有 NNN 个城市，编号 000 至 N−1N-1N−1 ，他们之间用 N−1N-1N−1 条道路连接，道路是双向行驶的，沿着道路你可以到达任何一个城市。你有一个旅行计划，这个计划是从编号 KKK 的城市出发，每天到达一个你没有去过的城市，并且旅途中经过的没有去过的城市尽可能的多（如果有 222 条路线，经过的没有去过的城市同样多，优先考虑编号最小的城市），直到所有城市都观光过一遍。现在给出城市之间的交通图 TTT ，以及出发地点 KKK ，你来设计一个旅行计划，满足上面的条件。 Constraints 1≤N≤500001 \leq N \leq 500001≤N≤50000 Solution 观察易得结论：每天的目的地必然是叶子节点，每天访问的路径一定是从叶子到根节点路径上的一段。 即据题意可以进行树上贪心，依据叶子节点的深度和编号大小进行排序后，按顺序从每个叶子往根走直到走到根节点或已访问过的节点，并进行统计。得到所有结果后再排序输出即可。 所以问题可以转化为：令每个叶子分别支配一条链，使得标号小的点尽量支配多的点，最后根据支配的点数多少、标号大小依次访问。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e4+5;int n,root,cnt,x,tot,ans;int first[N];bool vis[N];struct edge&#123;int to,next;&#125;e[N*2];struct node&#123;int id,deep;&#125;a[N],b[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(node a,node b)&#123;return a.deep==b.deep?a.id&lt;b.id:a.deep&gt;b.deep;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x,int fa,int deep)&#123; bool f=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; f=false;dfs(to,x,deep+1); &#125; if(f&amp;&amp;x!=root)a[++tot]=(node)&#123;x,deep&#125;;&#125;bool solve(int x,int fa)&#123; if(vis[x]||x==root)return true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; if(solve(to,x)) &#123; ans++;vis[x]=true; return true; &#125; &#125;&#125;int main()&#123; n=read();root=read(); for(int i=1;i&lt;n;i++)x=read(),ins(i,x),ins(x,i); dfs(root,-1,0);sort(a+1,a+tot+1,cmp); for(int i=1;i&lt;=tot;i++) &#123; ans=0;solve(a[i].id,-1); b[i]=(node)&#123;a[i].id,ans&#125;; &#125; sort(b+1,b+tot+1,cmp); printf("%d\n",root); for(int i=1;i&lt;=tot;i++)printf("%d\n",b[i].id); return 0;&#125;]]></content>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1907」小C的游戏]]></title>
    <url>%2F51nod1907%2F</url>
    <content type="text"><![CDATA[小 C 在无向图上玩这样一个游戏。 小 C 可以任选一点作为起点。每次他可以进行两种操作： 移动到一个相邻的结点。 使用一次魔法，移动到图中任意一个结点。 当他访问图中每个结点至少 111 次时，游戏结束。注意他必须使用不超过 n−1n-1n−1 次魔法。 游戏结束时，如果他使用了 kkk 次魔法，则他本轮游戏的花费为 aka_kak​ 。 现有一个 nnn 个点 mmm 条边的无向连通图 GGG 。图 GGG 中任意一条边至多属于一个环。 小 C 希望知道，在图 GGG 的所有生成子图进行上述游戏所需花费的最小值之和。 由于答案可能很大，将答案对 998244353998244353998244353 取模。 Constraints 1≤n≤300001 \leq n \leq 300001≤n≤30000 ， n−1≤m≤2n−2n-1 \leq m \leq 2n-2n−1≤m≤2n−2 ， 0≤ai≤1090 \leq a_i \leq 10^90≤ai​≤109 可能有重边，但不会有自环。 图 G′(V′,E′)G&#x27;(V&#x27;,E&#x27;)G′(V′,E′) 是图 G(V,E)G(V,E)G(V,E) 的生成子图当且仅当 V′=V,E′⊆EV&#x27; = V , E&#x27; \subseteq EV′=V,E′⊆E 。 简单环定义为一个顶点序列 v1,v2,⋯,vm(m≥2)v_1, v_2, \cdots , v_m (m \ge 2)v1​,v2​,⋯,vm​(m≥2) ，其中 viv_ivi​ 与 vi+1v_{i+1}vi+1​ 相邻， v1v_1v1​ 与 vmv_mvm​ 相邻，且 viv_ivi​ 互不相同。 Solution 首先可以确定，在一个连通块内部移动不需要魔法，即只有跨越连通块使用的魔法是必要的，即最少魔法使用次数为连通块个数 −1-1−1 。问题转换为，求出连通块个数为 iii 的生成子图的方案数。 据题意，给出的图是仙人掌图，可以被分解为若干树边和环。我们将环和树边分开考虑，并构造出对应的生成函数，xix^ixi 表示当前部分贡献 iii 个连通块的方案数，最后将得到的所有多项式相乘即可。 1.1.1. 对于一条树边，删去即贡献 111 个连通块，保留则无贡献，即 f(x)=x+1f(x)=x+1f(x)=x+1 。 2.2.2. 对于一个包含n条边的环，在删去第一条边时无贡献，从第二条边开始每删去一条边对连通块数量贡献 +1+1+1 ，即 f(x)=∑i=0n−1(ni+1)xi+1f(x)=\sum_{i=0}^{n-1}\binom{n}{i+1}x^i+1f(x)=∑i=0n−1​(i+1n​)xi+1 。 在多项式相乘时使用启发式合并，保证时间复杂度为 O(nlog2n)O(nlog^2n)O(nlog2n) 。 在最后统计答案时，由于 aaa 序列不一定单调递增，一个连通块个数为 iii 的生成子图的实际最小代价为后缀最小值。且因为初始连通块个数为 111 ，最终 xix^ixi 的系数实际代表的是包含 i+1i+1i+1 个连通块的生成子图的方案数。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;queue&gt;#define LL long longusing namespace std;const int N=131072+5;const int mod=998244353;int n,m,x,y,cnt,tot,sum,*cur;int nn,al,bl,*acur,*bcur;int first[N],val[N],fac[N],fav[N],bel[N];int hx[N],hy[N],fa[N],deep[N];int length[N],o[10000005];int a[N],b[N];struct edge&#123;int to,next;&#125;e[N*2];struct node&#123; int n,*cur; bool operator &lt; (const node&amp; a)const&#123;return n&gt;a.n;&#125;&#125;aa,bb;priority_queue&lt;node&gt; q;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int min(int a,int b)&#123;return a&lt;b?a:b;&#125;int C(int n,int m)&#123;return 1ll*fac[n]*fav[m]%mod*fav[n-m]%mod;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int find(int t)&#123;return t==bel[t]?t:bel[t]=find(bel[t]);&#125;void dfs(int x,int last)&#123; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==last)continue; deep[to]=deep[x]+1; fa[to]=x;dfs(to,x); &#125;&#125;int dis(int x,int y)&#123; int ans=1; while(x!=y) &#123; if(deep[x]&lt;deep[y])swap(x,y); x=fa[x];ans++; &#125; return ans;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;void ntt(int *a,int n,int f)&#123; int k=0;while((1&lt;&lt;k)&lt;n)k++; for(int i=0;i&lt;n;i++) &#123; int t=0; for(int j=0;j&lt;k;j++) if(i&amp;(1&lt;&lt;j))t|=(1&lt;&lt;(k-j-1)); if(i&lt;t)swap(a[i],a[t]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1,nw=power(3,(mod-1)/l); if(f==-1)nw=power(nw,mod-2); for(int *p=a;p!=a+n;p+=l) &#123; int w=1; for(int i=0;i&lt;m;i++) &#123; int t=1ll*p[m+i]*w%mod; p[m+i]=(p[i]-t+mod)%mod; p[i]=(p[i]+t)%mod; w=1ll*w*nw%mod; &#125; &#125; &#125; if(f==-1) &#123; int inv=power(n,mod-2); for(int i=0;i&lt;n;i++)a[i]=1ll*a[i]*inv%mod; &#125;&#125;int main()&#123; n=read();m=read(); fac[0]=1; for(int i=1;i&lt;=n;i++)fac[i]=1ll*fac[i-1]*i%mod; fav[n]=power(fac[n],mod-2); for(int i=n;i&gt;=1;i--)fav[i-1]=1ll*fav[i]*i%mod; for(int i=1;i&lt;=n;i++)bel[i]=i; for(int i=1;i&lt;=n;i++)val[i]=read(); for(int i=n-1;i&gt;=1;i--)val[i]=min(val[i],val[i+1]); for(int i=1;i&lt;=m;i++) &#123; x=read();y=read(); if(find(x)!=find(y))bel[find(x)]=find(y),ins(x,y),ins(y,x); else tot++,hx[tot]=x,hy[tot]=y; &#125; dfs(1,-1);sum=n-1;cnt=0; for(int i=1;i&lt;=tot;i++) length[i]=dis(hx[i],hy[i]),sum-=(length[i]-1); if(sum&gt;=0) &#123; cur=&amp;o[cnt];cnt=sum+1; for(int i=0;i&lt;=sum;i++)cur[i]=C(sum,i); q.push((node)&#123;sum,cur&#125;); &#125; for(int i=1;i&lt;=tot;i++) &#123; cur=&amp;o[cnt];cnt+=length[i]; cur[0]=length[i]+1; for(int j=1;j&lt;=length[i]-1;j++)cur[j]=C(length[i],j+1); q.push((node)&#123;length[i]-1,cur&#125;); &#125; while(q.size()&gt;1) &#123; aa=q.top();q.pop(); al=aa.n;acur=aa.cur; bb=q.top();q.pop(); bl=bb.n;bcur=bb.cur; for(nn=1;nn&lt;=al+bl;nn&lt;&lt;=1); for(int i=0;i&lt;nn;i++)a[i]=b[i]=0; for(int i=0;i&lt;=al;i++)a[i]=acur[i]; for(int i=0;i&lt;=bl;i++)b[i]=bcur[i]; ntt(a,nn,1);ntt(b,nn,1); for(int i=0;i&lt;nn;i++)a[i]=1ll*a[i]*b[i]%mod; ntt(a,nn,-1); cur=&amp;o[cnt];cnt+=al+bl+1; for(int i=0;i&lt;=al+bl;i++)cur[i]=a[i]; q.push((node)&#123;al+bl,cur&#125;); &#125; int ans=0;aa=q.top();cur=aa.cur; for(int i=1;i&lt;=n;i++)ans=(ans+1ll*val[i]*cur[i-1])%mod; printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>并查集</tag>
        <tag>NTT</tag>
        <tag>启发式合并</tag>
        <tag>生成函数</tag>
        <tag>仙人掌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 1920」空间统计学]]></title>
    <url>%2F51nod1920%2F</url>
    <content type="text"><![CDATA[有个 mmm 维的空间，并且每一维的坐标 xxx 都满足 x∈[0,3]x\in [0,3]x∈[0,3] 并且 xxx 为整数。 这个空间有 nnn 个部落，每个部落都坐落在这片空间中的一个点上，可以用坐标 (x1,x2,⋯,xm)(x_1,x_2,\cdots ,x_m)(x1​,x2​,⋯,xm​) 来表示。 有些部落可能在在同一个点上面。 定义两个点的距离为它们的曼哈顿距离，即每一维坐标差的绝对值的和。 比如对于点 (x1,x2,⋯,xm)(x_1,x_2,\cdots ,x_m)(x1​,x2​,⋯,xm​) 和 (y1,y2,⋯,ym)(y_1,y_2,\cdots ,y_m)(y1​,y2​,⋯,ym​) ，它们之间的距离为 ∑i=1m∣xi−yi∣\sum _{i=1}^{m}|x_i-y_i|∑i=1m​∣xi​−yi​∣ 。 现在对 [0,3m][0,3m][0,3m] 之间的每一个数字 xxx ，统计有多少对部落之间的距离为 xxx。 注意，一对部落是有序的，即部落 (a,b)(a,b)(a,b) 和部落 (b,a)(b,a)(b,a) 为不同的两对。 Constraints n≤200000n\leq 200000n≤200000 ， m≤9m\leq 9m≤9 Solution 观察数据范围可得 mmm 和坐标范围都很小，考虑状压 dp 。 令 f(i,j,k)f(i,j,k)f(i,j,k) 表示当前已经考虑到第 iii 维，到达 jjj 这个状态（将坐标压成四进制），当前距离为 kkk 的方案数。 转移时枚举上一维的状态和距离以及当前维的坐标，直接转移即可。 利用滚动数组节省空间，时间复杂度 O(12⋅m2⋅4m)O(12\cdot m^2 \cdot 4^m)O(12⋅m2⋅4m) 。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int M=262144+5;int n,m,x; int bit[10],a[N],f[2][M][28];LL ans;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int ab(int x)&#123;return x&gt;=0?x:-x;&#125;int main()&#123; n=read();m=read(); bit[0]=1; for(int i=1;i&lt;=m;i++)bit[i]=bit[i-1]*4; for(int i=1;i&lt;=n;i++) &#123; for(int j=0;j&lt;m;j++) x=read(),a[i]+=bit[j]*x; f[0][a[i]][0]++; &#125; int last=0,cur=1; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;bit[m];j++) for(int k=0;k&lt;=3*i;k++) f[cur][j][k]=0; for(int j=0;j&lt;bit[m];j++) &#123; x=j/bit[i]%4; for(int l=0;l&lt;=3*m;l++) &#123; if(!f[last][j][l])continue; for(int k=0;k&lt;=3;k++) f[cur][j+(k-x)*bit[i]][l+ab(k-x)]+=f[last][j][l]; &#125; &#125; last=cur;cur=1-cur; &#125; for(int i=0;i&lt;=3*m;i++) &#123; ans=0; for(int j=1;j&lt;=n;j++)ans+=f[m&amp;1][a[j]][i]; printf("%lld ",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>状压dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「51nod 2026」Gcd and Lcm]]></title>
    <url>%2F51nod2026%2F</url>
    <content type="text"><![CDATA[已知 f(x)=∑d∣xμ(d)⋅df(x)=\sum_{d|x} \mu(d) \cdot df(x)=∑d∣x​μ(d)⋅d ，现在请求出下面式子的值： ∑i=1n∑j=1nf(gcd⁡(i,j))⋅f(lcm(i,j))\sum\limits_{i=1}^n \sum\limits_{j=1}^n f(\gcd(i,j)) \cdot f(\text{lcm}(i,j)) i=1∑n​j=1∑n​f(gcd(i,j))⋅f(lcm(i,j)) 由于值可能过大所以请对 109+710^9+7109+7 取模 Constraints $ n \leq 10^9 $ Solution 对 iii 和 jjj 进行质因数分解，即 i=∏pqii=\prod p^{qi}i=∏pqi ，j=∏pqjj=\prod p^{qj}j=∏pqj ，可以得到： f(gcd⁡(i,j))⋅f(lcm(i,j))=∏f(pmin(qi,qj))⋅f(pmax(qi,qj))=f(i)⋅f(j)\begin{aligned} &amp;~~~~f(\gcd(i,j)) \cdot f(\text{lcm}(i,j)) \\ &amp;= \prod f(p^{min(qi,qj)})\cdot f(p^{max(qi,qj)}) \\ &amp;= f(i)\cdot f(j) \end{aligned} ​ f(gcd(i,j))⋅f(lcm(i,j))=∏f(pmin(qi,qj))⋅f(pmax(qi,qj))=f(i)⋅f(j)​ 将原答案转换为： ans=∑i=1n∑j=1nf(gcd⁡(i,j))⋅f(lcm(i,j))=∑i=1n∑j=1nf(i)⋅f(j)=(∑i=1nf(i))2=(∑i=1n∑d∣iμ(d)⋅d)2=(∑i=1nμ(i)⋅i⋅⌊ni⌋)2\begin{aligned} ans&amp;=\sum_{i=1}^n \sum_{j=1}^n f(\gcd(i,j)) \cdot f(\text{lcm}(i,j)) \\ &amp;=\sum_{i=1}^n \sum_{j=1}^n f(i)\cdot f(j) \\ &amp;=(\sum_{i=1}^n f(i))^2 \\ &amp;=(\sum_{i=1}^n \sum_{d|i} \mu(d) \cdot d)^2 \\ &amp;=(\sum_{i=1}^n \mu(i) \cdot i \cdot \left \lfloor \frac{n}{i} \right \rfloor)^2 \end{aligned} ans​=i=1∑n​j=1∑n​f(gcd(i,j))⋅f(lcm(i,j))=i=1∑n​j=1∑n​f(i)⋅f(j)=(i=1∑n​f(i))2=(i=1∑n​d∣i∑​μ(d)⋅d)2=(i=1∑n​μ(i)⋅i⋅⌊in​⌋)2​ 然后令 S(n)=∑i=1nμ(i)⋅iS(n)=\sum_{i=1}^n \mu(i) \cdot iS(n)=∑i=1n​μ(i)⋅i ，则由以下推导： 1=∑i=1ni⋅∑j∣iμ(j)=∑i=1ni⋅∑j=1⌊ni⌋j⋅μ(j)=∑i=1ni⋅S(⌊ni⌋)\begin{aligned} 1&amp;=\sum_{i=1}^n i \cdot \sum _{j|i} \mu(j) \\ &amp;=\sum_{i=1}^n i\cdot \sum_{j=1}^{\left \lfloor \frac{n}{i} \right \rfloor} j \cdot \mu(j) \\ &amp;=\sum_{i=1}^n i\cdot S({\left \lfloor \frac{n}{i} \right \rfloor}) \end{aligned} 1​=i=1∑n​i⋅j∣i∑​μ(j)=i=1∑n​i⋅j=1∑⌊in​⌋​j⋅μ(j)=i=1∑n​i⋅S(⌊in​⌋)​ 可得：S(n)=1−∑i=2ni⋅S(⌊ni⌋)S(n)=1-\sum_{i=2}^n i\cdot S({\left \lfloor \frac{n}{i} \right \rfloor})S(n)=1−∑i=2n​i⋅S(⌊in​⌋) 杜教筛即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6;const int mod=1e9+7;int n,nn,tot,now;int miu[N+5],pri[N+5],a[N+5];bool np[N+5];int calc(int l,int r)&#123;return 1ll*(l+r)*(r-l+1)/2%mod;&#125;int solve(int n)&#123; if(n&lt;=N)return miu[n]; if(~a[nn/n])return a[nn/n]; int ans=1,pos; for(int i=2;i&lt;=n;i=pos+1) &#123; pos=n/(n/i); ans=(ans-1ll*calc(i,pos)*solve(n/i)%mod+mod)%mod; &#125; return a[nn/n]=ans;&#125;int main()&#123; scanf("%d",&amp;n); nn=n;miu[1]=1; for(int i=2;i&lt;=N;i++) &#123; if(!np[i])&#123;miu[i]=-1;pri[++tot]=i;&#125; for(int j=1;1ll*i*pri[j]&lt;=N;j++) &#123; now=i*pri[j];np[now]=true; if(i%pri[j]==0)&#123;miu[now]=0;break;&#125; miu[now]=-miu[i]; &#125; &#125; for(int i=1;i&lt;=N;i++) miu[i]=(miu[i-1]+(1ll*miu[i]*i%mod+mod)%mod)%mod; int ans=0,pos; memset(a,-1,sizeof(a)); for(int i=1;i&lt;=n;i=pos+1) &#123; pos=n/(n/i); ans=(ans+1ll*(solve(pos)-solve(i-1)+mod)%mod*(n/i)%mod)%mod; &#125; printf("%lld",1ll*ans*ans%mod); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4259」残缺的字符串]]></title>
    <url>%2Fbzoj4259%2F</url>
    <content type="text"><![CDATA[很久很久以前，在你刚刚学习字符串匹配的时候，有两个仅包含小写字母的字符串 AAA 和 BBB ，其中 AAA 串长度为 mmm ，BBB 串长度为 nnn 。可当你现在再次碰到这两个串时，这两个串已经老化了，每个串都有不同程度的残缺。 你想对这两个串重新进行匹配，其中 AAA 为模板串，那么现在问题来了，请回答，对于 BBB 的每一个位置 iii ，从这个位置开始连续 mmm 个字符形成的子串是否可能与 AAA 串完全匹配? Constraints 1≤m,n≤3000001\leq m,n \leq 3000001≤m,n≤300000 Solution 首先将 * 号的值置为 000 ，那么对于两个长度皆为 mmm 的串，若 ∑i=0m−1(A[i]−B[i])2A[i]B[i]=0\sum _{i=0}^{m-1}(A[i]-B[i])^2 A[i]B[i]=0∑i=0m−1​(A[i]−B[i])2A[i]B[i]=0 ，则两个串可以完全匹配。 此时若将 AAA 串翻转，并枚举在 BBB 串中的结尾位置，则可得： f[i]=∑j=0i(A[j]−B[i−j])2A[j]B[i−j]=∑j=0iA[j]3B[i−j]−2∑j=0iA[j]2B[i−j]2+∑j=0iA[j]B[i−j]3\begin{aligned} f[i] &amp;= \sum _{j=0}^{i}(A[j]-B[i-j])^2 A[j]B[i-j] \\ &amp;= \sum _{j=0}^{i}A[j]^3B[i-j]-2\sum _{j=0}^{i}A[j]^2B[i-j]^2+\sum _{j=0}^{i}A[j]B[i-j]^3 \end{aligned} f[i]​=j=0∑i​(A[j]−B[i−j])2A[j]B[i−j]=j=0∑i​A[j]3B[i−j]−2j=0∑i​A[j]2B[i−j]2+j=0∑i​A[j]B[i−j]3​ 直接 FFT 即可，注意卡常。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;const int N=524288+5;const double pi=acos(-1);int n,n1,n2,cnt,out[N],a[N],b[N];char s1[N],s2[N];struct cpx&#123;double r,i;cpx(double _r=0,double _i=0):r(_r),i(_i)&#123;&#125;;&#125;;cpx A[N],B[N],ans[N];cpx operator + (cpx a,cpx b)&#123;return cpx(a.r+b.r,a.i+b.i);&#125;cpx operator - (cpx a,cpx b)&#123;return cpx(a.r-b.r,a.i-b.i);&#125;cpx operator * (cpx a,cpx b)&#123;return cpx(a.r*b.r-a.i*b.i,a.r*b.i+a.i*b.r);&#125;void fft(cpx *a,int n,int f)&#123; int k=0;while((1&lt;&lt;k)&lt;n)k++; for(int i=0;i&lt;n;i++) &#123; int t=0; for(int j=0;j&lt;k;j++) if(i&amp;(1&lt;&lt;j))t|=(1&lt;&lt;(k-j-1)); if(i&lt;t)swap(a[i],a[t]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1; cpx nw=cpx(cos(2*pi/l),sin(2*pi/l)*f); for(cpx *p=a;p!=a+n;p+=l) &#123; cpx w=cpx(1,0); for(int i=0;i&lt;m;i++) &#123; cpx t=p[m+i]*w;w=w*nw; p[m+i]=p[i]-t;p[i]=p[i]+t; &#125; &#125; &#125; if(f==-1)for(int i=0;i&lt;n;i++)a[i].r/=n;&#125;int main()&#123; scanf("%d%d%s%s",&amp;n1,&amp;n2,s1,s2); n=1;while(n&lt;n1||n&lt;n2)n&lt;&lt;=1; for(int i=0;i&lt;n1;i++)if(s1[i]!='*')a[n1-i-1]=s1[i]-'a'+1; for(int i=0;i&lt;n2;i++)if(s2[i]!='*')b[i]=s2[i]-'a'+1; for(int i=0;i&lt;n;i++)A[i]=cpx(a[i]*a[i]*a[i],0); for(int i=0;i&lt;n;i++)B[i]=cpx(b[i],0); fft(A,n,1);fft(B,n,1); for(int i=0;i&lt;n;i++)ans[i]=A[i]*B[i]; for(int i=0;i&lt;n;i++)A[i]=cpx(a[i]*a[i],0); for(int i=0;i&lt;n;i++)B[i]=cpx(b[i]*b[i],0); fft(A,n,1);fft(B,n,1); for(int i=0;i&lt;n;i++)ans[i]=ans[i]-A[i]*B[i]*cpx(2,0); for(int i=0;i&lt;n;i++)A[i]=cpx(a[i],0); for(int i=0;i&lt;n;i++)B[i]=cpx(b[i]*b[i]*b[i],0); fft(A,n,1);fft(B,n,1); for(int i=0;i&lt;n;i++)ans[i]=ans[i]+A[i]*B[i]; fft(ans,n,-1); for(int i=n1-1;i&lt;n2;i++) if(ans[i].r&lt;0.5)out[++cnt]=i-n1+2; printf("%d\n",cnt); for(int i=1;i&lt;=cnt;i++)printf("%d ",out[i]); return 0;&#125;]]></content>
      <tags>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「LOJ 6041」「雅礼集训 2017 Day7」事情的相似度]]></title>
    <url>%2Floj6041%2F</url>
    <content type="text"><![CDATA[人的一生不仅要靠自我奋斗，还要考虑到历史的行程。 历史的行程可以抽象成一个 010101 串，作为一个年纪比较大的人，你希望从历史的行程中获得一些姿势。 你发现在历史的不同时刻，不断的有相同的事情发生。比如，有两个人同时在世纪之交 111111 年的时候上台，同样喜欢与洋人谈笑风生，同样提出了以「三」字开头的理论。 你发现，一件事情可以看成是这个 010101 串的一个前缀，这个前缀最右边的位置就是这个事情的结束时间。 两件事情的相似度可以看成，这两个前缀的最长公共后缀长度。 现在你很好奇，在一段区间内结束的事情中最相似的两件事情的相似度是多少呢？ Constraints 1≤n,m≤1051 \leq n,m \leq 10^51≤n,m≤105 Solution 建出原串的 SAM ，则两个前缀的最长公共后缀为他们在 parent 树上的 lca ，问题转化为求区间内前缀两两 lca 深度的最大值。 将询问离线，按右端点从小到大排序。我们考虑每次加入一个字母，就将他们在 parent 树上到根节点的路径打上他们的标记。往根节点跑的过程中，若遇到了以前打的标记，则该节点为旧标记与新标记的 lca 。贪心可得应把标记尽量覆盖为较大的值。用树状数组来统计答案，下标为左端点，每次查询下标大于等于该询问左端点的最大深度。向根跑的过程中每一次遇到旧标记，就在树状数组上更新答案，并给该节点打上新标记。 往根节点跑的过程实际上就是 LCT 的 access 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=1e5+5;int n,m,r,last,size,root;int p[N],mx[N],ans[N],num[N];int c[N*2][2],fa[N*2],v[N*2],tag[N*2];char s[N];vector&lt;int&gt; q[N];struct sam&#123;int mx,fa,ch[2];&#125;t[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void modify(int x,int v)&#123;x=n-x+1;while(x&lt;=n)mx[x]=max(mx[x],v),x+=lowbit(x);&#125;int query(int x)&#123;x=n-x+1;int ans=0;while(x)ans=max(ans,mx[x]),x-=lowbit(x);return ans;&#125;void ins(int c,int id)&#123; int np=++size;num[id]=np; t[np].mx=t[last].mx+1; int x=last;last=np; while(x&amp;&amp;!t[x].ch[c])t[x].ch[c]=np,x=t[x].fa; if(!x)t[np].fa=root; else &#123; int y=t[x].ch[c]; if(t[y].mx==t[x].mx+1)t[np].fa=y; else &#123; int nq=++size; t[nq]=t[y];t[nq].mx=t[x].mx+1; t[y].fa=t[np].fa=nq; while(x&amp;&amp;t[x].ch[c]==y)t[x].ch[c]=nq,x=t[x].fa; &#125; &#125;&#125;bool isroot(int x)&#123;return c[fa[x]][0]!=x&amp;&amp;c[fa[x]][1]!=x;&#125;void change(int x,int val)&#123;v[x]=tag[x]=val;&#125;void down(int x)&#123; if(!tag[x])return; if(c[x][0])change(c[x][0],tag[x]); if(c[x][1])change(c[x][1],tag[x]); tag[x]=0;&#125;void rotate(int x)&#123; int y=fa[x],z=fa[y],l,r; if(c[y][0]==x)l=0;else l=1;r=l^1; if(!isroot(y))&#123;if(c[z][0]==y)c[z][0]=x;else c[z][1]=x;&#125; fa[x]=z;fa[y]=x;fa[c[x][r]]=y; c[y][l]=c[x][r];c[x][r]=y;&#125;void relax(int x)&#123;if(!isroot(x))relax(fa[x]);down(x);&#125;void splay(int x)&#123; relax(x); while(!isroot(x)) &#123; int y=fa[x],z=fa[y]; if(!isroot(y)) &#123; if((c[y][0]==x)^(c[z][0]==y))rotate(x); else rotate(y); &#125; rotate(x); &#125;&#125;void access(int x,int val)&#123; int o=0; while(x) &#123; splay(x);modify(v[x],t[x].mx); c[x][1]=o;o=x;x=fa[x]; &#125; tag[o]=v[o]=val;&#125;void build()&#123;for(int i=1;i&lt;=size;i++)fa[i]=t[i].fa;&#125;int main()&#123; n=read();m=read(); scanf("%s",s+1); for(int i=1;i&lt;=m;i++) &#123; p[i]=read();r=read(); q[r].push_back(i); &#125; last=size=root=1; for(int i=1;i&lt;=n;i++)ins(s[i]-'0',i); build(); for(int i=1;i&lt;=n;i++) &#123; access(num[i],i); int sz=q[i].size(); for(int j=0;j&lt;sz;j++) &#123; int x=q[i][j]; ans[x]=query(p[x]); &#125; &#125; for(int i=1;i&lt;=m;i++)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>SAM</tag>
        <tag>Link-Cut Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC 005F」Many Easy Problems]]></title>
    <url>%2Fagc005f%2F</url>
    <content type="text"><![CDATA[给定一棵 nnn 个节点的树，选出 kkk 个特殊点，假设点集为 SSS，令 f(S)f(S)f(S) 为最小的包含这 kkk 个节点的连通块，分别求出 k=1⋯nk=1\cdots nk=1⋯n 在所有情况下的 f(S)f(S)f(S) 的和。 Constraints 2≤n≤2000002 \leq n \leq 2000002≤n≤200000 Solution 考虑暴力，一个点被统计在连通块内，即在以它为根时，选出来的 kkk 个点都在它的同一个儿子的子树内。即节点 xxx 被统计进答案的次数 g(x)g(x)g(x) 为： g(x)=(nk)−∑(x,i)⊆E(szik)g(x)=\binom{n}{k}-\sum _{(x,i)\subseteq E}\binom{sz_{i}}{k} g(x)=(kn​)−(x,i)⊆E∑​(kszi​​) 令 cntxcnt_{x}cntx​ 表示上述公式里有多少个 szi=xsz_{i}=xszi​=x，那么可以得到： ansk=∑i=1ncnti⋅(ik)ans_{k}=\sum _{i=1}^{n}cnt_{i}\cdot\binom{i}{k} ansk​=i=1∑n​cnti​⋅(ki​) 整理可得： k!⋅ansk=∑i=1ncnti⋅i!(i−k)!k!\cdot ans_{k}=\sum _{i=1}^{n}\frac{cnt_{i}\cdot i!}{(i-k)!} k!⋅ansk​=i=1∑n​(i−k)!cnti​⋅i!​ 令 ai=cnti⋅i!a_{i}=cnt_{i}\cdot i!ai​=cnti​⋅i!，bi=(n−i)!b_{i}=(n-i)!bi​=(n−i)!，则可得： k!⋅ansk=∑i=1nai⋅bn−i+kk!\cdot ans_{k}=\sum _{i=1}^{n}a_{i}\cdot b_{n-i+k} k!⋅ansk​=i=1∑n​ai​⋅bn−i+k​ 最终答案为 n⋅(nk)−anskn\cdot \binom{n}{k}-ans_{k}n⋅(kn​)−ansk​ 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e5+5;const int M=524288+5;const int mod=924844033; int n,nn,cnt,u,v,ans,first[N],fac[N],inv[N];int num[N],sz[N],a[M],b[M];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x,int fa)&#123; sz[x]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs(to,x); sz[x]+=sz[to]; &#125; if(fa!=-1)a[sz[x]]++,a[n-sz[x]]++;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;void ntt(int *a,int n,int f)&#123; int k=0;while((1&lt;&lt;k)&lt;n)k++; for(int i=0;i&lt;n;i++) &#123; int t=0; for(int j=0;j&lt;k;j++) if(i&amp;(1&lt;&lt;j))t|=(1&lt;&lt;(k-j-1)); if(i&lt;t)swap(a[i],a[t]); &#125; for(int l=2;l&lt;=n;l&lt;&lt;=1) &#123; int m=l&gt;&gt;1,nw=power(5,(mod-1)/l); if(f==-1)nw=power(nw,mod-2); for(int *p=a;p!=a+n;p+=l) &#123; int w=1; for(int i=0;i&lt;m;i++) &#123; int t=1ll*p[m+i]*w%mod; p[m+i]=(p[i]-t+mod)%mod; p[i]=(p[i]+t)%mod; w=1ll*w*nw%mod; &#125; &#125; &#125; if(f==-1) &#123; int inv=power(n,mod-2); for(int i=0;i&lt;n;i++)a[i]=1ll*a[i]*inv%mod; &#125;&#125;int main()&#123; n=read(); for(int i=1;i&lt;n;i++) &#123; u=read();v=read(); ins(u,v);ins(v,u); &#125; dfs(1,-1); fac[0]=1; for(int i=1;i&lt;=n;i++)fac[i]=1ll*fac[i-1]*i%mod; inv[n]=power(fac[n],mod-2); for(int i=n;i&gt;=1;i--)inv[i-1]=1ll*inv[i]*i%mod; for(int i=1;i&lt;=n;i++)a[i]=1ll*a[i]*fac[i]%mod; for(int i=0;i&lt;=n;i++)b[n-i]=inv[i]; nn=1;while(nn&lt;n+n+1)nn&lt;&lt;=1; ntt(a,nn,1);ntt(b,nn,1); for(int i=0;i&lt;nn;i++)a[i]=1ll*a[i]*b[i]%mod; ntt(a,nn,-1); for(int i=1;i&lt;=n;i++) &#123; ans=1ll*fac[n]*inv[i]%mod*inv[n-i]%mod*n%mod; printf("%lld\n",(ans-1ll*a[n+i]*inv[i]%mod+mod)%mod); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>NTT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AGC 002F」Leftmost Ball]]></title>
    <url>%2Fagc002f%2F</url>
    <content type="text"><![CDATA[有 nnn 种颜色的球，标号 111 到 nnn ，每种颜色有 kkk 个。将 nknknk 个球随机排列后，将每种颜色的第一个球涂成颜色 000 ，求最终可能得到的颜色序列的方案数。 Constraints 1≤n,k≤20001\leq n,k \leq 20001≤n,k≤2000 Solution 令 f(i,j) (i≤j)f(i,j)~(i\leq j)f(i,j) (i≤j) 表示已经放置了 iii 个编号为 000 的球与 jjj 种第一次出现的位置最靠前的颜色的方案数。每次在当前的第一个空位放置一个颜色为 000 的球或是一种未出现的颜色的球。可得转移方程： f(i,j)=f(i−1,j)+(n−i+(n−j+1)⋅(k−1)−1k−2)⋅(n−j+1)⋅f(i,j−1)f(i,j)=f(i-1,j)+\binom{n-i+(n-j+1)\cdot(k-1)-1}{k-2}\cdot(n-j+1)\cdot f(i,j-1) f(i,j)=f(i−1,j)+(k−2n−i+(n−j+1)⋅(k−1)−1​)⋅(n−j+1)⋅f(i,j−1) 时间复杂度O(nk)O(nk)O(nk)。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=2e3+5;const int mod=1e9+7;int n,m,fac[N*N],inv[N*N],f[N][N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int C(int n,int m)&#123;return 1ll*fac[n]*inv[m]%mod*inv[n-m]%mod;&#125;int main()&#123; n=read();m=read(); if(m==1)&#123;printf("1");return 0;&#125; fac[0]=1; for(int i=1;i&lt;=n*m;i++)fac[i]=1ll*fac[i-1]*i%mod; inv[n*m]=power(fac[n*m],mod-2); for(int i=n*m;i&gt;=1;i--)inv[i-1]=1ll*inv[i]*i%mod; f[0][0]=1; for(int i=1;i&lt;=n;i++) for(int j=0;j&lt;=i;j++) &#123; f[i][j]=f[i-1][j]; if(!j)continue; Mod(f[i][j],1ll*f[i][j-1]*(n-j+1)%mod*C(n-i+(n-j+1)*(m-1)-1,m-2)%mod); &#125; printf("%d",f[n][n]); return 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 765F」Souvenirs]]></title>
    <url>%2Fcf765f%2F</url>
    <content type="text"><![CDATA[给定 nnn 个数， mmm 次询问，每次询问区间中 ∣ai−aj∣|a_{i}-a_{j}|∣ai​−aj​∣ 的最小值。 Constraints 2≤n≤1052 \leq n \leq 10^52≤n≤105 ，0≤ai≤1090 \leq a_i \leq 10^90≤ai​≤109 ，1≤m≤3⋅1051 \leq m \leq 3\cdot 10^51≤m≤3⋅105 Solution 对于每一个 iii ，考虑所有满足 j&gt;ij&gt;ij&gt;i 且 aj≤aia_{j}\leq a_{i}aj​≤ai​ 的可能可以成为答案的 jjj（aj≥aia_{j}\geq a_{i}aj​≥ai​ 的情况可以用同样的方式处理）。假设当前已经找到了一对 (i,j)(i,j)(i,j)，则下一个合法的位置 kkk 需要满足 ak&lt;aja_{k}&lt;a_{j}ak​&lt;aj​ 且 ak−ai&lt;aj−aka_{k}-a_{i}&lt;a_{j}-a_{k}ak​−ai​&lt;aj​−ak​，即每次需要查询区间 [j+1,n][j+1,n][j+1,n] 内的第一个满足 ai≤ak&lt;ai+aj2a_{i}\leq a_{k}&lt;\frac{a_{i}+a_{j}}{2}ai​≤ak​&lt;2ai​+aj​​ 的 kkk，可以将数字从大到小加入线段树后直接查询。由于 aj−aia_{j}-a_{i}aj​−ai​ 每次至少减少一半，所以最多有 O(nloga)O(nloga)O(nloga)对(i,j)(i,j)(i,j) 。 得到所有合法的 (i,j)(i,j)(i,j) 后，可以按 jjj 排序后插入树状数组，每次查询左端点。时间复杂度 O((nloga+m)logn)O((nloga+m)logn)O((nloga+m)logn) 。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long long#define lc(x) x&lt;&lt;1#define rc(x) x&lt;&lt;1|1using namespace std;const int N=1e5+5;const int inf=0x3f3f3f3f;int n,m,tot,sum,a[N],b[N];int mn[N*4],ans[N*10];struct data&#123; int l,r,w,id; bool operator &lt; (const data &amp;t) const&#123;return r&lt;t.r||(r==t.r&amp;&amp;id&lt;t.id);&#125;&#125;c[N*70];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;bool cmp(int x,int y)&#123;return a[x]&gt;a[y]||(a[x]==a[y]&amp;&amp;x&gt;y);&#125;void modify(int x,int l,int r,int p,int w)&#123; mn[x]=min(mn[x],w); if(l==r)return; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid)modify(lc(x),l,mid,p,w); else modify(rc(x),mid+1,r,p,w);&#125;int find(int x,int l,int r,int p,int w)&#123; if(l==r)return mn[x]&lt;=w?l:0; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid&amp;&amp;mn[lc(x)]&lt;=w) &#123; int t=find(lc(x),l,mid,p,w); if(t)return t; &#125; return find(rc(x),mid+1,r,p,w);&#125;void solve()&#123; memset(mn,0x3f,sizeof(mn)); sort(b+1,b+n+1,cmp); for(int i=1;i&lt;=n;i++) &#123; int j=find(1,1,n,b[i],inf-1); while(j) &#123; c[++tot]=(data)&#123;b[i],j,a[j]-a[b[i]],0&#125;; j=find(1,1,n,b[i],((a[b[i]]+a[j]-1)/2)); &#125; modify(1,1,n,b[i],a[b[i]]); &#125;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void change(int x,int w)&#123; x=n-x+1; while(x&lt;=n)mn[x]=min(mn[x],w),x+=lowbit(x);&#125;int query(int x)&#123; x=n-x+1;sum=inf; while(x)sum=min(sum,mn[x]),x-=lowbit(x); return sum;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)a[i]=read()+1,b[i]=i; solve(); for(int i=1;i&lt;=n;i++)a[i]=1e9+2-a[i]; solve(); m=read(); for(int i=1;i&lt;=m;i++) c[++tot]=(data)&#123;read(),read(),0,i&#125;; sort(c+1,c+tot+1); memset(mn,0x3f,sizeof(mn)); for(int i=1;i&lt;=tot;i++) if(c[i].id)ans[c[i].id]=query(c[i].l); else change(c[i].l,c[i].w); for(int i=1;i&lt;=m;i++)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 5217」Brackets]]></title>
    <url>%2Fhdu5217%2F</url>
    <content type="text"><![CDATA[给出一个长度为 nnn 的括号序列和 222 种操作：1.1.1. 翻转某一个括号；2.2.2. 查询区间内完成括号匹配后第 kkk 个括号的原位置。 Constraints 1≤n,q≤2000001\leq n,q \leq 2000001≤n,q≤200000 Solution 易得，最后的序列一定形如 ‘)))(((’ ，即左段皆为 ‘)’，右段皆为 ‘(’ 。我们可以建出一棵线段树，线段树上的每个节点对应区间内匹配后左段 ‘(’ 的数量和右段 ‘)’ 的数量。 区间合并与修改显然，主要问题在查询。至此我们可以通过查询区间 [L,R][L,R][L,R] 的信息快速得到第 kkk 个括号的类型。因为 ‘(’ 在从右往左合并区间时单调不减， ‘)’ 在从左往右合并区间时单调不减，所以可以在线段树上边跑边查询。详见代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define lc x&lt;&lt;1#define rc x&lt;&lt;1|1#define LL long longusing namespace std;const int N=5e5+5;int T,n,m,op,L,R,x;int a[N],id[N],tl[N*4],tr[N*4];char ch[N];struct node&#123;int t1,t0;&#125;ans,now,tmp,t[N*4];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;node merge(node a,node b)&#123; node c=(node)&#123;a.t1,b.t0&#125;; if(a.t0&gt;b.t1)c.t0+=a.t0-b.t1; else c.t1+=b.t1-a.t0; return c;&#125;void build(int x,int l,int r)&#123; tl[x]=l;tr[x]=r; if(l==r) &#123; if(a[l])t[x]=(node)&#123;1,0&#125;; else t[x]=(node)&#123;0,1&#125;; id[l]=x;return; &#125; int mid=(l+r)&gt;&gt;1; build(lc,l,mid); build(rc,mid+1,r); t[x]=merge(t[lc],t[rc]);&#125;void modify(int x,int l,int r,int p)&#123; if(l==r) &#123; swap(t[x].t0,t[x].t1); return; &#125; int mid=(l+r)&gt;&gt;1; if(p&lt;=mid)modify(lc,l,mid,p); else modify(rc,mid+1,r,p); t[x]=merge(t[lc],t[rc]);&#125;void query(int x,int l,int r)&#123; if(L&lt;=l&amp;&amp;r&lt;=R) &#123; ans=merge(ans,t[x]); return; &#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)query(lc,l,mid); if(R&gt;mid)query(rc,mid+1,r);&#125;int work0(int x,int l,int r,int goal)&#123; if(l==r)return l; int mid=(l+r)&gt;&gt;1; tmp=now;now=merge(t[rc],now); if(now.t0&gt;=goal) &#123; now=tmp; return work0(rc,mid+1,r,goal); &#125; return work0(lc,l,mid,goal);&#125;int find0(int p,int goal)&#123; int x=id[p]; bool flag=false; now=merge(t[x],now); if(now.t0==goal)return p; if(x&amp;1)flag=true; while(1) &#123; x&gt;&gt;=1; if(flag) &#123; tmp=now;now=merge(t[lc],now); if(now.t0&gt;=goal)&#123;now=tmp;x=lc;break;&#125; &#125; if(x&amp;1)flag=true; else flag=false; &#125; return work0(x,tl[x],tr[x],goal);&#125;int work1(int x,int l,int r,int goal)&#123; if(l==r)return l; int mid=(l+r)&gt;&gt;1; tmp=now;now=merge(now,t[lc]); if(now.t1&gt;=goal) &#123; now=tmp; return work1(lc,l,mid,goal); &#125; return work1(rc,mid+1,r,goal);&#125;int find1(int p,int goal)&#123; int x=id[p]; bool flag=true; now=merge(now,t[x]); if(now.t1==goal)return p; if(x&amp;1)flag=false; while(1) &#123; x&gt;&gt;=1; if(flag) &#123; tmp=now;now=merge(now,t[rc]); if(now.t1&gt;=goal)&#123;now=tmp;x=rc;break;&#125; &#125; if(x&amp;1)flag=false; else flag=true; &#125; return work1(x,tl[x],tr[x],goal);&#125;void work()&#123; n=read();m=read(); scanf("%s",ch+1); for(int i=1;i&lt;=n;i++) if(ch[i]=='(')a[i]=0; else a[i]=1; build(1,1,n); while(m--) &#123; op=read(); if(op==1) &#123; x=read(); modify(1,1,n,x); continue; &#125; L=read();R=read();x=read(); ans.t0=ans.t1=0; query(1,1,n); if(ans.t0+ans.t1&lt;x) &#123; printf("-1\n"); continue; &#125; now.t0=now.t1=0; if(x&lt;=ans.t1)printf("%d\n",find1(L,x)); else printf("%d\n",find0(R,ans.t0+ans.t1-x+1)); &#125;&#125;int main()&#123; T=read(); while(T--)work(); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HDU 5632」Rikka with Array]]></title>
    <url>%2Fhdu5632%2F</url>
    <content type="text"><![CDATA[给定一个数 nnn ，问有多少个数对 (i,j)(i,j)(i,j) ，满足 1≤i&lt;j≤n1\leq i&lt;j \leq n1≤i&lt;j≤n 且 f[i]&gt;f[j]f[i]&gt;f[j]f[i]&gt;f[j] ，f[x]f[x]f[x] 为 xxx 二进制表示下 111 的个数。 Constraints n≤10300n \leq 10^{300}n≤10300 Solution （在打模拟赛时写到的题目……好像写了一种跟所有人都不一样的写法） 首先考虑一个数 xxx ，我们需要统计满足 1≤i&lt;x1\leq i&lt;x1≤i&lt;x 且 f[i]&gt;f[x]f[i]&gt;f[x]f[i]&gt;f[x] 的 iii 的个数。考虑数位 dpdpdp ，将 xxx 转为二进制形式，从低位往高位推。假设当前在第 iii 位，从第 111 位到第 iii 位共有 kkk 个 111 ：若当前位为 000 ，则直接跳过进行下一位的统计；否则钦定当前要统计进答案的数字的比第 iii 位高的位置与 xxx 相同，且第 iii 位为 000 ，则此时最低的第 i−1i-1i−1 位至少要有 k+1k+1k+1 个 111 ，可任意选取，即需要统计进答案里的方案数为 ∑j=k+1i−1(i−1j)\sum _{j=k+1}^{i-1} \binom{i-1}{j}∑j=k+1i−1​(ji−1​) ，令 s(i,j)=∑d=0j(id)s(i,j)=\sum _{d=0}^{j}\binom{i}{d}s(i,j)=∑d=0j​(di​) ，则公式简化为 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 。 现在我们需要统计总答案，且因为 nnn 很大，无法直接枚举。考虑将 nnn 转成二进制形式，共有 cntcntcnt 位，aia_{i}ai​ 为 nnn 在二进制下第 iii 位上的数字。统计每一个 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 被统计进答案的贡献。若 s(i−1,i−1)−s(i−1,k)s(i-1,i-1)-s(i-1,k)s(i−1,i−1)−s(i−1,k) 会在数字 xxx 时被统计进答案里， xxx 需要满足以下几个条件：1. 1≤x≤n1\leq x\leq n1≤x≤n ，2. xxx 的第 iii 位为 111 ，3. xxx 的前 iii 位恰好有 kkk 个 111 。答案转化为统计满足条件的 xxx 的个数。 我们递推一个数组 fff ，f(i,j)f(i,j)f(i,j) 表示数值小于等于 nnn 最低的 iii 位，且二进制下恰好含有 jjj 个 111 的数字的方案数。可得： f(i,j)={f(i−1,j) (ai=0)f(i−1,j−1)+(i−1j) (ai=1)f(i,j)=\begin{cases}f(i-1,j)~~~~~~~~~~~~~~~~~~~~~~~(a_{i}=0)\\f(i-1,j-1)+\binom{i-1}{j}~~~(a_{i}=1)\end{cases} f(i,j)={f(i−1,j) (ai​=0)f(i−1,j−1)+(ji−1​) (ai​=1)​ 特殊的，f(i,0)=1(0≤i≤cnt)f(i,0)=1(0\leq i\leq cnt)f(i,0)=1(0≤i≤cnt) 。然后就可以数位 dpdpdp 出对于每一个 (i−1,k)(i-1,k)(i−1,k) 的组合，所有符合条件的数 xxx 了。 枚举当前在第 iii 位，前 i−1i-1i−1 位总共有 kkk 个 111 ，我们令 num=∑d=i+1cnt2d−(i+1)⋅adnum=\sum _{d=i+1}^{cnt} 2^{d-(i+1)}\cdot a_{d}num=∑d=i+1cnt​2d−(i+1)⋅ad​ ，即大于第 iii 位的部分的 000 到 num−1num-1num−1 的方案，则 s(i−1,i−1)−s(i−1,k+1)s(i-1,i-1)-s(i-1,k+1)s(i−1,i−1)−s(i−1,k+1) 的系数 ttt 计算方式如下： t={num⋅(i−1k) (ai=0)num⋅(i−1k)+f(i−1,k) (ai=1)t=\begin{cases}num\cdot \binom{i-1}{k}~~~~~~~~~~~~~~~~~~~~~~~~~(a_{i}=0)\\num\cdot \binom{i-1}{k}+f(i-1,k)~~~(a_{i}=1)\end{cases} t={num⋅(ki−1​) (ai​=0)num⋅(ki−1​)+f(i−1,k) (ai​=1)​ 然后就可以得到最终的答案了。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e3+5;const int mod=998244353;int T,n,cnt,ans,tmp,num,now,t;int x[N],a[N],C[N][N],s[N][N],f[N][N];char ch[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;int main()&#123; for(int i=0;i&lt;=1000;i++)C[i][0]=1; for(int i=1;i&lt;=1000;i++) for(int j=1;j&lt;=i;j++) C[i][j]=(C[i-1][j]+C[i-1][j-1])%mod; for(int i=0;i&lt;=1000;i++) for(int j=0;j&lt;=1000;j++) if(j)s[i][j]=(s[i][j-1]+C[i][j])%mod; else s[i][j]=C[i][j]; T=read(); while(T--) &#123; cnt=ans=0; scanf("%s",ch+1); n=strlen(ch+1); for(int i=1;i&lt;=n;i++)x[n-i+1]=ch[i]-'0'; if(n==1&amp;&amp;(x[1]==0||x[1]==1))&#123;printf("0\n");continue;&#125; while(n) &#123; if(x[1]&amp;1)a[++cnt]=1,x[1]--; else a[++cnt]=0; for(int i=n;i&gt;=1;i--) if(x[i]&amp;1)x[i]/=2,x[i-1]+=10; else x[i]/=2; while(n&amp;&amp;x[n]==0)n--; &#125; memset(f,0,sizeof(f)); for(int i=0;i&lt;=cnt;i++)f[i][0]=1; for(int j=1;j&lt;=cnt;j++) for(int i=j;i&lt;=cnt;i++) if(!a[i])Mod(f[i][j],f[i-1][j]); else &#123; Mod(f[i][j],f[i-1][j-1]); Mod(f[i][j],C[i-1][j]); &#125; for(int i=1;i&lt;=cnt;i++) &#123; num=0; for(int j=cnt;j&gt;i;j--)num=(num*2+a[j])%mod; for(int j=0;j&lt;i;j++) &#123; t=1ll*num*C[i-1][j]%mod; Mod(ans,1ll*(s[i-1][i-1]-s[i-1][j+1]+mod)%mod*t%mod); if(!a[i])continue; Mod(ans,1ll*(s[i-1][i-1]-s[i-1][j+1]+mod)%mod*f[i-1][j]%mod); &#125; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数位dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 914H」Ember and Storm's Tree Game]]></title>
    <url>%2Fcf914h%2F</url>
    <content type="text"><![CDATA[Ember 和 Storm 正在玩游戏。首先，Ember 构造一棵 nnn 个节点且每个节点度数不超过 ddd 的带节点编号的树 TTT 。然后，Storm 选择两个不同的节点 uuu 和 vvv ，并写下从 uuu 到 vvv 路径上的节点编号，记为序列 a1,a2⋯aka_1,a_2\cdots a_ka1​,a2​⋯ak​ 。最后，Ember 在序列中选择一个位置 i(1≤i&lt;k)i(1\leq i &lt; k)i(1≤i&lt;k) ，并在以下两个操作选择一个执行： 翻转 ai+1⋯aka_{i+1}\cdots a_kai+1​⋯ak​ 并将这一段加上 aia_iai​，操作后序列变为 a1a_1a1​，⋯ai\cdots a_i⋯ai​，ak+aia_k+a_iak​+ai​，ak−1+aia_{k-1}+a_iak−1​+ai​，⋯ai+1+ai\cdots a_{i+1}+a_i⋯ai+1​+ai​ 取负 ai+1⋯aka_{i+1}\cdots a_kai+1​⋯ak​ 并将这一段加上 aia_iai​，操作后序列变为 a1a_1a1​，⋯ai\cdots a_i⋯ai​，−ai+1+ai-a_{i+1}+a_i−ai+1​+ai​，−ai+2+ai-a_{i+2}+a_i−ai+2​+ai​，⋯−ak+ai\cdots -a_k+a_i⋯−ak​+ai​ 如果最后的序列是严格单调的，则 Ember 获胜，否则 Storm 获胜。 游戏情形可以用一个元组 (T,u,v,i,op)(T,u,v,i,op)(T,u,v,i,op) 来描述，opopop 为翻转或是取负取决于 Ember 的决策。若 Ember 和 Storm 都使用最优策略（若有多种必胜策略，任选一种执行；若必败，也任选一种执行），试统计所有可能的游戏情形的数量，并输出其取模 mmm 的结果。 Constraints 2≤n≤2002\leq n \leq 2002≤n≤200 ，1≤d&lt;n1 \leq d &lt; n1≤d&lt;n ，1≤m≤2⋅1091 \leq m \leq 2\cdot 10^91≤m≤2⋅109 Solution 首先，Ember 一定会构造出一棵能让自己必胜的树。而 Ember 获胜当而仅当原序列 aaa 为单调的或是单峰的；且对于每一个合法的序列，有 222 种合法的 (i,op)(i,op)(i,op) 的组合。没有什么好证明的……在草稿纸上自己模拟一下两种操作就可以得到了。 问题转换为：统计满足以下条件的树的数量 SSS ：1. 包含nnn个节点，2. 每个节点度数不超过 ddd ，3. 树上任意两个节点间路径的编号序列为单调的或单峰的。最终答案为 2⋅n⋅(n−1)⋅S2\cdot n\cdot(n-1)\cdot S2⋅n⋅(n−1)⋅S 。 而对于一棵合法的树，一定存在一个特殊点，满足以这个节点为起点或终点的所有路径都是单调的。为了方便统计，我们令合法树的根节点为特殊点。观察可得，对于一棵合法树，除根节点以外的子树都满足：父亲节点编号大于儿子编号，或是父亲编号小于儿子编号。所以我们只需要统计这两种情况的答案，然后在根节点处拼起来即可。而实际上，这两种情况是等价的。 令 f(i,j)f(i,j)f(i,j) 表示节点数为 iii ，根节点度数为 jjj ，且父亲编号小于儿子编号的方案数。 枚举当前要拼接的子树大小 kkk ，钦定根节点编号最小，拼接过来的子树的根节点编号次小，可得到以下递推公式： f(i,j)=∑k=1i−1f(i−k,j−1)⋅(i−2k−1)⋅∑l=1d−1f(k,l)f(i,j)=\sum _{k=1}^{i-1}f(i-k,j-1)\cdot \binom{i-2}{k-1}\cdot \sum _{l=1}^{d-1}f(k,l) f(i,j)=k=1∑i−1​f(i−k,j−1)⋅(k−1i−2​)⋅l=1∑d−1​f(k,l) 令 sum(i)=∑j=1d−1f(i,j)sum(i)=\sum _{j=1}^{d-1}f(i,j)sum(i)=∑j=1d−1​f(i,j)，可得： f(i,j)=∑k=1i−1f(i−k,j−1)⋅(i−2k−1)⋅sum(k)f(i,j)=\sum _{k=1}^{i-1}f(i-k,j-1)\cdot \binom{i-2}{k-1}\cdot sum(k) f(i,j)=k=1∑i−1​f(i−k,j−1)⋅(k−1i−2​)⋅sum(k) 时间复杂度为 O(n3)O(n^{3})O(n3) ，初始化 f(1,0)=sum(1)=1f(1,0)=sum(1)=1f(1,0)=sum(1)=1 。 （这种方法是在评论区看到的……然后参考了一下wxh大爷的博客。官方题解给了另一种统计 fff 数组的方式，要稍微复杂一些，以及因为不保证 mmm 是质数，会有一些细节需要处理。详见官方题解，细节处理详见评论区。） 统计出 fff 数组后就可以开始拼接了，枚举满足父亲节点编号小于儿子编号的点数 iii 、度数 jjj , 满足父亲节点编号大于儿子编号的度数 kkk ，可得到以下公式： S=∑i=0n−1∑j=0d∑k=0d−jf(i+1,j)⋅f(n−i,k)S=\sum _{i=0}^{n-1}\sum _{j=0}^{d}\sum _{k=0}^{d-j}f(i+1,j)\cdot f(n-i,k) S=i=0∑n−1​j=0∑d​k=0∑d−j​f(i+1,j)⋅f(n−i,k) 而实际上一棵合法树是可以有多个合法根的，比如最简单的 n=2n=2n=2 的情况，合法根既可以是 111 也可以是 222 。我们可以得出另一个结论，如果一棵树有多个合法根，那么这些点一定构成一条单调链，一端是 j=1j=1j=1 且 k≠1k≠1k≠1 ，另一端是 j≠1j≠1j≠1 且 k=1k=1k=1 ，中间是 j=1j=1j=1 且 k=1k=1k=1 ，我们把这棵树放在第一种情况统计。 得到最终公式： S=∑i=0n−1∑j+k≤d,k≠1f(i+1,j)⋅f(n−i,k)S=\sum _{i=0}^{n-1}\sum _{j+k\leq d,k\neq 1}f(i+1,j)\cdot f(n-i,k) S=i=0∑n−1​j+k≤d,k≠1∑​f(i+1,j)⋅f(n−i,k) Code 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=205;int n,d,mod;LL ans,sum[N],c[N][N],f[N][N];int main()&#123; scanf("%d%d%d",&amp;n,&amp;d,&amp;mod); for(int i=0;i&lt;=n;i++)c[i][0]=1; for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=i;j++) c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod; sum[1]=1;f[1][0]=1; for(int i=2;i&lt;=n;i++) &#123; for(int j=1;j&lt;=d;j++) for(int k=1;k&lt;i;k++) f[i][j]=(f[i][j]+f[i-k][j-1]*sum[k]%mod*c[i-2][k-1]%mod)%mod; for(int j=1;j&lt;=d-1;j++) sum[i]=(sum[i]+f[i][j])%mod; &#125; for(int i=0;i&lt;=n-1;i++) for(int j=0;j&lt;=d;j++) for(int k=0;j+k&lt;=d;k++) if(k!=1)ans=(ans+f[i+1][j]*f[n-i][k]%mod)%mod; printf("%lld",2*n*(n-1)*ans%mod); return 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>背包dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 870F」Paths]]></title>
    <url>%2Fcf870f%2F</url>
    <content type="text"><![CDATA[给定数字 nnn ，建立一个无向图。对于所有 111 到 nnn 之间的数字，当数字 gcd(u,v)≠1gcd(u,v)\neq 1gcd(u,v)≠1 时将 uuu、vvv 连一条边，边权为 111 。d(u,v)d(u,v)d(u,v) 表示 uuu 到 vvv 的最短路，求所有 d(u,v)d(u,v)d(u,v) 的和，其中 1≤u&lt;v≤n1\leq u &lt; v \leq n1≤u&lt;v≤n。 Constraints $1 \leq n \leq 10^7 $ Solution 对于 111 以及所有大于 n2\frac{n}{2}2n​ 的质数，与其他数字均不联通，直接剔除。 对于剩下的数字： 1.1.1. 当 gcd(u,v)≠1gcd(u,v) \neq 1gcd(u,v)≠1 时，d(u,v)=1d(u,v)=1d(u,v)=1 。即对于数字 uuu，小于 uuu 且 d(u,v)=1d(u,v)=1d(u,v)=1 的数字个数为 x−1−φ(x)x-1-\varphi (x)x−1−φ(x) 。 2.2.2. 令 p[u]p[u]p[u] 表示数字 uuu 的最小质因子，则当 p[u]⋅p[v]≤np[u]\cdot p[v]\leq np[u]⋅p[v]≤n 时，d(u,v)=2d(u,v)=2d(u,v)=2 。维护数组 numnumnum 、sumsumsum ， num[i]num[i]num[i] 代表最小质因子为 iii 的数字个数， sumsumsum 数组为 numnumnum 数组的前缀和。统计 ∑num[i]⋅sum[n/i]\sum num[i]\cdot sum[n/i]∑num[i]⋅sum[n/i] 可以覆盖所有 p[u]⋅p[v]≤np[u]\cdot p[v] \leq np[u]⋅p[v]≤n 的情况，其中减去自身与自身被统计的情况，剩下的所有数对都被统计了两次，其中包含 gcd(u,v)≠1gcd(u,v)\neq 1gcd(u,v)≠1 的情况，需进行相应处理，详见代码。 3.3.3. 剩下的数对最短路一定为 333 ，因为 uuu → 2⋅p[u]2\cdot p[u]2⋅p[u] → 2⋅p[v]2\cdot p[v]2⋅p[v] → vvv 这条路一定存在。可通过数对总数减去 d(u,v)=1d(u,v)=1d(u,v)=1 与 d(u,v)=2d(u,v)=2d(u,v)=2 的情况得到。 Code 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define LL long longusing namespace std;const int N=1e7+5;int n,m,tot,now,pri[N],p[N],phi[N],num[N],sum[N]; LL one,two,three;int main()&#123; scanf("%d",&amp;n); phi[1]=1; for(int i=2;i&lt;=n;i++) &#123; if(!p[i])&#123;p[i]=pri[++tot]=i;phi[i]=i-1;&#125; for(int j=1;j&lt;=tot;j++) &#123; if(i*pri[j]&gt;n)break; p[i*pri[j]]=pri[j]; if(i%pri[j]==0)&#123;phi[i*pri[j]]=phi[i]*pri[j];break;&#125; else phi[i*pri[j]]=phi[i]*(pri[j]-1); &#125; &#125; for(int i=2;i&lt;=n;i++)one+=i-1-phi[i]; for(int i=2;i&lt;=n;i++)num[p[i]]++; for(int i=2;i&lt;=n;i++)sum[i]=sum[i-1]+num[i]; for(int i=2;i&lt;=n;i++)two+=1ll*num[i]*sum[n/i]; for(int i=2;i&lt;=n;i++)if(1ll*p[i]*p[i]&lt;=n)two--; two=two/2-one;m=n-1; for(int i=tot;i&gt;=1;i--) if(pri[i]*2&gt;n)m--; else break; three=1ll*m*(m-1)/2-one-two; printf("%lld\n",one+two*2+three*3); return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「ARC 063F」Snuke's Coloring 2]]></title>
    <url>%2Farc063f%2F</url>
    <content type="text"><![CDATA[给定一个 W×HW\times HW×H 的二维平面，初始均为白色，有 nnn 个关键点 (xi,yi)(x_{i},y_{i})(xi​,yi​) ，对于每一个关键点选择一个方向，并将该方向上的所有网格涂成黑色。易得操作后白色部分一定是一个矩形，请最大化矩形周长。 Constraints 0≤n≤2⋅1050 \leq n \leq 2 \cdot 10^50≤n≤2⋅105 ，1≤w,h≤1081 \leq w,h \leq 10^81≤w,h≤108 Solution 观察可以得到一个性质，答案矩形一定会经过直线 x=W2x=\frac{W}{2}x=2W​ 或 y=H2y=\frac{H}{2}y=2H​ 。两种情况可以用相同的方式处理出答案。 将坐标离散化后，枚举矩形的上下边界，可以直接计算出矩形的左右边界。考虑用线段树进行优化。左右各开一个单调栈，在维护单调栈时在线段树上进行区间加减即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long long#define lc(x) x&lt;&lt;1#define rc(x) x&lt;&lt;1|1using namespace std;const int N=3e5+5;int w,h,n,ans,L,R;int mx[N*4],tag[N*4];struct node&#123;int x,y;node(int _x=0,int _y=0):x(_x),y(_y)&#123;&#125;;&#125;p[N],a[N],b[N]; int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void modify(int x,int l,int r,int v)&#123; if(L&lt;=l&amp;&amp;r&lt;=R)&#123;mx[x]+=v;tag[x]+=v;return;&#125; int mid=(l+r)&gt;&gt;1; if(L&lt;=mid)modify(lc(x),l,mid,v); if(R&gt;mid)modify(rc(x),mid+1,r,v); mx[x]=max(mx[lc(x)],mx[rc(x)])+tag[x];&#125;bool cmp(node a,node b)&#123;return a.x&lt;b.x||(a.x==b.x&amp;&amp;a.y&lt;b.y);&#125;void work()&#123; memset(mx,0,sizeof(mx)); memset(tag,0,sizeof(tag)); sort(p+1,p+n+1,cmp); int l=0,r=0; for(int i=1;i&lt;=n-1;i++) &#123; if(p[i].y&lt;=h/2) &#123; int nxt=i-1; while(l&amp;&amp;a[l].y&lt;p[i].y) &#123; L=a[l].x;R=nxt;nxt=a[l].x-1; modify(1,1,n,a[l].y-p[i].y);l--; &#125; if(nxt!=i-1)a[++l]=node(nxt+1,p[i].y); &#125; else &#123; int nxt=i-1; while(r&amp;&amp;b[r].y&gt;p[i].y) &#123; L=b[r].x;R=nxt;nxt=b[r].x-1; modify(1,1,n,p[i].y-b[r].y);r--; &#125; if(nxt!=i-1)b[++r]=node(nxt+1,p[i].y); &#125; a[++l]=node(i,0);b[++r]=node(i,h); L=i;R=i;modify(1,1,n,h-p[i].x); ans=max(ans,mx[1]+p[i+1].x); &#125;&#125;int main()&#123; w=read();h=read();n=read(); for(int i=1;i&lt;=n;i++)p[i].x=read(),p[i].y=read(); p[++n]=node(0,0);p[++n]=node(w,h);work(); for(int i=1;i&lt;=n;i++)swap(p[i].x,p[i].y); swap(w,h);work(); printf("%d",ans*2); return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4449」[Neerc2015]Distance on Triangulation]]></title>
    <url>%2Fbzoj4449%2F</url>
    <content type="text"><![CDATA[给定一个凸 nnn 边形，以及它的三角剖分。再给定 qqq 个询问，每个询问是一对凸多边行上的顶点 (a,b)(a,b)(a,b) ，问点 aaa 最少经过多少条边(可以是多边形上的边，也可以是剖分上的边)可以到达点 bbb 。 Constraints n≤50000n \leq 50000n≤50000 ，q≤100000q \leq 100000q≤100000 Solution 运用分治的思想，每一次选择一条剖分边，使得凸多边形分成尽量平均的两部分。使用 bfs 得出该条边的两个端点到各个顶点的最短路，对所有的询问在两个端点处进行拼凑并更新答案。然后对两部分的信息分别划开，进行下一层的分治。 （每次分治完，点数会比原来多 222 ，所以空间要开三倍。） Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;algorithm&gt; #include&lt;cstring&gt;#define LL long longusing namespace std;const int N=3e5+5;const int inf=0x3f3f3f3f;int n,m,cnt,x,y,t,tmp;int first[N],ans[N],id[N];int qq[N],disx[N],disy[N],q1[N],q2[N];bool ok[N];struct node&#123;int x,y,id;&#125;l[N],q[N],h1[N],h2[N];struct edge&#123;int to,next;&#125;e[N&lt;&lt;1];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int find(int l,int r,int x)&#123;return lower_bound(id+l,id+r+1,x)-id;&#125;void bfs(int S,int pl,int pr,int *dis)&#123; int head=0,tail=0; for(int i=pl;i&lt;=pr;i++)dis[id[i]]=inf; qq[tail++]=S;dis[S]=0; while(head!=tail) &#123; int u=qq[head++]; for(int i=first[u];i;i=e[i].next) &#123; int to=e[i].to; if(!ok[to])continue; if(dis[to]==inf)dis[to]=dis[u]+1,qq[tail++]=to; &#125; &#125; &#125;void work(int dl,int dr,int pl,int pr,int ql,int qr)&#123; if(dl&gt;dr||pl&gt;pr||ql&gt;qr)return; int mn=inf,mnid=0; for(int i=dl;i&lt;=dr;i++) &#123; x=find(pl,pr,l[i].x);y=find(pl,pr,l[i].y); if(x&gt;y)swap(x,y); tmp=max(y-x,x-y+pr-pl+1); if(tmp&lt;mn)mn=tmp,mnid=i; &#125; for(int i=pl;i&lt;=pr;i++)ok[id[i]]=true; bfs(l[mnid].x,pl,pr,disx); bfs(l[mnid].y,pl,pr,disy); for(int i=pl;i&lt;=pr;i++)ok[id[i]]=false; int t1=0,t2=0,t3=0,t4=0,t5=0,t6=0; for(int i=ql;i&lt;=qr;i++) &#123; x=q[i].x;y=q[i].y;t=q[i].id; if(x==l[mnid].x&amp;&amp;y==l[mnid].y)&#123;ans[t]=1;continue;&#125; ans[t]=min(ans[t],disx[x]+disx[y]); ans[t]=min(ans[t],disy[x]+disy[y]); ans[t]=min(ans[t],disx[x]+disy[y]+1); ans[t]=min(ans[t],disy[x]+disx[y]+1); if(q[i].x&gt;l[mnid].x&amp;&amp;q[i].y&lt;l[mnid].y)h1[++t1]=q[i]; else if((q[i].x&lt;l[mnid].x||q[i].x&gt;l[mnid].y)&amp;&amp; (q[i].y&lt;l[mnid].x||q[i].y&gt;l[mnid].y))h2[++t2]=q[i]; &#125; for(int i=1;i&lt;=t1;i++)q[ql+i-1]=h1[i]; for(int i=1;i&lt;=t2;i++)q[ql+t1+i-1]=h2[i]; for(int i=pl;i&lt;=pr;i++) &#123; if(id[i]&gt;=l[mnid].x&amp;&amp;id[i]&lt;=l[mnid].y)q1[++t3]=id[i]; if(id[i]&lt;=l[mnid].x||id[i]&gt;=l[mnid].y)q2[++t4]=id[i]; &#125; for(int i=1;i&lt;=t3;i++)id[pl+i-1]=q1[i]; for(int i=1;i&lt;=t4;i++)id[pl+t3+i-1]=q2[i]; for(int i=dl;i&lt;=dr;i++) &#123; if(i==mnid)continue; if(l[i].x&gt;=l[mnid].x&amp;&amp;l[i].y&lt;=l[mnid].y)h1[++t5]=l[i]; else h2[++t6]=l[i]; &#125; for(int i=1;i&lt;=t5;i++)l[dl+i-1]=h1[i]; for(int i=1;i&lt;=t6;i++)l[dl+t5+i-1]=h2[i]; work(dl+t5,dl+t5+t6-1,pl+t3,pl+t3+t4-1,ql+t1,ql+t1+t2-1); work(dl,dl+t5-1,pl,pl+t3-1,ql,ql+t1-1); &#125;int main()&#123; n=read(); for(int i=1;i&lt;=n-3;i++) &#123; l[i].x=read();l[i].y=read(); ins(l[i].x,l[i].y);ins(l[i].y,l[i].x); if(l[i].x&gt;l[i].y)swap(l[i].x,l[i].y); &#125; for(int i=1;i&lt;n;i++)ins(i,i+1),ins(i+1,i); ins(1,n);ins(n,1); m=read(); for(int i=1;i&lt;=m;i++) &#123; q[i].x=read();q[i].y=read();q[i].id=i; if(q[i].x&gt;q[i].y)swap(q[i].x,q[i].y); ans[i]=min(q[i].y-q[i].x,q[i].x-q[i].y+n); &#125; for(int i=1;i&lt;=n;i++)id[i]=i; work(1,n-3,1,n,1,m); for(int i=1;i&lt;=m;i++)printf("%d\n",ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>分治</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 4833」[Lydsy1704月赛]最小公倍佩尔数]]></title>
    <url>%2Fbzoj4833%2F</url>
    <content type="text"><![CDATA[令 (1+2)n=e(n)+2⋅f(n)(1+\sqrt 2)^n=e(n)+\sqrt 2\cdot f(n)(1+2​)n=e(n)+2​⋅f(n) ，其中 e(n),f(n)e(n),f(n)e(n),f(n) 都是整数，显然有 (1−2)n=e(n)−2⋅f(n)(1-\sqrt 2)^n=e(n)-\sqrt 2\cdot f(n)(1−2​)n=e(n)−2​⋅f(n)。令 g(n)g(n)g(n) 表示 f(1),f(2),⋯,f(n)f(1),f(2),\cdots ,f(n)f(1),f(2),⋯,f(n) 的最小公倍数，给定两个正整数 nnn 和 ppp ，其中 ppp 是质数，并且保证 f(1),f(2),⋯,f(n)f(1),f(2),\cdots ,f(n)f(1),f(2),⋯,f(n) 在模 ppp 意义下均不为 000，请计算 ∑i=1ni⋅g(i)\sum _{i=1}^{n}i\cdot g(i)∑i=1n​i⋅g(i) 模 ppp 的值。 Constraints T≤210T \leq 2 ^{10}T≤210 ，1≤n≤1061\leq n \leq 10 ^61≤n≤106 ，2≤p≤109+72\leq p \leq 10 ^9 +72≤p≤109+7 Solution 在开始推导前先观察两个式子： gcd(fib(a),fib(b))=fib(gcd(a,b))gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(xa−1,xb−1)=xgcd(a,b)−1gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1 gcd(xa−1,xb−1)=xgcd(a,b)−1 形如 f(n)=a⋅f(n−1)+b⋅f(n−2)f(n)=a\cdot f(n-1)+b\cdot f(n-2)f(n)=a⋅f(n−1)+b⋅f(n−2) 的式子具有性质 gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y)) 。 而题目中的式子等价于： f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)f(0)=0,f(1)=1,f(n)=2f(n-1)+f(n-2)f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)，同样满足这个性质。 （以下集合 TTT 均满足 $T\neq \varnothing $） 再由式子： lcm(S)=∏T⊂Sgcd(T)(−1)∣T∣+1lcm(S)=\prod_{T\subset S}gcd(T)^{(-1)^{|T|+1}} lcm(S)=T⊂S∏​gcd(T)(−1)∣T∣+1 可以得到： g(n)=∏T⊂2[n]f(gcdi∈T(i))(−1)∣T∣+1g(n)=\prod _{T\subset 2^{[n]}}f(gcd_{i\in T}(i))^{(-1)^{|T|+1}} g(n)=T⊂2[n]∏​f(gcdi∈T​(i))(−1)∣T∣+1 构造出 hhh 满足 f(n)=∏d∣nh(d)f(n)=\prod _{d|n}h(d)f(n)=∏d∣n​h(d) 得到式子： g(n)=∏T⊂2[n](∏d∣gcdi∈T(i)h(d))(−1)∣T∣+1=∏d=1nh(d)∑T⊂2 [⌊nd⌋] (−1)∣T∣+1\begin{aligned} g(n)&amp;=\prod _{T\subset 2^{[n]}}\left ( \prod _{d|gcd_{i\in T}(i)}h(d) \right )^{(-1)^{|T|+1}}\\ &amp;=\prod _{d=1}^{n}h(d)^{\sum _{T\subset 2^{~[\lfloor \frac{n}{d}\rfloor ]~}}(-1)^{|T|+1}} \end{aligned} g(n)​=T⊂2[n]∏​⎝⎛​d∣gcdi∈T​(i)∏​h(d)⎠⎞​(−1)∣T∣+1=d=1∏n​h(d)∑T⊂2 [⌊dn​⌋] ​(−1)∣T∣+1​ 又由二项式定理可证： ∑T⊂2[⌊nd⌋](−1)∣T∣+1=−∑i=1nd(−1)i(ndi)=1\sum _{T\subset 2^{[\lfloor \frac{n}{d}\rfloor ]}}(-1)^{|T|+1}=-\sum _{i=1}^{\frac{n}{d}}(-1)^i\binom{\frac{n}{d}}{i}=1 T⊂2[⌊dn​⌋]∑​(−1)∣T∣+1=−i=1∑dn​​(−1)i(idn​​)=1 所以 g(n)=∏d=1nh(d)g(n)=\prod _{d=1}^{n}h(d)g(n)=∏d=1n​h(d) 问题解决，时间复杂度 O(nlogn)O(nlogn)O(nlogn)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;int T,n,mod,inv,sum,ans,f[N],h[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; T=read(); while(T--) &#123; n=read();mod=read(); f[0]=0;h[1]=f[1]=1; for(int i=2;i&lt;=n;i++) h[i]=f[i]=(1ll*f[i-1]*2+f[i-2])%mod; for(int i=1;i&lt;=n;i++) &#123; inv=power(h[i],mod-2); for(int j=i+i;j&lt;=n;j+=i)h[j]=1ll*h[j]*inv%mod; &#125; sum=1;ans=0; for(int i=1;i&lt;=n;i++) sum=1ll*sum*h[i]%mod,ans=(ans+1ll*sum*i)%mod; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2159」Crash的文明世界]]></title>
    <url>%2Fbzoj2159%2F</url>
    <content type="text"><![CDATA[给定一棵 nnn 个节点的树，对于每个节点，计算出：S(i)=∑j=1ndist(i,j)k(mod10007)S(i)=\sum _{j=1}^ndist(i,j)^k \pmod {10007}S(i)=∑j=1n​dist(i,j)k(mod10007)。其中 dist(i,j)dist(i, j)dist(i,j) 表示第 iii 个节点到第 jjj 个节点路径上的边数，kkk 为一个常数且为正整数。 Constraints n≤50000n \leq 50000n≤50000 ，k≤150k \leq 150k≤150 Solution 用结论来化简式子：xn=∑i=1nS(n,i)⋅F(x,i)x^n=\sum _{i=1}^n S(n,i)\cdot F(x,i)xn=∑i=1n​S(n,i)⋅F(x,i) S(n,i)S(n,i)S(n,i)为第二类斯特林数，F(x,i)=x!(x−i)!F(x,i)=\frac{x!}{(x-i)!}F(x,i)=(x−i)!x!​ 可得： ans(i)=∑j=1ndist(i,j)m=∑j=1n∑k=1mS(m,k)⋅F(dist(i,j),k)=∑k=1mS(m,k)∑j=1nF(dist(i,j),k)=∑k=1mS(m,k)⋅k!⋅∑j=1nC(dist(i,j),k)\begin{aligned} ans(i)&amp;=\sum _{j=1}^ndist(i,j)^m\\ &amp;=\sum_{j=1}^{n}\sum_{k=1}^{m}S(m,k)\cdot F(dist(i,j),k)\\ &amp;=\sum_{k=1}^{m}S(m,k)\sum_{j=1}^{n} F(dist(i,j),k)\\ &amp;=\sum_{k=1}^{m}S(m,k)\cdot k!\cdot \sum_{j=1}^{n} C(dist(i,j),k) \end{aligned} ans(i)​=j=1∑n​dist(i,j)m=j=1∑n​k=1∑m​S(m,k)⋅F(dist(i,j),k)=k=1∑m​S(m,k)j=1∑n​F(dist(i,j),k)=k=1∑m​S(m,k)⋅k!⋅j=1∑n​C(dist(i,j),k)​ 根据组合数递推公式：C(n,m)=C(n−1,m)+C(n−1,m−1)C(n,m)=C(n-1,m)+C(n-1,m-1)C(n,m)=C(n−1,m)+C(n−1,m−1) 就可以很方便的对后面的部分进行树形 dp 了。 具体地，令 up(x,i)up(x,i)up(x,i) 为不在 xxx 的子树中的部分的贡献，令 dn(x,i)dn(x,i)dn(x,i) 为 xxx 的子树的贡献。特别的，dn(x,0)=1dn(x,0)=1dn(x,0)=1。 详见代码。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e4+5;const int M=155;const int mod=1e4+7;int n,m,u,v,cnt,ans,tmp;int first[N],fac[M],s[M][M];int up[N][M],dn[N][M];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void dfs1(int x,int fa)&#123; dn[x][0]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs1(to,x); Mod(dn[x][0],dn[to][0]); for(int j=1;j&lt;=m;j++) Mod(dn[x][j],(dn[to][j]+dn[to][j-1])%mod); &#125;&#125;void dfs2(int x,int fa)&#123; if(fa!=-1) &#123; up[x][0]=n-dn[x][0]; for(int i=1;i&lt;=m;i++) &#123; Mod(up[x][i],(up[fa][i]+up[fa][i-1])%mod); Mod(up[x][i],(dn[fa][i]+dn[fa][i-1])%mod); Mod(up[x][i],(2*mod-dn[x][i]-dn[x][i-1])%mod); Mod(up[x][i],(mod-dn[x][i-1])%mod); if(i!=1)Mod(up[x][i],(mod-dn[x][i-2])%mod); &#125; &#125; for(int i=first[x];i;i=e[i].next) if(e[i].to!=fa)dfs2(e[i].to,x);&#125;int main()&#123; int L,now,A,B,Q; n=read();m=read();L=read(); now=read();A=read();B=read();Q=read(); for(int i=1;i&lt;n;i++) &#123; now=(now*A+B)%Q; tmp=i&lt;L?i:L; u=i-now%tmp;v=i+1; ins(u,v);ins(v,u); &#125;// n=read();m=read();// for(int i=1;i&lt;n;i++)// &#123;// u=read();v=read();// ins(u,v);ins(v,u);// &#125; fac[0]=s[0][0]=1; for(int i=1;i&lt;=m;i++) &#123; fac[i]=fac[i-1]*i%mod; for(int j=1;j&lt;=i;j++) s[i][j]=(s[i-1][j]*j+s[i-1][j-1])%mod; &#125; dfs1(1,-1);dfs2(1,-1); for(int i=1;i&lt;=n;i++) &#123; ans=0; for(int j=1;j&lt;=m;j++) Mod(ans,s[m][j]*fac[j]%mod*(up[i][j]+dn[i][j])%mod); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>树形dp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3495」PA2010 Riddle]]></title>
    <url>%2Fbzoj3495%2F</url>
    <content type="text"><![CDATA[有 nnn 个城镇被分成了 kkk 个郡，有 mmm 条连接城镇的无向边。要求给每个郡选择一个城镇作为首都，满足每条边至少有一个端点是首都。 Constraints 1≤n≤1061\leq n \leq 10 ^61≤n≤106 ，0≤m≤1060\leq m \leq 10 ^60≤m≤106 ，1≤k≤n1\leq k \leq n1≤k≤n Solution 每个点 xxx 拆成两对点，xxx 代表选择 xxx 为首都，x+nx+nx+n 表示不选择 xxx 为首都，x+2nx+2nx+2n 表示 xxx 的前缀已包含首都，x+3nx+3nx+3n 表示 xxx 的前缀不包含首都。 对于每一条原图中无向边 (x,y)(x,y)(x,y) ，因为至少有一个端点为首都，连边 (x+n,y)(x+n,y)(x+n,y) ，(y+n,x)(y+n,x)(y+n,x)。 对于每一个点 xxx ，连边 (x,x+2n)(x,x+2n)(x,x+2n) ，(x+3n,x+n)(x+3n,x+n)(x+3n,x+n)。 对于每一个点 xxx 与它的上一个点 lastlastlast ，连边方式如下：(last+2n,x+2n)(last+2n,x+2n)(last+2n,x+2n)，(x+3n,last+3n)(x+3n,last+3n)(x+3n,last+3n)，(last+2n,x+n)(last+2n,x+n)(last+2n,x+n)，(x,last+3n)(x,last+3n)(x,last+3n)。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=4e6+5;int n,m,k,cnt,x,y,last,tim,top,color;int first[N],dfn[N],low[N],sta[N],c[N];bool vis[N];struct edge&#123;int to,next;&#125;e[N*3];void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++tim; sta[++top]=x;vis[x]=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!dfn[to])tarjan(to),low[x]=min(low[x],low[to]=min(low[x],low[to])); else if(vis[to])low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; color++; while(sta[top]!=x)vis[sta[top]]=false,c[sta[top--]]=color; vis[x]=false;c[x]=color;top--; &#125;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) if(c[i]==c[i+n]||c[i+2*n]==c[i+3*n])return false; return true;&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=m;i++) &#123; x=read();y=read(); ins(x+n,y);ins(y+n,x); &#125; for(int i=1;i&lt;=k;i++) &#123; x=read();last=0; for(int j=1;j&lt;=x;j++) &#123; y=read(); ins(y,y+2*n);ins(y+3*n,y+n); if(last) &#123; ins(last+2*n,y+2*n); ins(y+3*n,last+3*n); ins(last+2*n,y+n); ins(y,last+3*n); &#125; last=y; &#125; &#125; for(int i=1;i&lt;=4*n;i++)if(!dfn[i])tarjan(i); if(check())printf("TAK"); else printf("NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>2-SAT</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 983E」NN country]]></title>
    <url>%2Fcf983e%2F</url>
    <content type="text"><![CDATA[给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。 Constraints 2≤n≤2⋅1052\leq n \leq 2\cdot 10 ^52≤n≤2⋅105 ，1≤m≤2⋅1051\leq m \leq 2\cdot 10 ^51≤m≤2⋅105 ，1≤q≤2⋅1051\leq q \leq 2\cdot 10 ^51≤q≤2⋅105 Solution 对于每一条 aaa 与 bbb 间的路径，都可拆分为 aaa 到 lcalcalca 的路径和 bbb 到 lcalcalca 的路径 采用贪心策略， low[x][i]low[x][i]low[x][i] 表示从 xxx 点出发向上选择不超过 2i2^i2i 条链可抵达的深度最浅的点。这时对于每一个询问可将询问的两个端点修改为利用贪心策略跳到的深度大于 lcalcalca 且深度最小的节点，并记录下答案，这个过程可以用倍增完成。注意特判端点即 lcalcalca 的情况。 然后出现两种情况。若修改后的两个端点出现在同一条给定链上，答案为原答案 +1+1+1 ，否则答案为原答案 +2+2+2 。问题模型转换为，每次询问一个点对是否出现在同一条给定链上。记录下 dfs 序，在深搜过程中利用树状数组统计即可。 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int n,m,Q,cnt,val,x,y,ind;int deep[N],in[N],out[N],last[N];int first[N],ans[N],tr[N];int fa[N][20],low[N][20];bool ok[N];vector&lt;int&gt; a[N],b[N];struct edge&#123;int to,next;&#125;e[N];struct chain&#123;int x,y,t;&#125;c[N],q[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x)&#123; in[x]=++ind; for(int i=1;(1&lt;&lt;i)&lt;=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=first[x];i;i=e[i].next) &#123; deep[e[i].to]=deep[x]+1; dfs(e[i].to); &#125; out[x]=ind;&#125;int lca(int x,int y)&#123; if(deep[x]&lt;deep[y])swap(x,y); int d=deep[x]-deep[y]; for(int i=0;(1&lt;&lt;i)&lt;=d;i++) if((1&lt;&lt;i)&amp;d)x=fa[x][i]; if(x==y)return x; for(int i=17;i&gt;=0;i--) if((1&lt;&lt;i)&lt;=deep[x]&amp;&amp;fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfslow(int x)&#123; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to;dfslow(to); if(deep[low[to][0]]&lt;deep[low[x][0]]) low[x][0]=low[to][0]; &#125;&#125;int find(int x,int t)&#123; if(deep[low[x][17]]&gt;deep[t])&#123;val=-inf;return -1;&#125; if(x==t)&#123;val=-1;return 0;&#125; val=0; for(int i=17;i&gt;=0;i--) if(deep[low[x][i]]&gt;deep[t]) x=low[x][i],val|=(1&lt;&lt;i); return x;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x))tr[x]+=v;&#125;int query(int x)&#123;int ans=0;for(;x;x-=lowbit(x))ans+=tr[x];return ans;&#125;void work(int x)&#123; for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; last[t]=query(out[q[t].y])-query(in[q[t].y]-1); &#125; for(int sz=a[x].size(),i=0;i&lt;sz;i++)add(in[a[x][i]],1); for(int i=first[x];i;i=e[i].next)work(e[i].to); for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; if(query(out[q[t].y])-query(in[q[t].y]-1)!=last[t])ok[t]=true; &#125;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) fa[i][0]=read(),ins(fa[i][0],i); dfs(1); for(int i=1;i&lt;=n;i++)low[i][0]=i; m=read(); for(int i=1;i&lt;=m;i++) &#123; c[i].x=read();c[i].y=read(); c[i].t=lca(c[i].x,c[i].y); if(deep[c[i].t]&lt;deep[low[c[i].x][0]]) low[c[i].x][0]=c[i].t; if(deep[c[i].t]&lt;deep[low[c[i].y][0]]) low[c[i].y][0]=c[i].t; a[c[i].x].push_back(c[i].y); a[c[i].y].push_back(c[i].x); &#125; dfslow(1); for(int t=1;t&lt;=n;t++) for(int i=1;i&lt;=17;i++) low[t][i]=low[low[t][i-1]][i-1]; Q=read(); for(int i=1;i&lt;=Q;i++) &#123; q[i].x=read();q[i].y=read(); q[i].t=lca(q[i].x,q[i].y); ans[i]=2; x=find(q[i].x,q[i].t);ans[i]+=val; y=find(q[i].y,q[i].t);ans[i]+=val; if(x&gt;0&amp;&amp;y&gt;0) &#123; q[i].x=x;q[i].y=y; b[x].push_back(i); &#125; &#125; work(1); for(int i=1;i&lt;=Q;i++) if(ok[i])ans[i]--; for(int i=1;i&lt;=Q;i++) printf("%d\n",ans[i]&lt;0?-1:ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>倍增</tag>
        <tag>最近公共祖先</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
</search>
