<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[「BZOJ 4833」[Lydsy1704月赛]最小公倍佩尔数]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj4833%2F</url>
    <content type="text"><![CDATA[令 (1+2)n=e(n)+2⋅f(n)(1+\sqrt 2)^n=e(n)+\sqrt 2\cdot f(n)(1+2​)n=e(n)+2​⋅f(n) ，其中 e(n),f(n)e(n),f(n)e(n),f(n) 都是整数，显然有 (1−2)n=e(n)−2⋅f(n)(1-\sqrt 2)^n=e(n)-\sqrt 2\cdot f(n)(1−2​)n=e(n)−2​⋅f(n)。令 g(n)g(n)g(n) 表示 f(1),f(2),⋯,f(n)f(1),f(2),\cdots ,f(n)f(1),f(2),⋯,f(n) 的最小公倍数，给定两个正整数 nnn 和 ppp ，其中 ppp 是质数，并且保证 f(1),f(2),⋯,f(n)f(1),f(2),\cdots ,f(n)f(1),f(2),⋯,f(n) 在模 ppp 意义下均不为 000，请计算 ∑i=1ni⋅g(i)\sum _{i=1}^{n}i\cdot g(i)∑i=1n​i⋅g(i) 模 ppp 的值。 Solution 在开始推导前先观察两个式子： gcd(fib(a),fib(b))=fib(gcd(a,b))gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(fib(a),fib(b))=fib(gcd(a,b)) gcd(xa−1,xb−1)=xgcd(a,b)−1gcd(x^a-1,x^b-1)=x^{gcd(a,b)}-1 gcd(xa−1,xb−1)=xgcd(a,b)−1 形如 f(n)=a⋅f(n−1)+b⋅f(n−2)f(n)=a\cdot f(n-1)+b\cdot f(n-2)f(n)=a⋅f(n−1)+b⋅f(n−2) 的式子具有性质 gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y))gcd(f(x),f(y))=f(gcd(x,y)) 。 而题目中的式子等价于： f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)f(0)=0,f(1)=1,f(n)=2f(n-1)+f(n-2)f(0)=0,f(1)=1,f(n)=2f(n−1)+f(n−2)，同样满足这个性质。 （以下集合 TTT 均满足 $T\neq \varnothing $） 再由式子： lcm(S)=∏T⊂Sgcd(T)(−1)∣T∣+1lcm(S)=\prod_{T\subset S}gcd(T)^{(-1)^{|T|+1}} lcm(S)=T⊂S∏​gcd(T)(−1)∣T∣+1 可以得到： g(n)=∏T⊂2[n]f(gcdi∈T(i))(−1)∣T∣+1g(n)=\prod _{T\subset 2^{[n]}}f(gcd_{i\in T}(i))^{(-1)^{|T|+1}} g(n)=T⊂2[n]∏​f(gcdi∈T​(i))(−1)∣T∣+1 构造出 hhh 满足 f(n)=∏d∣nh(d)f(n)=\prod _{d|n}h(d)f(n)=∏d∣n​h(d) 得到式子： g(n)=∏T⊂2[n](∏d∣gcdi∈T(i)h(d))(−1)∣T∣+1=∏d=1nh(d)∑T⊂2 [⌊nd⌋] (−1)∣T∣+1\begin{aligned} g(n)&amp;=\prod _{T\subset 2^{[n]}}\left ( \prod _{d|gcd_{i\in T}(i)}h(d) \right )^{(-1)^{|T|+1}}\\ &amp;=\prod _{d=1}^{n}h(d)^{\sum _{T\subset 2^{~[\lfloor \frac{n}{d}\rfloor ]~}}(-1)^{|T|+1}} \end{aligned} g(n)​=T⊂2[n]∏​⎝⎛​d∣gcdi∈T​(i)∏​h(d)⎠⎞​(−1)∣T∣+1=d=1∏n​h(d)∑T⊂2 [⌊dn​⌋] ​(−1)∣T∣+1​ 又由二项式定理可证： ∑T⊂2[⌊nd⌋](−1)∣T∣+1=−∑i=1nd(−1)i(ndi)=1\sum _{T\subset 2^{[\lfloor \frac{n}{d}\rfloor ]}}(-1)^{|T|+1}=-\sum _{i=1}^{\frac{n}{d}}(-1)^i\binom{\frac{n}{d}}{i}=1 T⊂2[⌊dn​⌋]∑​(−1)∣T∣+1=−i=1∑dn​​(−1)i(idn​​)=1 所以 g(n)=∏d=1nh(d)g(n)=\prod _{d=1}^{n}h(d)g(n)=∏d=1n​h(d) 问题解决，时间复杂度 O(nlogn)O(nlogn)O(nlogn)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=1e6+5;int T,n,mod,inv,sum,ans,f[N],h[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;int power(int a,int b)&#123; int ans=1; while(b) &#123; if(b&amp;1)ans=1ll*ans*a%mod; a=1ll*a*a%mod;b&gt;&gt;=1; &#125; return ans;&#125;int main()&#123; T=read(); while(T--) &#123; n=read();mod=read(); f[0]=0;h[1]=f[1]=1; for(int i=2;i&lt;=n;i++) h[i]=f[i]=(1ll*f[i-1]*2+f[i-2])%mod; for(int i=1;i&lt;=n;i++) &#123; inv=power(h[i],mod-2); for(int j=i+i;j&lt;=n;j+=i)h[j]=1ll*h[j]*inv%mod; &#125; sum=1;ans=0; for(int i=1;i&lt;=n;i++) sum=1ll*sum*h[i]%mod,ans=(ans+1ll*sum*i)%mod; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数论</tag>
        <tag>容斥原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2159」Crash的文明世界]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj2159%2F</url>
    <content type="text"><![CDATA[给定一棵 nnn 个节点的树，对于每个节点，计算出：S(i)=∑j=1ndist(i,j)k(mod10007)S(i)=\sum _{j=1}^ndist(i,j)^k \pmod {10007}S(i)=∑j=1n​dist(i,j)k(mod10007)。其中 dist(i,j)dist(i, j)dist(i,j) 表示第 iii 个节点到第 jjj 个节点路径上的边数，kkk 为一个常数且为正整数。 Solution 用结论来化简式子：xn=∑i=1nS(n,i)⋅F(x,i)x^n=\sum _{i=1}^n S(n,i)\cdot F(x,i)xn=∑i=1n​S(n,i)⋅F(x,i) S(n,i)S(n,i)S(n,i)为第二类斯特林数，F(x,i)=x!(x−i)!F(x,i)=\frac{x!}{(x-i)!}F(x,i)=(x−i)!x!​ 可得： ans(i)=∑j=1ndist(i,j)m=∑j=1n∑k=1mS(m,k)⋅F(dist(i,j),k)=∑k=1mS(m,k)∑j=1nF(dist(i,j),k)=∑k=1mS(m,k)⋅k!⋅∑j=1nC(dist(i,j),k)\begin{aligned} ans(i)&amp;=\sum _{j=1}^ndist(i,j)^m\\ &amp;=\sum_{j=1}^{n}\sum_{k=1}^{m}S(m,k)\cdot F(dist(i,j),k)\\ &amp;=\sum_{k=1}^{m}S(m,k)\sum_{j=1}^{n} F(dist(i,j),k)\\ &amp;=\sum_{k=1}^{m}S(m,k)\cdot k!\cdot \sum_{j=1}^{n} C(dist(i,j),k) \end{aligned} ans(i)​=j=1∑n​dist(i,j)m=j=1∑n​k=1∑m​S(m,k)⋅F(dist(i,j),k)=k=1∑m​S(m,k)j=1∑n​F(dist(i,j),k)=k=1∑m​S(m,k)⋅k!⋅j=1∑n​C(dist(i,j),k)​ 根据组合数递推公式：C(n,m)=C(n−1,m)+C(n−1,m−1)C(n,m)=C(n-1,m)+C(n-1,m-1)C(n,m)=C(n−1,m)+C(n−1,m−1) 就可以很方便的对后面的部分进行树形dp了。 具体地，令 up(x,i)up(x,i)up(x,i) 为不在 xxx 的子树中的部分的贡献，令 dn(x,i)dn(x,i)dn(x,i) 为 xxx 的子树的贡献。特别的，dn(x,0)=1dn(x,0)=1dn(x,0)=1。 详见代码。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=5e4+5;const int M=155;const int mod=1e4+7;int n,m,u,v,cnt,ans,tmp;int first[N],fac[M],s[M][M];int up[N][M],dn[N][M];struct edge&#123;int to,next;&#125;e[N*2];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void Mod(int&amp; a,int b)&#123;a+=b;if(a&gt;=mod)a-=mod;&#125;void dfs1(int x,int fa)&#123; dn[x][0]=1; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(to==fa)continue; dfs1(to,x); Mod(dn[x][0],dn[to][0]); for(int j=1;j&lt;=m;j++) Mod(dn[x][j],(dn[to][j]+dn[to][j-1])%mod); &#125;&#125;void dfs2(int x,int fa)&#123; if(fa!=-1) &#123; up[x][0]=n-dn[x][0]; for(int i=1;i&lt;=m;i++) &#123; Mod(up[x][i],(up[fa][i]+up[fa][i-1])%mod); Mod(up[x][i],(dn[fa][i]+dn[fa][i-1])%mod); Mod(up[x][i],(2*mod-dn[x][i]-dn[x][i-1])%mod); Mod(up[x][i],(mod-dn[x][i-1])%mod); if(i!=1)Mod(up[x][i],(mod-dn[x][i-2])%mod); &#125; &#125; for(int i=first[x];i;i=e[i].next) if(e[i].to!=fa)dfs2(e[i].to,x);&#125;int main()&#123; int L,now,A,B,Q; n=read();m=read();L=read(); now=read();A=read();B=read();Q=read(); for(int i=1;i&lt;n;i++) &#123; now=(now*A+B)%Q; tmp=i&lt;L?i:L; u=i-now%tmp;v=i+1; ins(u,v);ins(v,u); &#125;// n=read();m=read();// for(int i=1;i&lt;n;i++)// &#123;// u=read();v=read();// ins(u,v);ins(v,u);// &#125; fac[0]=s[0][0]=1; for(int i=1;i&lt;=m;i++) &#123; fac[i]=fac[i-1]*i%mod; for(int j=1;j&lt;=i;j++) s[i][j]=(s[i-1][j]*j+s[i-1][j-1])%mod; &#125; dfs1(1,-1);dfs2(1,-1); for(int i=1;i&lt;=n;i++) &#123; ans=0; for(int j=1;j&lt;=m;j++) Mod(ans,s[m][j]*fac[j]%mod*(up[i][j]+dn[i][j])%mod); printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>树形dp</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 3495」PA2010 Riddle]]></title>
    <url>%2F2018%2F05%2F22%2Fbzoj3495%2F</url>
    <content type="text"><![CDATA[有 nnn 个城镇被分成了 kkk 个郡，有 mmm 条连接城镇的无向边。要求给每个郡选择一个城镇作为首都，满足每条边至少有一个端点是首都。 Solution 每个点 xxx 拆成两对点，xxx 代表选择 xxx 为首都，x+nx+nx+n 表示不选择 xxx 为首都，x+2nx+2nx+2n 表示 xxx 的前缀已包含首都，x+3nx+3nx+3n表示 xxx 的前缀不包含首都。 对于每一条原图中无向边 (x,y)(x,y)(x,y) ，因为至少有一个端点为首都，连边 (x+n,y)(x+n,y)(x+n,y) ，(y+n,x)(y+n,x)(y+n,x)。 对于每一个点 xxx ，连边 (x,x+2n)(x,x+2n)(x,x+2n) ，(x+3n,x+n)(x+3n,x+n)(x+3n,x+n)。 对于每一个点 xxx 与它的上一个点 lastlastlast ，连边方式如下：(last+2n,x+2n)(last+2n,x+2n)(last+2n,x+2n)，(x+3n,last+3n)(x+3n,last+3n)(x+3n,last+3n)，(last+2n,x+n)(last+2n,x+n)(last+2n,x+n)，(x,last+3n)(x,last+3n)(x,last+3n)。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#define LL long longusing namespace std;const int N=4e6+5;int n,m,k,cnt,x,y,last,tim,top,color;int first[N],dfn[N],low[N],sta[N],c[N];bool vis[N];struct edge&#123;int to,next;&#125;e[N*3];void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void tarjan(int x)&#123; low[x]=dfn[x]=++tim; sta[++top]=x;vis[x]=true; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to; if(!dfn[to])tarjan(to),low[x]=min(low[x],low[to]=min(low[x],low[to])); else if(vis[to])low[x]=min(low[x],dfn[to]); &#125; if(low[x]==dfn[x]) &#123; color++; while(sta[top]!=x)vis[sta[top]]=false,c[sta[top--]]=color; vis[x]=false;c[x]=color;top--; &#125;&#125;bool check()&#123; for(int i=1;i&lt;=n;i++) if(c[i]==c[i+n]||c[i+2*n]==c[i+3*n])return false; return true;&#125;int main()&#123; n=read();m=read();k=read(); for(int i=1;i&lt;=m;i++) &#123; x=read();y=read(); ins(x+n,y);ins(y+n,x); &#125; for(int i=1;i&lt;=k;i++) &#123; x=read();last=0; for(int j=1;j&lt;=x;j++) &#123; y=read(); ins(y,y+2*n);ins(y+3*n,y+n); if(last) &#123; ins(last+2*n,y+2*n); ins(y+3*n,last+3*n); ins(last+2*n,y+n); ins(y,last+3*n); &#125; last=y; &#125; &#125; for(int i=1;i&lt;=4*n;i++)if(!dfn[i])tarjan(i); if(check())printf("TAK"); else printf("NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>2-SAT</tag>
        <tag>tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 983E」NN country]]></title>
    <url>%2F2018%2F05%2F21%2Fcf983E%2F</url>
    <content type="text"><![CDATA[给定一棵 nnn 个点的树， mmm 条链， qqq 个询问，每次询问 aaa 到 bbb 之间的路径最少可用几条给定链完全覆盖，无解输出 −1-1−1 。 Solution 对于每一条 aaa 与 bbb 间的路径，都可拆分为 aaa 到 lcalcalca 的路径和 bbb 到 lcalcalca 的路径 采用贪心策略， low[x][i]low[x][i]low[x][i] 表示从 xxx 点出发向上选择不超过 2i2^i2i 条链可抵达的深度最浅的点。这时对于每一个询问可将询问的两个端点修改为利用贪心策略跳到的深度大于 lcalcalca 且深度最小的节点，并记录下答案，这个过程可以用倍增完成。注意特判端点即 lcalcalca 的情况。 然后出现两种情况。若修改后的两个端点出现在同一条给定链上，答案为原答案 +1+1+1 ，否则答案为原答案 +2+2+2 。问题模型转换为，每次询问一个点对是否出现在同一条给定链上。记录下 dfsdfsdfs 序，在深搜过程中利用树状数组统计即可。 时间复杂度 O(nlogn)O(nlogn)O(nlogn) 。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#define LL long longusing namespace std;const int N=2e5+5;const int inf=0x3f3f3f3f;int n,m,Q,cnt,val,x,y,ind;int deep[N],in[N],out[N],last[N];int first[N],ans[N],tr[N];int fa[N][20],low[N][20];bool ok[N];vector&lt;int&gt; a[N],b[N];struct edge&#123;int to,next;&#125;e[N];struct chain&#123;int x,y,t;&#125;c[N],q[N];int read()&#123; int x=0,f=1;char c=getchar(); while(c&lt;'0'||c&gt;'9')&#123;if(c=='-')f=-1;c=getchar();&#125; while(c&gt;='0'&amp;&amp;c&lt;='9')&#123;x=x*10+c-'0';c=getchar();&#125; return x*f;&#125;void ins(int u,int v)&#123;e[++cnt]=(edge)&#123;v,first[u]&#125;;first[u]=cnt;&#125;void dfs(int x)&#123; in[x]=++ind; for(int i=1;(1&lt;&lt;i)&lt;=deep[x];i++) fa[x][i]=fa[fa[x][i-1]][i-1]; for(int i=first[x];i;i=e[i].next) &#123; deep[e[i].to]=deep[x]+1; dfs(e[i].to); &#125; out[x]=ind;&#125;int lca(int x,int y)&#123; if(deep[x]&lt;deep[y])swap(x,y); int d=deep[x]-deep[y]; for(int i=0;(1&lt;&lt;i)&lt;=d;i++) if((1&lt;&lt;i)&amp;d)x=fa[x][i]; if(x==y)return x; for(int i=17;i&gt;=0;i--) if((1&lt;&lt;i)&lt;=deep[x]&amp;&amp;fa[x][i]!=fa[y][i]) x=fa[x][i],y=fa[y][i]; return fa[x][0];&#125;void dfslow(int x)&#123; for(int i=first[x];i;i=e[i].next) &#123; int to=e[i].to;dfslow(to); if(deep[low[to][0]]&lt;deep[low[x][0]]) low[x][0]=low[to][0]; &#125;&#125;int find(int x,int t)&#123; if(deep[low[x][17]]&gt;deep[t])&#123;val=-inf;return -1;&#125; if(x==t)&#123;val=-1;return 0;&#125; val=0; for(int i=17;i&gt;=0;i--) if(deep[low[x][i]]&gt;deep[t]) x=low[x][i],val|=(1&lt;&lt;i); return x;&#125;int lowbit(int x)&#123;return x&amp;(-x);&#125;void add(int x,int v)&#123;for(;x&lt;=n;x+=lowbit(x))tr[x]+=v;&#125;int query(int x)&#123;int ans=0;for(;x;x-=lowbit(x))ans+=tr[x];return ans;&#125;void work(int x)&#123; for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; last[t]=query(out[q[t].y])-query(in[q[t].y]-1); &#125; for(int sz=a[x].size(),i=0;i&lt;sz;i++)add(in[a[x][i]],1); for(int i=first[x];i;i=e[i].next)work(e[i].to); for(int sz=b[x].size(),i=0;i&lt;sz;i++) &#123; int t=b[x][i]; if(query(out[q[t].y])-query(in[q[t].y]-1)!=last[t])ok[t]=true; &#125;&#125;int main()&#123; n=read(); for(int i=2;i&lt;=n;i++) fa[i][0]=read(),ins(fa[i][0],i); dfs(1); for(int i=1;i&lt;=n;i++)low[i][0]=i; m=read(); for(int i=1;i&lt;=m;i++) &#123; c[i].x=read();c[i].y=read(); c[i].t=lca(c[i].x,c[i].y); if(deep[c[i].t]&lt;deep[low[c[i].x][0]]) low[c[i].x][0]=c[i].t; if(deep[c[i].t]&lt;deep[low[c[i].y][0]]) low[c[i].y][0]=c[i].t; a[c[i].x].push_back(c[i].y); a[c[i].y].push_back(c[i].x); &#125; dfslow(1); for(int t=1;t&lt;=n;t++) for(int i=1;i&lt;=17;i++) low[t][i]=low[low[t][i-1]][i-1]; Q=read(); for(int i=1;i&lt;=Q;i++) &#123; q[i].x=read();q[i].y=read(); q[i].t=lca(q[i].x,q[i].y); ans[i]=2; x=find(q[i].x,q[i].t);ans[i]+=val; y=find(q[i].y,q[i].t);ans[i]+=val; if(x&gt;0&amp;&amp;y&gt;0) &#123; q[i].x=x;q[i].y=y; b[x].push_back(i); &#125; &#125; work(1); for(int i=1;i&lt;=Q;i++) if(ok[i])ans[i]--; for(int i=1;i&lt;=Q;i++) printf("%d\n",ans[i]&lt;0?-1:ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>树状数组</tag>
        <tag>倍增</tag>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
</search>
